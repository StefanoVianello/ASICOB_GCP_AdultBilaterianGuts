---
title: "R Notebook"
output: html_notebook
---

### All TFs

```{r, fig.width= 10, fig.height=4, echo=FALSE}
#A lot of variability and associations int he datasat are either driven, or organised aorund clownfish liver, sea urchin phatynx + oesophagus, or Pf Co+Pr
#Let us see what happens if we remove them from the analysis (of course, we loose the information about what tissue they may be similar to in other species)

#load and  subset merged_metadata
load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/merged_metadata.rds") #merged_metadata
merged_metadata <- merged_metadata[!(row(merged_metadata)[,1] %in% c(1,2,3, #Ao liver
                                                                     22,23,24,25, #Bf endostyle
                                                                     42, 43, 44,45,46,47, #Pf anterior 2
                                                                     #71,72,73,75,76,77,78,79, 80,81,82,
                                                                     111,112,113, 114,115, 116 #Pd mouh
                                                                     )),]
merged_metadata$segment <- factor(merged_metadata$segment, levels = unique(merged_metadata$segment))

#recreate zscored matrix without considering the values of those samples
load("Z://01_Stefano/Collaboration_Data/Annotations/merged_counts.rds") #merged_counts

zcounts_Ao <- merged_counts[ , 4:21]
zcounts_Bf <- merged_counts[ , 26:41]
zcounts_Pf <- merged_counts[ , 48:74]
zcounts_Sp <- merged_counts[ , 75:110]
zcounts_Pd <- merged_counts[ , 117:140]

zcounts_Ao <- t(scale(t(zcounts_Ao)))
zcounts_Bf <- t(scale(t(zcounts_Bf)))
zcounts_Pf <- t(scale(t(zcounts_Pf)))
zcounts_Sp <- t(scale(t(zcounts_Sp)))
zcounts_Pd <- t(scale(t(zcounts_Pd)))

#some genes have the same values in all samples, and give NaN when z-scored
#replace Nan with 0
zcounts_Ao[is.na(zcounts_Ao)] <- 0
zcounts_Bf[is.na(zcounts_Bf)] <- 0
zcounts_Pf[is.na(zcounts_Pf)] <- 0
zcounts_Sp[is.na(zcounts_Sp)] <- 0
zcounts_Pd[is.na(zcounts_Pd)] <- 0

zmerged_counts <- Reduce(merge, lapply(list(zcounts_Ao, zcounts_Bf, zcounts_Pf, zcounts_Sp, zcounts_Pd), data.table, keep.rownames = TRUE, key = "rn"))
zmerged_counts <- as.data.frame(zmerged_counts)

#remove extra col
rownames(zmerged_counts) <- zmerged_counts$rn
zmerged_counts <- zmerged_counts[,2:ncol(zmerged_counts)]



```

```{r, fig.width= 10, fig.height=4, echo=FALSE}



#### AVERAGE OR NOT? (comment/uncomment)
zmerged_counts_averaged <- data.frame(matrix(nrow=nrow(zmerged_counts),ncol=0))
group_indeces <- c(0, cumsum(unname( table(merged_metadata$segment))))
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- zmerged_counts[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  zmerged_counts_averaged <- cbind(zmerged_counts_averaged, tmp_averages)
  
}
colnames(zmerged_counts_averaged) <- paste0(unique(merged_metadata$segment), "_mean")
zmerged_counts<- zmerged_counts_averaged

merged_metadata_averaged <- merged_metadata
merged_metadata_averaged <- merged_metadata_averaged[!duplicated(merged_metadata_averaged$segment),]
rownames(merged_metadata_averaged) <- paste0(merged_metadata_averaged$segment, "_mean")
merged_metadata <- merged_metadata_averaged
###


#5839 genes
```


```{r}

load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species.rds") #shared_TFs_8species [356]
#subset with only TF orthogroups
zmerged_counts_TFs <- zmerged_counts[rownames(zmerged_counts) %in% shared_TFs_8species,] #277 orthogroups left
shared_TFs_8species_expressed <- rownames(zmerged_counts_TFs)


#save(shared_TFs_8species_expressed, file="Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species_expressed.rds")

```


```{r}
# transpose our counts matrix (switch rows and columns)
counts_VST_top2000_transposed <- t(zmerged_counts_TFs) #277
```

### PCA

```{r}

#we can now calculate PCA (on the top 2000 genes)
PCAobject_top2000 <- prcomp(x=counts_VST_top2000_transposed, center = T, scale. = T)

# Plot Scree Plot of our data "WHY WE USE STANDART DEV^2? WHAT IS 100, WHAT IS 2?
{barplot(round(PCAobject_top2000$sdev^2/sum(PCAobject_top2000$sdev^2)*100,2),
         las=2,
         names.arg=colnames(PCAobject_top2000$x),
         ylab="% Variance explained",
         xlab="PCA principal components",
         ylim =range(pretty(c(0, 25))),
         xlim = c(0,25),
         main = "Scree plot (277common transcription factors)"
         )
abline(h=100/length(colnames(PCAobject_top2000$x)), lty=2, col="dodgerblue")}


```
```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_PCA.pdf")

{barplot(round(PCAobject_top2000$sdev^2/sum(PCAobject_top2000$sdev^2)*100,2),
         las=2,
         names.arg=colnames(PCAobject_top2000$x),
         ylab="% Variance explained",
         xlab="PCA principal components",
         ylim =range(pretty(c(0, 25))),
         xlim = c(0,25),
         main = "Scree plot (277common transcription factors)"
         )
abline(h=100/length(colnames(PCAobject_top2000$x)), lty=2, col="dodgerblue")}

dev.off()
```


```{r}
#find cumulative variance explained 
round(cumsum((PCAobject_top2000$sdev^2/sum(PCAobject_top2000$sdev^2)*100)),2)
```


```{r, fig.width= 12, fig.height=9, echo=FALSE}
## PCA (segment colour code)
#View(PCAobject_top2000$x)
#View(PCAobject_top2000)
#check the proportion of variance value
#view (summary(PCAobject_top2000)$importance)
#View(sample_metadata)
# we will use ggplot, so we need to add a column with the sample names to our data
PCAobject_top2000_ggplot <- merge(as.data.frame(PCAobject_top2000$x),
                                  merged_metadata, #we are merging with a dataframe that has a column "segment" and "replicate" for each sample
                                  by=0)


plot1a <- ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC2,colour=species, shape=species ))+
  geom_point(size=3)+
  #scale_color_manual(values = rep("gray30", 3))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="right")

plot1b <- ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC2,colour=segment, shape=species ))+
  geom_point(size=3)+
  #scale_color_manual(values = rep("gray30", 3))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="right")



plot2a <- ggplot(PCAobject_top2000_ggplot,
       aes(PC3,PC2,colour=species, shape=species))+
  geom_point(size=3)+
  #scale_color_manual(values = rep("gray30", 3))+
  #scale_shape_manual(values = c(24, 23, 22 ))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  xlab(paste("PC3 (", round(summary(PCAobject_top2000)$importance[8]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="right")


plot2b <- ggplot(PCAobject_top2000_ggplot,
       aes(PC3,PC2,colour=segment, shape=replicate))+
  geom_point(size=3)+
  #scale_color_manual(values = rep("gray30", 3))+
  #scale_shape_manual(values = c(24, 23, 22 ))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  xlab(paste("PC3 (", round(summary(PCAobject_top2000)$importance[8]*100,2), "%)")) + 
  ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="right")


plot3a <- ggplot(PCAobject_top2000_ggplot,
       aes(PC3,PC4,colour=species, shape=species))+
  geom_point(size=3)+
  #scale_color_manual(values = rep("gray30", 3))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  theme_classic()+ theme(legend.position="right")

plot3b <- ggplot(PCAobject_top2000_ggplot,
       aes(PC3,PC4,colour=segment, shape=replicate))+
  geom_point(size=3)+
  #scale_color_manual(values = rep("gray30", 3))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  theme_classic()+ theme(legend.position="right")



grid.arrange(plot1a, plot1b, 
             plot2a, plot2b,
             plot3a, plot3b,
             ncol=2, nrow=3)

#remove unused variables
#rm(plot1, plot2, plot3)

```

```{r}
color_categorical_segment <- c("skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "orchid",
                               "skyblue2", "indianred", "goldenrod1", "orchid",
                               "skyblue2", "skyblue2", "skyblue2", "dodgerblue", "indianred", "indianred", "magenta", "magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "goldenrod1","goldenrod1", "magenta","magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "magenta", "orchid", "orchid")
names(color_categorical_segment) <- paste0(unique(merged_metadata$segment), "_mean")
color_categorical_segment_named <- color_categorical_segment
```


```{r, fig.height=8, fig.width=8}
image <- ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC2,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="bottom")

plot(image)

```
```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_PCA.pdf")

plot(image)

dev.off()
```
```{r, fig.height=4, fig.width=4}
ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC3,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC4,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC5,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC6,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC7,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC8,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC9,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC10,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC11,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC12,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC13,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC14,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

ggplot(PCAobject_top2000_ggplot,
       aes(PC1,PC15,colour=segment, shape=species ))+
  geom_point(size=4)+
  scale_color_manual(values = unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  xlim(-20, 20)+
  #ylim(-100, 100)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="none")

```




### UMAP

```{r}

#install.packages("uwot")
library(uwot)
```


```{r}
umap <- uwot::umap2(t(zmerged_counts_TFs), 
                     n_components = 20,
             #n_neighbors = 15, min_dist = 0.001, 
             verbose = TRUE
             )


UMAPobject_ggplot <- merge(as.data.frame(umap),
                                  merged_metadata, #we are merging with a dataframe that has a column "segment" and "replicate" for each sample
                                  by=0)

#sUMAPobject_ggplot <- merge(as.data.frame(umap_seurat@cell.embeddings),
#                                  merged_metadata, #we are merging with a dataframe that has a column "segment" and "replicate" for each sample
#                                  by=0)
```



```{r, fig.height=8}
#library(rphylopic)
ggplot(UMAPobject_ggplot,
       aes(V1,V2,colour=species, shape=species ))+
  geom_point(size=3)+
  #scale_color_manual(values = color_categorical_all)+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="bottom")


ggplot(UMAPobject_ggplot,
       aes(V1,V2,colour=segment, shape=species ))+
  geom_point(size=3)+
  scale_color_manual(values =  unname(color_categorical_segment))+
  #scale_shape_manual(values = c(24, 23, 22))+ 
  #scale_fill_manual(values = color_categorical_segment)+
  #xlim(-55, 55)+
  #ylim(-55, 55)+
  #xlab(paste("PC1 (", round(summary(PCAobject_top2000)$importance[2]*100,2), "%)")) + 
  #ylab(paste("PC2 (", round(summary(PCAobject_top2000)$importance[5]*100,2), "%)"))+
  theme_classic()+ theme(legend.position="bottom")
```

```{r}
plot_ly(data = UMAPobject_ggplot, 
        x = ~V1, y = ~V2, z = ~V3, 
        color = ~segment, 
        #symbol = ~species,
        colors = unname(color_categorical_segment),
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~segment, #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names



```




#### find main drivers of PC1

```{r, echo=FALSE}
##plot top 50 contributing genes to PCA1 (liver vs others)
#find list of top (50) contributing genes
contrib_data <- factoextra::fviz_contrib(PCAobject_top2000, choice = "var", 
                             axes = 1, 
                             top = 50
                             )

#PC1PC2_TOP50_contributors <- contrib_data[["plot_env"]][["data_sum"]][["name"]]
PC1_TOP50_contributors <- data.frame("orthogroup" = sapply(contrib_data[["plot_env"]][["data_sum"]][["name"]], as.character), 
                                        "contribution to PC1" = contrib_data[["plot_env"]][["data_sum"]][["contrib"]])



#add a column with the ocellaris gene for that orthogroup
PC1_TOP50_contributors$Ao_geneID <- dictionary_orthogroups_best_withHox_genebased$Ao[match(PC1_TOP50_contributors$orthogroup ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

PC1_TOP50_contributors$Ao_description <- annotation_info_Ao$merged_description[match(PC1_TOP50_contributors$Ao_geneID ,annotation_info_Ao$entrez_ID)] 



#rearrange column order
PC1_TOP50_contributors <- PC1_TOP50_contributors[,c(1, 3,4,2)]

#list top contributing genes
kable(PC1_TOP50_contributors, caption = "Top50 genes driving PC1 separation")

#save dataframe for manual annotation
#write.csv(PC1PC2_TOP50_contributors,"C://Users/Doctor/Desktop/RNAseq_analyses/Aocellaris_metamorphosis/Saved_objects/PC1PC2_TOP50_contributors_onTop1000variantgenes.csv",row.names = FALSE)


## Formattable output

formattable_output <- formattable(PC1_TOP50_contributors, 
             caption ="Top50 genes driving PC1 separation",
            align =c("c","l", "l", "c"), 
            list(`Ao_geneID` = formatter("span", 
                                      style = x ~ formattable::style(
                                        color = "#A9A9A9", font.weight = "bold")
                                      ), 
                 `Ao_description` = formatter("span", 
                                      style = x ~ formattable::style(
                                        color = "#A9A9A9")
                                      ), 
                 `contribution.to.PC1`= color_tile(NA,"lightcoral")

                 )
            )

formattable_output

#removed unused variables
rm(contrib_data)

```

```{r}
formattable_output <- as.datatable(formattable_output, options = list(pageLength = 10)) 
htmlwidgets::saveWidget(formattable_output, "Z://01_Stefano/Collaboration_Data/Figure_elements/TF_PC1drivers_formattable.html", selfcontained = T) 
```

```{r, fig.width=10, fig.height=60, echo=FALSE}
#http://agroninfotech.blogspot.com/2020/06/biplot-for-pcs-using-base-graphic.html
# we can now verify how these top 50 genes actually move our samples across dimensions
# define palette
mypalette <- brewer.pal(9,"RdBu") #function. “RdYlBu” is a common choice, and “Spectral” is also nice.
morecols <- colorRampPalette(mypalette)
colorrange=rev(morecols(100))


#set rows and columns (4)
par(mfrow=c((length(unlist(PC1_TOP50_contributors["orthogroup"]))/3)+1,3))



#plot loop
for (i in 1:length(unlist(PC1_TOP50_contributors["orthogroup"]))) {
  gene_of_interest <- unlist(PC1_TOP50_contributors["orthogroup"])[i]
  
  #normalise values of expression for gene X (e.g hbae5)
  #colorvalues <- 100*(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))/(max(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))) #transpose all values above 0 by adding minimal value (could be negative) to all. The normalised by max intensity to 1. Then on 100 scale
  colorvalues <- 100*((counts_VST_top2000_transposed[,gene_of_interest]-min(counts_VST_top2000_transposed[,gene_of_interest]))/((max(counts_VST_top2000_transposed[,gene_of_interest]))-(min(counts_VST_top2000_transposed[,gene_of_interest]))))
  
  
  #color datapoints (observations) by expression level
  par(pty = "s",
    cex.main = 1.2,
    cex.lab = 1,
    font.main = 2,
    font.lab = 2,
    family = "sans",
    col.main = "gray10",
    col.lab = "gray10",
    fg = "gray10",
    las = 1)
  
  plot.new()
  
  #we are first going to plot the different conditions (samples), which are in PCAobject_top2000$x 
  plot.window(xlim = extendrange(range(PCAobject_top2000$x[, 1]), f = 0.1), 
            ylim = extendrange(range(PCAobject_top2000$x[, 2]), f = 0.1), 
            asp = 1)
  axis(side = 1, 
     labels = TRUE)
  axis(side = 2, 
     labels = TRUE)
  title(main = PC1_TOP50_contributors$Ao_description[match(gene_of_interest, PC1_TOP50_contributors$orthogroup)],
        xlab = paste("PC 1 (", 
                   round(summary(PCAobject_top2000)$importance[2]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      ylab = paste("PC 2 (", 
                   round(summary(PCAobject_top2000)$importance[5]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      #line = 2,
      adj = 0.5)
  
  # plot the different conditions (samples)
  points(x = PCAobject_top2000$x[,c(1,2)],
       pch = 16,
       cex = 2,
       col = colorrange[colorvalues]
       #col = rep(c("black","gray50", "gray35"),each=7)
       )
  
  #text(PCAobject_top2000$x[,1:2]-5, 
  #     labels = row.names(PCAobject_top2000$x), 
  #     cex = 0.8,
  #     font = 2,
  #     col = "black"
  #     )
  
  
}


#remove unused variables
#rm(colorrange, colorvalues, gene_of_interest, i, mypalette, morecols)
```

```{r, fig.width=10, fig.height=60, echo=FALSE}
#http://agroninfotech.blogspot.com/2020/06/biplot-for-pcs-using-base-graphic.html
# we can now verify how these top 50 genes actually move our samples across dimensions
# define palette
mypalette <- brewer.pal(9,"RdBu") #function. “RdYlBu” is a common choice, and “Spectral” is also nice.
morecols <- colorRampPalette(mypalette)
colorrange=rev(morecols(100))


#set rows and columns (4)
par(mfrow=c((length(unlist(PC1_TOP50_contributors["orthogroup"]))/3)+1,3))


pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_PCAdrivers_plots.pdf")

#plot loop
for (i in 1:length(unlist(PC1_TOP50_contributors["orthogroup"]))) {
  gene_of_interest <- unlist(PC1_TOP50_contributors["orthogroup"])[i]
  
  #normalise values of expression for gene X (e.g hbae5)
  #colorvalues <- 100*(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))/(max(counts_VST_top1000_transposed[,gene_of_interest]+abs(min(counts_VST_top1000_transposed[,gene_of_interest])))) #transpose all values above 0 by adding minimal value (could be negative) to all. The normalised by max intensity to 1. Then on 100 scale
  colorvalues <- 100*((counts_VST_top2000_transposed[,gene_of_interest]-min(counts_VST_top2000_transposed[,gene_of_interest]))/((max(counts_VST_top2000_transposed[,gene_of_interest]))-(min(counts_VST_top2000_transposed[,gene_of_interest]))))
  
  
  #color datapoints (observations) by expression level
  par(pty = "s",
    cex.main = 1.2,
    cex.lab = 1,
    font.main = 2,
    font.lab = 2,
    family = "sans",
    col.main = "gray10",
    col.lab = "gray10",
    fg = "gray10",
    las = 1)
  
  plot.new()
  
  #we are first going to plot the different conditions (samples), which are in PCAobject_top2000$x 
  plot.window(xlim = extendrange(range(PCAobject_top2000$x[, 1]), f = 0.1), 
            ylim = extendrange(range(PCAobject_top2000$x[, 2]), f = 0.1), 
            asp = 1)
  axis(side = 1, 
     labels = TRUE)
  axis(side = 2, 
     labels = TRUE)
  title(main = PC1_TOP50_contributors$Ao_description[match(gene_of_interest, PC1_TOP50_contributors$orthogroup)],
        xlab = paste("PC 1 (", 
                   round(summary(PCAobject_top2000)$importance[2]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      ylab = paste("PC 2 (", 
                   round(summary(PCAobject_top2000)$importance[5]*100, 
                         digits = 1),
                   "%)", 
                   sep = ""), 
      #line = 2,
      adj = 0.5)
  
  # plot the different conditions (samples)
  points(x = PCAobject_top2000$x[,c(1,2)],
       pch = 16,
       cex = 2,
       col = colorrange[colorvalues]
       #col = rep(c("black","gray50", "gray35"),each=7)
       )
  
  #text(PCAobject_top2000$x[,1:2]-5, 
  #     labels = row.names(PCAobject_top2000$x), 
  #     cex = 0.8,
  #     font = 2,
  #     col = "black"
  #     )
  
  
}

dev.off()

#remove unused variables
#rm(colorrange, colorvalues, gene_of_interest, i, mypalette, morecols)
```






```{r, echo=FALSE}
#plot these genes
selected_genes <- PC1_TOP50_contributors$orthogroup
counts_VST_selectedgenes <- subset(zmerged_counts, rownames(zmerged_counts) %in% selected_genes[1:20])

rownames(counts_VST_selectedgenes) <- PC1_TOP50_contributors$Ao_description[match(rownames(counts_VST_selectedgenes) ,PC1_TOP50_contributors$orthogroup)] 

```


```{r, fig.height=6, fig.width=10}
image <- Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        #column_split = merged_metadata$species,
        column_split = factor(merged_metadata$species, levels=c("Pd", "Sp", "Pf", "Bf", "Ao")),
        col = rev(brewer.pal(11,"RdBu"))
        )

draw(image)
```

```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_PCAdrivers_heatmaps.pdf")

draw(image)

dev.off()
```






















###Joint R2E seriation 
```{r, fig.width=10, fig.height=15}
Heatmap(t(scale(t(zmerged_counts_TFs))), cluster_columns = T, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```
```{r}
counts_VST_selectedgenes_all <- zmerged_counts_TFs
#counts_VST_selectedgenes <- zmerged_counts_TFs[,c(2,3,5,6,7)]
counts_VST_selectedgenes <- zmerged_counts_TFs
```


```{r}
#define column proximity matrix C (samples)
sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
ht <- Heatmap(sample_correlation_matrix)
ht <- draw(ht)
ht
```

```{r, fig.width=10, fig.height=10}
# calculate correlation betwwen samples

# Users should always use circlize::colorRamp2() function to generate the color mapping function
#col_fun = colorRamp2(c(-1, 0, 1), brewer.pal(9,"BuPu")[c(1,5,9)])

color_categorical_segment <- c("skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "orchid",
                               "skyblue2", "indianred", "goldenrod1", "orchid",
                               "skyblue2", "skyblue2", "skyblue2", "dodgerblue", "indianred", "indianred", "magenta", "magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "goldenrod1","goldenrod1", "magenta","magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "magenta", "orchid", "orchid")
names(color_categorical_segment) <- paste0(unique(merged_metadata$segment), "_mean")
color_categorical_segment_named <- color_categorical_segment


colAnn <- HeatmapAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            which = 'col',
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE
                            )

rowAnn <- rowAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                        show_legend = FALSE,
                        show_annotation_name = FALSE
                            )



#### samples


rightAnn <- rowAnnotation(df = data.frame(Ao = paste0(unique(merged_metadata$segment), "_mean"),
                                          Bf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Sp = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pd = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to match the name of the named list
                   
                            
                            col = list("Ao" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=1, to=6)))], "white"),
                                       "Bf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=7, to=10)))], "white"),
                                       "Pf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=11, to=19)))], "white"),
                                       "Sp" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=20, to=28)))], "white"),
                                       "Pd" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=29, to=36)))], "white")), #set the name of the named list so it matches
                   simple_anno_size = unit(0.6, "cm"),
                   empty2 = anno_empty(border = FALSE, width= unit(4, "mm")),
                   show_legend = FALSE
                   
                   )














Heatmap(mat = sample_correlation_matrix,
        name= "Pearson rho",
        column_title = gt_render(paste0("<span style='color:darkorchid4'>**Spearman's ", expression(ρ), "**</span> correlation coeff. <br/> between samples <span style='color:gray60'>(on most variable genes)</span>")),
        #col = brewer.pal(9,"BuPu"),
        col = colorRamp2(c(-1, 0, 1), rev(brewer.pal(9,"RdGy")[c(1,5,9)])),
        #col = colorRamp2(c(-1, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col = brewer.pal(9,"PiYG"),
        #col =  colorRamp2(c(-0.5, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col = 
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = T,
        show_column_dend = T,
        #row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        #column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        #column_order = ordered_levels,
        #row_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        #column_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(0.5, "mm"),
        width = unit(12, "cm"), 
        height = unit(12, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        left_annotation = rowAnn,
        right_annotation = rightAnn,
        show_heatmap_legend = T
        )

```

```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix, 
        cluster_rows = T,
        cluster_columns = T)
plot(svd(sample_correlation_matrix)$u[, 1], svd(sample_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(sample_correlation_matrix,method="pearson"))
Heatmap(R1,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
Heatmap(R2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
Heatmap(R3,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
Heatmap(R4,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
Heatmap(R5,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
Heatmap(R6,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(sample_correlation_matrix)$d[svd(sample_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(sample_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```
```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R4
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

ggplot(PC1PC2_df, aes(x=U1, y=U2))+
   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
                            angle = 0),
                        color = "gray")+
   geom_point()+
  theme_bw()+
  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```

```{r}
cut_index <- 29

ifelse(cut_index == nrow(tmp), 
       tmp_genes <- tmp,
       tmp_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
htR2E <- Heatmap(sample_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))])

htR2E <- draw(htR2E)
```

```{r, fig.width=10, fig.height=10}
# calculate correlation betwwen samples

# Users should always use circlize::colorRamp2() function to generate the color mapping function
#col_fun = colorRamp2(c(-1, 0, 1), brewer.pal(9,"BuPu")[c(1,5,9)])

color_categorical_segment <- c("skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "orchid",
                               "skyblue2", "indianred", "goldenrod1", "orchid",
                               "skyblue2", "skyblue2", "skyblue2", "dodgerblue", "indianred", "indianred", "magenta", "magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "goldenrod1","goldenrod1", "magenta","magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "magenta", "orchid", "orchid")
names(color_categorical_segment) <- paste0(unique(merged_metadata$segment), "_mean")
color_categorical_segment_named <- color_categorical_segment


colAnn <- HeatmapAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            which = 'col',
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE
                            )

rowAnn <- rowAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                        show_legend = FALSE,
                        show_annotation_name = FALSE
                            )



#### samples


rightAnn <- rowAnnotation(df = data.frame(Ao = paste0(unique(merged_metadata$segment), "_mean"),
                                          Bf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Sp = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pd = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to match the name of the named list
                   
                            
                            col = list("Ao" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=1, to=6)))], "white"),
                                       "Bf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=7, to=10)))], "white"),
                                       "Pf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=11, to=19)))], "white"),
                                       "Sp" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=20, to=28)))], "white"),
                                       "Pd" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=29, to=36)))], "white")), #set the name of the named list so it matches
                   simple_anno_size = unit(0.6, "cm"),
                   empty2 = anno_empty(border = FALSE, width= unit(4, "mm")),
                   show_legend = FALSE
                   
                   )














image <- Heatmap(mat = sample_correlation_matrix,
        name= "Pearson rho",
        column_title = gt_render(paste0("<span style='color:darkorchid4'>**Spearman's ", expression(ρ), "**</span> correlation coeff. <br/> between samples <span style='color:gray60'>(on most variable genes)</span>")),
        #col = brewer.pal(9,"BuPu"),
        col = colorRamp2(c(-1, 0, 1), rev(brewer.pal(9,"RdGy")[c(1,5,9)])),
        #col = colorRamp2(c(-1, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col = brewer.pal(9,"PiYG"),
        #col =  colorRamp2(c(-0.5, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col = 
        na_col = "black",
        cluster_rows = FALSE,
        show_row_dend = FALSE,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        #column_order = ordered_levels,
        #row_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        #column_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(0.5, "mm"),
        width = unit(12, "cm"), 
        height = unit(12, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        left_annotation = rowAnn,
        right_annotation = rightAnn,
        show_heatmap_legend = T
        )

draw(image)

```

```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_segmentseriation_R2E.pdf")
draw(image)

dev.off()
```
```{r, fig.width=10, fig.height=10}
# calculate correlation betwwen samples

# Users should always use circlize::colorRamp2() function to generate the color mapping function
#col_fun = colorRamp2(c(-1, 0, 1), brewer.pal(9,"BuPu")[c(1,5,9)])

color_categorical_segment <- c("skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "orchid",
                               "skyblue2", "indianred", "goldenrod1", "orchid",
                               "skyblue2", "skyblue2", "skyblue2", "dodgerblue", "indianred", "indianred", "magenta", "magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "goldenrod1","goldenrod1", "magenta","magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "magenta", "orchid", "orchid")
names(color_categorical_segment) <- paste0(unique(merged_metadata$segment), "_mean")
color_categorical_segment_named <- color_categorical_segment


colAnn <- HeatmapAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            which = 'col',
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE
                            )

rowAnn <- rowAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                        show_legend = FALSE,
                        show_annotation_name = FALSE
                            )



#### samples


rightAnn <- rowAnnotation(df = data.frame(Ao = paste0(unique(merged_metadata$segment), "_mean"),
                                          Bf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Sp = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pd = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to match the name of the named list
                   
                            
                            col = list("Ao" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=1, to=6)))], "white"),
                                       "Bf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=7, to=10)))], "white"),
                                       "Pf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=11, to=19)))], "white"),
                                       "Sp" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=20, to=28)))], "white"),
                                       "Pd" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=29, to=36)))], "white")), #set the name of the named list so it matches
                   simple_anno_size = unit(0.6, "cm"),
                   empty2 = anno_empty(border = FALSE, width= unit(4, "mm")),
                   show_legend = FALSE
                   
                   )














image <- Heatmap(mat = sample_correlation_matrix,
        name= "Pearson rho",
        column_title = gt_render(paste0("<span style='color:darkorchid4'>**Spearman's ", expression(ρ), "**</span> correlation coeff. <br/> between samples <span style='color:gray60'>(on most variable genes)</span>")),
        #col = brewer.pal(9,"BuPu"),
        col = colorRamp2(c(0, 0.5, 1), brewer.pal(9,"BuPu")[c(1,5,9)]),
        #col = colorRamp2(c(-1, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col =  brewer.pal(9,"BuPu"),
        #col =  colorRamp2(c(-0.5, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col = 
        na_col = "black",
        cluster_rows = FALSE,
        show_row_dend = FALSE,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        #column_order = ordered_levels,
        #row_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        #column_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(0.5, "mm"),
        width = unit(12, "cm"), 
        height = unit(12, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        left_annotation = rowAnn,
        right_annotation = rightAnn,
        show_heatmap_legend = T
        )

draw(image)

```


```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_segmentseriation_R2E_BuPu.pdf")
draw(image)

dev.off()
```













```{r}
dataframe <- data.frame(gene = rownames(sample_correlation_matrix), original_order = seq(1:nrow(sample_correlation_matrix)))

seriation_order <- row_order(htR2E)

dataframe$original_seriation_order <- seriation_order

for (i in seq(1:nrow(dataframe))) {
  dataframe$R2E_order[i] <- which(seriation_order == dataframe$original_order[i])
}  


Heatmap(sample_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = F, 
        #row_order = rownames(counts_VST_selectedgenes)[seriation_order],
        row_order = dataframe$gene[order(dataframe$R2E_order)],
        column_order= dataframe$gene[order(dataframe$R2E_order)],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```

```{r, fig.width=10, fig.height=7}
hclust <- hclust(dist(sample_correlation_matrix), method = "ward.D2")
hclust_order <- hclust$order

reordered_object <- stats::reorder(x=hclust,
        wts= dataframe$R2E_order,
        agglo.FUN = "mean" #note that package vegan needs to be loaded
        )

#reordered_object <- dendextend::rotate(hclust, dataframe$R2E_order)

reorder <- reordered_object$order

dataframe$original_reorded <- reorder

for (i in seq(1:nrow(dataframe))) {
  dataframe$R2EHCT_order[i] <- which(reorder == dataframe$original_order[i])
} 


Heatmap(sample_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(sample_correlation_matrix)[hclust_order],
        column_order =  rownames(sample_correlation_matrix)[hclust_order],
        na_col = "white", col = rev(brewer.pal(11,"RdBu"))
        )


Heatmap(sample_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = F, 
        #row_order = rownames(sample_correlation_matrix)[reorder],
        row_order = dataframe$gene[order(dataframe$R2E_order)],
        column_order = dataframe$gene[order(dataframe$R2E_order)],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))

Heatmap(sample_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = as.dendrogram(reordered_object), 
        #row_order = rownames(sample_correlation_matrix)[reorder],
        #row_order = dataframe$gene[order(dataframe$R2EHCT_order)],
        column_order= dataframe$gene[order(dataframe$R2EHCT_order)],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```

```{r, fig.width=10, fig.height=10}
# calculate correlation betwwen samples

# Users should always use circlize::colorRamp2() function to generate the color mapping function
#col_fun = colorRamp2(c(-1, 0, 1), brewer.pal(9,"BuPu")[c(1,5,9)])

color_categorical_segment <- c("skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "orchid",
                               "skyblue2", "indianred", "goldenrod1", "orchid",
                               "skyblue2", "skyblue2", "skyblue2", "dodgerblue", "indianred", "indianred", "magenta", "magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "goldenrod1","goldenrod1", "magenta","magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "magenta", "orchid", "orchid")
names(color_categorical_segment) <- paste0(unique(merged_metadata$segment), "_mean")
color_categorical_segment_named <- color_categorical_segment


colAnn <- HeatmapAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            which = 'col',
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE
                            )

rowAnn <- rowAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                        show_legend = FALSE,
                        show_annotation_name = FALSE
                            )



#### samples


rightAnn <- rowAnnotation(df = data.frame(Ao = paste0(unique(merged_metadata$segment), "_mean"),
                                          Bf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Sp = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pd = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to match the name of the named list
                   
                            
                            col = list("Ao" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=1, to=6)))], "white"),
                                       "Bf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=7, to=10)))], "white"),
                                       "Pf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=11, to=19)))], "white"),
                                       "Sp" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=20, to=28)))], "white"),
                                       "Pd" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=29, to=36)))], "white")), #set the name of the named list so it matches
                   simple_anno_size = unit(0.6, "cm"),
                   empty2 = anno_empty(border = FALSE, width= unit(4, "mm")),
                   show_legend = FALSE
                   
                   )














image <- Heatmap(mat = sample_correlation_matrix,
        name= "Pearson rho",
        column_title = gt_render(paste0("<span style='color:darkorchid4'>**Spearman's ", expression(ρ), "**</span> correlation coeff. <br/> between samples <span style='color:gray60'>(on most variable genes)</span>")),
        #col = brewer.pal(9,"BuPu"),
        col = colorRamp2(c(-1, 0, 1), rev(brewer.pal(9,"RdGy")[c(1,5,9)])),
        #col = colorRamp2(c(-1, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col = brewer.pal(9,"PiYG"),
        #col =  colorRamp2(c(-0.5, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col = 
        na_col = "black",
        cluster_rows = as.dendrogram(reordered_object),
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = as.dendrogram(reordered_object),
        show_column_dend = T,
       #row_order = dataframe$gene[order(dataframe$R2EHCT_order)],
      #  column_order= dataframe$gene[order(dataframe$R2EHCT_order)],
        #column_order = ordered_levels,
        #row_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        #column_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(0.5, "mm"),
        width = unit(12, "cm"), 
        height = unit(12, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        left_annotation = rowAnn,
        right_annotation = rightAnn,
        show_heatmap_legend = T
        )

draw(image)

```
```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_segmentseriation_R2EHCT.pdf")
draw(image)

dev.off()
```



```{r}
#define row proximity matrix R (genes)0
gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="spearman"))
Heatmap(gene_correlation_matrix)
```

```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="pearson"))
#Heatmap(gene_correlation_matrix, 
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(gene_correlation_matrix)$u[, 1], svd(gene_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(gene_correlation_matrix,method="pearson"))
#Heatmap(R1,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
#Heatmap(R2,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
#Heatmap(R3,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
#Heatmap(R4,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
#Heatmap(R5,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
Heatmap(R6,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(gene_correlation_matrix)$d[svd(gene_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(gene_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```
```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R5
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

ggplot(PC1PC2_df, aes(x=U1, y=U2))+
   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
                            angle = 0),
                        color = "gray")+
   geom_point()+
  theme_bw()+
  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```



```{r}
cut_index <- 56

ifelse(cut_index == nrow(tmp), 
       tmp2_genes <- tmp,
       tmp2_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp2_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
htR2E_genes <- Heatmap(gene_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order =  rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))])
htR2E_genes <- draw(htR2E_genes)


dataframe <- data.frame(gene = rownames(gene_correlation_matrix), original_order = seq(1:nrow(gene_correlation_matrix)))

seriation_order <- row_order(htR2E_genes)

dataframe$original_seriation_order <- seriation_order

for (i in seq(1:nrow(dataframe))) {
  dataframe$R2E_order[i] <- which(seriation_order == dataframe$original_order[i])
}  


```



```{r, fig.height=10, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        
        #FOR R2E:
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"RdGy")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes))),
               width=3,
               #FOR R2E_HCT
        cluster_rows = as.dendrogram(reordered_object),
        cluster_columns = as.dendrogram(reordered_object),
        #FOR R2E
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2_genes))],
        #column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )


ht_list = ht1 + ht2
draw(ht_list)
```

```{r, fig.width=10, fig.height=7}
hclust <- hclust(dist(gene_correlation_matrix), method = "ward.D2")
hclust_order <- hclust$order

reordered_object_genes <- stats::reorder(x=hclust,
        wts= dataframe$R2E_order,
        agglo.FUN = "mean" #note that package vegan needs to be loaded
        )

#reordered_object_genes <- dendextend::rotate(hclust, dataframe$R2E_order)

reorder <- reordered_object_genes$order

dataframe$original_reorded <- reorder

for (i in seq(1:nrow(dataframe))) {
  dataframe$R2EHCT_order[i] <- which(reorder == dataframe$original_order[i])
} 


Heatmap(gene_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(gene_correlation_matrix)[hclust_order],
        column_order =  rownames(gene_correlation_matrix)[hclust_order],
        na_col = "white", col = rev(brewer.pal(11,"RdBu"))
        )


Heatmap(gene_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = F, 
        #row_order = rownames(gene_correlation_matrix)[reorder],
        row_order = dataframe$gene[order(dataframe$R2E_order)],
        column_order = dataframe$gene[order(dataframe$R2E_order)],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))

Heatmap(gene_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = as.dendrogram(reordered_object_genes), 
        #row_order = rownames(gene_correlation_matrix)[reorder],
        #row_order = dataframe$gene[order(dataframe$R2EHCT_order)],
        column_order= dataframe$gene[order(dataframe$R2EHCT_order)],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```

```{r, fig.height=10, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
               #FOR R2E_HCT
        cluster_rows = as.dendrogram(reordered_object_genes),
        cluster_columns = as.dendrogram(reordered_object_genes),
        #cluster_rows = T,
        
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        
        #column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"RdGy")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes))),
               width=3,
               #FOR R2E_HCT
        #cluster_rows = as.dendrogram(reordered_object),
        #cluster_columns = as.dendrogram(reordered_object),
        #cluster_columns = T,
        row_order = rownames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )

ht_list = ht1 + ht2
draw(ht_list)
```
```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_GAP.pdf")
draw(ht_list)

dev.off()
```


```{r, fig.height= 15, fig.width= 10}
load("Z://01_Stefano/Collaboration_Data/Annotations/dictionary_orthogroups_best_withHox_genebased.rds")


counts_VST_selectedgenes_named <- counts_VST_selectedgenes
rownames(counts_VST_selectedgenes_named) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes_named) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes_named) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes_named) ,annotation_info_Ao$entrez_ID)] 


ht <- Heatmap(t(scale(t(counts_VST_selectedgenes_named))),
               width=3,
              cluster_rows = as.dendrogram(reordered_object_genes),
              #cluster_columns = as.dendrogram(reordered_object),
        #cluster_rows = F,
        #cluster_columns = F,
        #row_order = rownames(counts_VST_selectedgenes_named)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )

dht <- draw(ht)

```
```{r}
InteractiveComplexHeatmap::htShiny(dht)
```


```{r}
summary_dataframe <- data.frame(geneID = NA, symbol = NA, orthogroup = NA, description = rownames(counts_VST_selectedgenes_named)[row_order(dht)])

summary_dataframe$geneID <- annotation_info_Ao$entrez_ID[match(summary_dataframe$description ,annotation_info_Ao$merged_description)] 

summary_dataframe$symbol <- annotation_info_Ao$merged_symbol[match(summary_dataframe$geneID ,annotation_info_Ao$entrez_ID)]

summary_dataframe$orthogroup <- rownames(dictionary_orthogroups_best_withHox_genebased)[match(summary_dataframe$geneID ,dictionary_orthogroups_best_withHox_genebased$Ao)]

#save(summary_dataframe, file="Z://01_Stefano/Collaboration_Data/84TF_conserved_subset.rds")
#write.csv(summary_dataframe, file="Z://01_Stefano/Collaboration_Data/84TF_conserved_subset.csv")
```





























### clustering methods experiments


```{r}
#SELECT THIS TO PLOT ONLY SHARED TFs

load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")
dictionary_spur <-  get(load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Sp_dictionary_standard.rds"))
orthogroup_TFs <- orthogroup_TFs[orthogroup_TFs %in% rownames(dictionary_orthogroups_best_withHox_genebased)] #314


#find genes
selected_genes <- dictionary_orthogroups_best_withHox_genebased[orthogroup_TFs, "Sp"]
selected_genes <- na.omit(selected_genes)
selected_genes <- make.unique(as.character(selected_genes))

```


```{r}
color_categorical_segment <- c("dodgerblue2",  "dodgerblue3",  "goldenrod",  "goldenrod","goldenrod1", "goldenrod1", "orchid1", "orchid1", "orchid"
                           )

#load starting point counts matrix (batch-correct VST object), species-specific metadata, and species-specific conversion dictionary
load("Z://01_Stefano/Collaboration_Data/VST_Sp_corrected.rds")
counts_VST_corrected <- VST_Sp_corrected



load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Sp_samplemetadata_standard.rds")
sample_metadata <- SpGut_design3
rm(SpGut_design3)

#reorder counts columns based on real AP position
counts_VST_corrected <- as.data.frame(counts_VST_corrected)
counts_VST <- counts_VST_corrected
```


```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "gene_ID"

missing_genes$description <- dictionary_spur$symbol[match(missing_genes$gene_ID,dictionary_spur$geneID)]
#tpo and LOC111580672_slco1c1

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "gene_ID"
selected_genes$description <- dictionary_spur$symbol[match(selected_genes$gene_ID,dictionary_spur$geneID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained (retained)")

```


```{r}
#we have our list of genes, and we know we can plot all of them.
#so we can start now:

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$gene_ID)

#sort in the order that the genes were given
counts_VST_selectedgenes <- counts_VST_selectedgenes[match(selected_genes$gene_ID, rownames(counts_VST_selectedgenes)), ]

#change the rownames with ORTHOGROUP CODE
rownames(counts_VST_selectedgenes) <- rownames(dictionary_orthogroups_best_withHox_genebased[match(rownames(counts_VST_selectedgenes), dictionary_orthogroups_best_withHox_genebased$Sp),])
```


```{r}
#create an empty dataframe with the right number of rows, which will host the average gene values
counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_selectedgenes),ncol=0))

#to start, create a summary vst that contains the average value of each gene across replicates of the same condition
group_indeces <- c(0, cumsum(unname( table(sample_metadata$segment))))
#calculate the average by group of replicates
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- counts_VST_selectedgenes[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
  
}

#set nicer column names
colnames(counts_VST_averaged) <- paste0(unique(sample_metadata$segment), "_mean")

counts_VST_selectedgenes <- counts_VST_averaged
```


```{r}
#now we need to remove genes that have no variance
zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))
#check which OGs would be lost

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ] #311

#check which ones got lost
setdiff(rownames(zcounts_VST_selectedgenes), rownames(counts_VST_selectedgenes))
```





```{r}
#default method hclust ward.D2
hclust <- hclust(dist(t(scale(t(counts_VST_selectedgenes)))), method = "ward.D2")


Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = T, 
        clustering_method_rows = "ward.D2",
        na_col = "white", col = rev(brewer.pal(11,"RdBu"))
        )

Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(counts_VST_selectedgenes)[hclust_order$order],
        na_col = "white", col = rev(brewer.pal(11,"RdBu"))
        )
```


```{r}
#library()
#register_DendSer()

pimage(t(scale(t(counts_VST_selectedgenes))), 
       order = "Heatmap", seriation_method = "HC_complete", 
       main = "Wood (hierarichal clustering)")
hmap(t(scale(t(counts_VST_selectedgenes))), method = "HC_complete", main = "Wood (hierarichal clustering)")

pimage(t(scale(t(counts_VST_selectedgenes))), order = "Heatmap", seriation_method = "HC_Mean", 
       main = "Wood (reorder by row/col mean)")
hmap(t(scale(t(counts_VST_selectedgenes))), method = "HC_Mean", main = "Wood (reorder by row/col mean)")

pimage(t(scale(t(counts_VST_selectedgenes))), order = "Heatmap", seriation_method = "GW_complete", 
       main = "Wood (reorder by Gruvaeus and Wainer heuristic)")
hmap(t(scale(t(counts_VST_selectedgenes))), method = "GW_complete", main = "Wood (reorder by Gruvaeus and Wainer heuristic)")

pimage(t(scale(t(counts_VST_selectedgenes))), order = "Heatmap", 
       main = "Wood (default - optimal leaf ordering)")
hmap(t(scale(t(counts_VST_selectedgenes))), method = "OLO_complete", main = "Wood (opt. leaf ordering)")
```


```{r}
hmap(t(scale(t(counts_VST_selectedgenes))), method = "DendSer_BAR", main = "Wood (banded anti-Robinson)")

```
```{r}
hmap(t(scale(t(counts_VST_selectedgenes))), method = "HC_complete", 
     plot_margins = "distances",
     main = "Wood (hierarichal clustering)")
```

```{r}
hmap(t(scale(t(counts_VST_selectedgenes))), method = "MDS", main = "Wood (MDS)")
hmap(t(scale(t(counts_VST_selectedgenes))), method = "MDS_angle", main = "Wood (Angle in 2D MDS space)")
hmap(t(scale(t(counts_VST_selectedgenes))), method = "R2E", main = "Wood (Rank 2 ellipse seriation)")
hmap(t(scale(t(counts_VST_selectedgenes))), method = "TSP", main = "Wood (Traveling salesperson)")
```
```{r, fig.width=10, fig.height=15}
dataframe <- data.frame(gene = rownames(counts_VST_selectedgenes), original_order = seq(1:nrow(counts_VST_selectedgenes)))

hmapobject_R2E <- hmap(t(scale(t(counts_VST_selectedgenes))), method = "R2E", main = "Wood (Rank 2 ellipse seriation)")
seriation_order <- unname(get_order(hmapobject_R2E[["o"]][[1]]))

dataframe$original_seriation_order <- seriation_order

for (i in seq(1:nrow(dataframe))) {
  dataframe$R2E_order[i] <- which(seriation_order == dataframe$original_order[i])
}  


Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        #row_order = rownames(counts_VST_selectedgenes)[seriation_order],
        row_order = dataframe$gene[order(dataframe$R2E_order)],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```


```{r, fig.width=10, fig.height=7}
reordered_object <- stats::reorder(hclust,
        wts= dataframe$R2E_order,
        agglo.FUN = "mean"
        )

reordered_object <- dendextend::rotate(hclust, dataframe$R2E_order)

reorder <- reordered_object$order

dataframe$original_reorded <- reorder

for (i in seq(1:nrow(dataframe))) {
  dataframe$R2EHCT_order[i] <- which(reorder == dataframe$original_order[i])
} 


Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(counts_VST_selectedgenes)[hclust_order$order],
        na_col = "white", col = rev(brewer.pal(11,"RdBu"))
        )


Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        #row_order = rownames(counts_VST_selectedgenes)[reorder],
        row_order = rev(dataframe$gene[order(dataframe$R2E_order)]),
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))

Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        #row_order = rownames(counts_VST_selectedgenes)[reorder],
        row_order = rev(dataframe$gene[order(dataframe$R2EHCT_order)]),
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```


```{r,fig.width = 10, fig.height=25}



Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = T, 
        clustering_method_rows = "ward.D2",
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))

Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(counts_VST_selectedgenes)[hclust_order$order],
        na_col = "white", col = rev(brewer.pal(11,"RdBu"))
        )

Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(counts_VST_selectedgenes)[seriation_order],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))

Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = test$labels[reorder],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))


```

```{r}
dataframe<- data.frame(genes = rownames(counts_VST_selectedgenes),
                       original_order = seq(1:nrow(counts_VST_selectedgenes)),
                       R2E_order = seriation_order,
                       R2E_order_2 = reordered_indeces
                       )
```


```{r}
reordered_rownames <- rownames(counts_VST_selectedgenes)[seriation_order]
reordered_indeces <- match(rownames(counts_VST_selectedgenes), rownames(counts_VST_selectedgenes)[seriation_order])


test2 <- stats::reorder(hclust,
        wts= dataframe$R2E_orde_2,
        agglo.FUN = "mean"
        )

reorder <- test2$order


Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = T, 
        clustering_method_rows = "ward.D2",
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))

Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(counts_VST_selectedgenes)[hclust_order$order],
        na_col = "white", col = rev(brewer.pal(11,"RdBu"))
        )

Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(counts_VST_selectedgenes)[seriation_order],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))

Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(counts_VST_selectedgenes)[reorder],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))

```



```{r}
cut <- cutree(hclust, k=8)

dataframe <- data.frame(gene = hclust$labels,gene2 = rownames(counts_VST_selectedgenes), wardD2 = hclust$order, R2E = seriation_order, group = cut)

```



```{r}
#library(vegan)
vegan_order <- dendextend::rotate(hclust_order, seriation_order)

Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(counts_VST_selectedgenes)[hclust_order$order],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))

Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(counts_VST_selectedgenes)[seriation_order],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))

Heatmap(t(scale(t(counts_VST_selectedgenes))), 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(counts_VST_selectedgenes)[vegan_order$order],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```
































### Species-specific

##Ao

```{r}
#SELECT THIS TO PLOT ONLY SHARED TFs
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species_expressed.rds") #shared_TFs_8species_expressed [277/356]

orthogroup_TFs <- unique(shared_TFs_8species_expressed) #277

load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox.rds")
orthogroup_TFs <- orthogroup_TFs[orthogroup_TFs %in% rownames(dictionary_orthogroups_best_withHox)] #277

#find proteins
proteins_ao <- dictionary_orthogroups_best_withHox$Ao[match(orthogroup_TFs, rownames(dictionary_orthogroups_best_withHox) )] #277


dictionary_aoce <-  read.table(file = "Z://01_Stefano/Collaboration_Data/Annotations/Aoce_dictionary.csv", sep = ',', header = TRUE)
selected_genes <- dictionary_aoce$geneID[match(proteins_ao,dictionary_aoce$proteinID)]
selected_genes <- na.omit(selected_genes)
selected_genes <- make.unique(as.character(selected_genes)) #277



```



```{r}
##we can now load the platynereis counts matrix, and the sample metadata, to plot
#Both of these come from you (I have modified it a bit)
load("Z://01_Stefano/Collaboration_Data/VST_Ao_corrected.rds")
counts_VST <- VST_Ao_corrected

load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Ao_samplemetadata_standard.rds") #sample_metadata
liver_metadata <- data.frame(segment = rep("liver", 3), replicate = c(1,2,3))
rownames(liver_metadata) <- c("liv_01", "liv_02", "liv_03")
sample_metadata <- rbind(liver_metadata, sample_metadata)
rm(liver_metadata)

dictionary_aoce <-  get(load(file = "Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Aoce_dictionary_standard.rds"))


#we will also define the colours for the heatmap labels, and the AP order of the segments
color_categorical_segment <- rep(c("indianred1","lightpink", "sandybrown", "lightgoldenrod1",
                    "dodgerblue3","lightskyblue","lightskyblue1"),each=1)


ordered_levels_segment <- c("liver","oesophagus", "stomach", "pyloric", "A_intestine", "M_intestine", "P_intestine")
```



```{r, echo=FALSE}
# Almost ready to plot!
#This is an optional step, but we need to make sure that all the genes we want to plot ("selected_genes") are actually in the counts matrix. It could be that they are not there so we need to skip them.

#this code will print two tables below: one with the missing genes, one with the genes not missing.

# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "gene_ID"

missing_genes$symbol <- dictionary_aoce$symbol[match(missing_genes$gene_ID,dictionary_aoce$geneID)]


missing_genes$description <- dictionary_aoce$description[match(missing_genes$gene_ID,dictionary_aoce$geneID)]


# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "gene_ID"
selected_genes$symbol <- dictionary_aoce$symbol[match(selected_genes$gene_ID,dictionary_aoce$geneID)]
selected_genes$description <- dictionary_aoce$description[match(selected_genes$gene_ID,dictionary_aoce$geneID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained (retained)")


#note, in this case the missing genes table is empty because there are no missing genes: all genes in the list we want to plot are in the sea urchin counts table for this dataset
```



```{r}
#we have our list of genes, and we know we can plot all of them.
#so we can start now:

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$gene_ID)
 
#sort in the order that the genes were given
counts_VST_selectedgenes <- counts_VST_selectedgenes[match(selected_genes$gene_ID, rownames(counts_VST_selectedgenes)), ]


#change the rownames with a more complete description (here, only the gene names)
rownames(counts_VST_selectedgenes) <- dictionary_aoce$symbol[match(rownames(counts_VST_selectedgenes), dictionary_aoce$geneID)]
```





```{r}
#create an empty dataframe with the right number of rows, which will host the average gene values
counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_selectedgenes),ncol=0))

#to start, create a summary vst that contains the average value of each gene across replicates of the same condition
group_indeces <- c(0, cumsum(unname( table(sample_metadata$segment))))
#calculate the average by group of replicates
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- counts_VST_selectedgenes[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
  
}

#set nicer column names
colnames(counts_VST_averaged) <- paste0(unique(sample_metadata$segment), "_mean")

counts_VST_selectedgenes <- counts_VST_averaged
```


```{r}
#now we need to remove genes that have no variance
zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ]

```





```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```



```{r}
counts_VST_selectedgenes_all <- counts_VST_selectedgenes
counts_VST_selectedgenes <- counts_VST_selectedgenes[,2:7]

zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ]
```

```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```



```{r}
#define column proximity matrix C (samples)
sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix)
```

```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix, 
        cluster_rows = T,
        cluster_columns = T)
plot(svd(sample_correlation_matrix)$u[, 1], svd(sample_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(sample_correlation_matrix,method="pearson"))
Heatmap(R1,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
Heatmap(R2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
Heatmap(R3,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
Heatmap(R4,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
Heatmap(R5,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
Heatmap(R6,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(sample_correlation_matrix)$d[svd(sample_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(sample_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```
```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R3
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

ggplot(PC1PC2_df, aes(x=U1, y=U2))+
   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
                            angle = 0),
                        color = "gray")+
   geom_point()+
  theme_bw()+
  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = T),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```

```{r}
cut_index <- 5

ifelse(cut_index == nrow(tmp), 
       tmp_genes <- tmp,
       tmp_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
image <- Heatmap(sample_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        col = brewer.pal(9,"BuPu"),
        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))])

htR2E <- draw(image)
```
```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_seriation_segments_Ao_CPM10.pdf")
draw(image)

dev.off()
```


```{r}
#define row proximity matrix R (genes)
gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="spearman"))
#Heatmap(gene_correlation_matrix, show_column_names = FALSE, show_row_names = FALSE)
```





```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="pearson"))
#Heatmap(gene_correlation_matrix, 
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(gene_correlation_matrix)$u[, 1], svd(gene_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(gene_correlation_matrix,method="pearson"))
#Heatmap(R1,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
#Heatmap(R2,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
#Heatmap(R3,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
#Heatmap(R4,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
#Heatmap(R5,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
#Heatmap(R6,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(gene_correlation_matrix)$d[svd(gene_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(gene_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```


```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R4
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
#Heatmap(R_r2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

#ggplot(PC1PC2_df, aes(x=U1, y=U2))+
#  ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
#                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
#                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
#                            angle = 0),
#                        color = "gray")+
#   geom_point()+
#  theme_bw()+
#  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = T),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```


```{r}
cut_index <- 82 #for all Tfs


ifelse(cut_index == nrow(tmp), 
       tmp2_genes <- tmp,
       tmp2_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp2_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
Heatmap(gene_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))])
```



```{r, fig.height=40, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(c(c("11", "13"), rownames(tmp2_genes)[1:23]))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"PiYG")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes))),
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(c(c("11", "13"), rownames(tmp2_genes)[1:23]))],
        #column_order = c("oesophagus_mean", "stomach_mean", "liver_mean", "pyloric_mean" ,    "A_intestine_mean", "M_intestine_mean","P_intestine_mean"),
        #column_order = colnames(counts_VST_top2000)[c(1,2,3,5,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )

#ht3 <- Heatmap(sample_correlation_matrix,
#        cluster_rows = F,
#        cluster_columns = F,
#        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        col = rev(brewer.pal(9,"PiYG")))



ht_list = ht1 + ht2
draw(ht_list)
```



#### Tradeseq

```{r}
#library(tradeSeq)
time <- matrix(seq(1:6), nrow=ncol(counts_VST_selectedgenes), ncol=1, byrow=FALSE)
rownames(time) <- colnames(counts_VST_selectedgenes)



weights <- matrix(1, nrow=ncol(counts_VST_selectedgenes), ncol=1) #this needs to be a matrix where each column is a condition (different sample, here only 1), and the value be a binary telling which segments are in which

```

```{r}
## evaluate optimal K
infMat <- evaluateK(counts = as.matrix(counts_VST_selectedgenes), 
                    pseudotime=time, 
                    cellWeights=weights, 
                    nGenes=nrow(counts_VST_selectedgenes), 
                    k=3:6)



```


```{r}
## fit GAM
gamList <- fitGAM(counts = as.matrix(counts_VST_selectedgenes), 
                  pseudotime=time, 
                  cellWeights=weights, 
                  nknots=3)


```
```{r}
rowData(gamList)$assocRes <-  associationTest(gamList, global = T,  contrastType = "consecutive")
assocRes <- rowData(gamList)$assocRes


hist(assocRes$pvalue, breaks=100)
plot(x= seq(1:length(assocRes$pvalue)), y=assocRes$pvalue, pch=16, col=scales::alpha("black", 0.5))
abline(h=0.05)
```

```{r}
mockGenes <-  rownames(assocRes)[
  which(assocRes$pvalue<= 0.8)
]
```


```{r, fig.height=15, fig.width=10}
### based on mean smoother
yhatSmooth <- predictSmooth(gamList, gene = mockGenes, nPoints = 50, tidy = FALSE)
tradseqTFs_Ao <- rownames(yhatSmooth) 


#rownames(yhatSmooth) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(yhatSmooth),rownames(dictionary_orthogroups_best_withHox_genebased))]
#rownames(yhatSmooth) <- dictionary_aoce$description[match(rownames(yhatSmooth),dictionary_aoce$geneID)]

heatSmooth <- pheatmap(t(scale(t(yhatSmooth[, 1:50]))),
                       cluster_cols = FALSE,
                       show_rownames = T, 
                       show_colnames = T)
heatSmooth
```
```{r}
save(tradseqTFs_Ao, file= "Z://01_Stefano/Collaboration_Data/tradseqTFs_Ao.rds")
```












##Pd


```{r}
#SELECT THIS TO PLOT ALL TFs of this species
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Pd_TF_ID.xlsx") 
hmsearch_TFs_list <- unlist(hmsearch_TFs[1]) #1844 proteins


dictionary_pdum <-  get(load(file = "Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Pd_dictionary_standard.rds"))
selected_genes <- dictionary_pdum$geneID[match(hmsearch_TFs_list,dictionary_pdum$proteinID)] #1844 genes
selected_genes <- na.omit(selected_genes) #1844 genes
```


```{r}
##we can now load the platynereis counts matrix, and the sample metadata, to plot
#Both of these come from you (I have modified it a bit)
load("Z://01_Stefano/Collaboration_Data/VST_Pd_corrected.rds")
counts_VST <- VST_Pd_corrected

load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Pd_samplemetadata_standard.rds") #SpGut_design3




#we will also define the colours for the heatmap labels, and the AP order of the segments
color_categorical_segment_pd <- rep(c("dodgerblue3","darkorange2",  "indianred3", "lightskyblue","lightskyblue1", "sandybrown","lightgoldenrod1", "lightyellow", "lightcoral","lightpink"), each=1)

ordered_levels_segment_pd <- unique(sample_metadata$segment)
```



```{r, echo=FALSE}
# Almost ready to plot!
#This is an optional step, but we need to make sure that all the genes we want to plot ("selected_genes") are actually in the counts matrix. It could be that they are not there so we need to skip them.

#this code will print two tables below: one with the missing genes, one with the genes not missing.

# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "gene_ID"

missing_genes$symbol <- dictionary_pdum$symbol[match(missing_genes$gene_ID,dictionary_pdum$geneID)]


missing_genes$description <- dictionary_pdum$description[match(missing_genes$gene_ID,dictionary_pdum$geneID)]


# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "gene_ID"
selected_genes$symbol <- dictionary_pdum$symbol[match(selected_genes$gene_ID,dictionary_pdum$geneID)]
selected_genes$description <- dictionary_pdum$description[match(selected_genes$gene_ID,dictionary_pdum$geneID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained (retained)")


#note, in this case the missing genes table is empty because there are no missing genes: all genes in the list we want to plot are in the sea urchin counts table for this dataset
```

```{r}
#1214 left

#we have our list of genes, and we know we can plot all of them.
#so we can start now:

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$gene_ID)

#sort in the order that the genes were given
counts_VST_selectedgenes <- counts_VST_selectedgenes[match(selected_genes$gene_ID, rownames(counts_VST_selectedgenes)), ]


#change the rownames with a more complete description (here, only the gene names)
rownames(counts_VST_selectedgenes) <- dictionary_pdum$symbol[match(rownames(counts_VST_selectedgenes), dictionary_pdum$geneID)]
```





```{r}
#create an empty dataframe with the right number of rows, which will host the average gene values
counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_selectedgenes),ncol=0))

#to start, create a summary vst that contains the average value of each gene across replicates of the same condition
group_indeces <- c(0, cumsum(unname( table(sample_metadata$segment))))
#calculate the average by group of replicates
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- counts_VST_selectedgenes[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
  
}

rownames(counts_VST_averaged) <- make.unique(rownames(counts_VST_selectedgenes))

#set nicer column names
colnames(counts_VST_averaged) <- paste0(unique(sample_metadata$segment), "_mean")

counts_VST_selectedgenes <- counts_VST_averaged
```



```{r}
#now we need to remove genes that have no variance
zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ]

```





```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = F, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```



```{r}
counts_VST_selectedgenes_all <- counts_VST_selectedgenes
counts_VST_selectedgenes <- counts_VST_selectedgenes[,3:10]

zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ]
```

```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```




```{r}
#define column proximity matrix C (samples)
sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix)
```


```{r}
#define row proximity matrix R (genes)
gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="spearman"))
Heatmap(gene_correlation_matrix)
```





```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="pearson"))
#Heatmap(gene_correlation_matrix, 
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(gene_correlation_matrix)$u[, 1], svd(gene_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(gene_correlation_matrix,method="pearson"))
#Heatmap(R1,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
#Heatmap(R2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
#Heatmap(R3,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
#Heatmap(R4,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
#Heatmap(R5,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
#Heatmap(R6,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(gene_correlation_matrix)$d[svd(gene_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(gene_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```


```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R5
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
#plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", col = rep(color_categorical_all[1:7],each=3), pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

#ggplot(PC1PC2_df, aes(x=U1, y=U2))+
#   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
#                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
#                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
#                            angle = 0),
#                        color = "gray")+
#   geom_point()+
#  theme_bw()+
#  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = T),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[1])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```


```{r}
###SELECT
cut_index <- 550 #for all TFs


ifelse(cut_index == nrow(tmp), 
       tmp2_genes <- tmp,
       tmp2_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp2_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
Heatmap(gene_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))])
```



```{r, fig.height=10, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"PiYG")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes))),
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2_genes))],
        #column_order = colnames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2))],
        #column_order = colnames(counts_VST_top2000)[c(1,2,3,5,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )


ht_list = ht1 + ht2
draw(ht_list)
```






#### Tradeseq

```{r}
#library(tradeSeq)
time <- matrix(seq(1:9), nrow=ncol(counts_VST_selectedgenes), ncol=1, byrow=FALSE)
rownames(time) <- colnames(counts_VST_selectedgenes)



weights <- matrix(1, nrow=ncol(counts_VST_selectedgenes), ncol=1) #this needs to be a matrix where each column is a condition (different sample, here only 1), and the value be a binary telling which segments are in which

```

```{r}
#for some reason the counts matrix still has negative values
counts_VST_selectedgenes_noneg <-counts_VST_selectedgenes
counts_VST_selectedgenes_noneg$has_negatives<-apply(counts_VST_selectedgenes, 1, function(x) any(x<0))
counts_VST_selectedgenes_noneg <- counts_VST_selectedgenes_noneg[counts_VST_selectedgenes_noneg$has_negatives == F,] #1149
counts_VST_selectedgenes_noneg <- counts_VST_selectedgenes_noneg[,1:8]

## evaluate optimal K
infMat <- evaluateK(counts = as.matrix(counts_VST_selectedgenes_noneg), 
                    pseudotime=time, 
                    cellWeights=weights, 
                    nGenes=500, 
                    k=3:6)



```


```{r}
## fit GAM
gamList <- fitGAM(counts = as.matrix(counts_VST_selectedgenes_noneg), 
                  pseudotime=time, 
                  cellWeights=weights, 
                  nknots=5)


```
```{r}
rowData(gamList)$assocRes <-  associationTest(gamList, global = T,  contrastType = "consecutive")
assocRes <- rowData(gamList)$assocRes

mockGenes <-  rownames(assocRes)[
  which(assocRes$pvalue<= 0.2)
]
```



```{r, fig.height=15, fig.width=10}
### based on mean smoother
yhatSmooth <- predictSmooth(gamList, gene = mockGenes, nPoints = 50, tidy = FALSE)
heatSmooth <- pheatmap(t(scale(t(yhatSmooth[, 1:50]))),
                       cluster_cols = FALSE,
                       show_rownames = T, 
                       show_colnames = T)
heatSmooth
```







##Sp



```{r}
#SELECT THIS TO PLOT ALL TFs of this species
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Sp_TF_ID.xlsx") 
hmsearch_TFs_list <- unlist(hmsearch_TFs[1]) #1289 proteins


dictionary_spur <-  get(load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Sp_dictionary_standard.rds"))


selected_genes <- dictionary_spur$geneID[match(hmsearch_TFs_list,dictionary_spur$proteinID)] #2408 genes
selected_genes <- na.omit(selected_genes) #1289 genes
```

```{r}
color_categorical_segment <- c("dodgerblue2",  "dodgerblue3",  "goldenrod",  "goldenrod","goldenrod1", "goldenrod1", "orchid1", "orchid1", "orchid"
                           )

#load starting point counts matrix (batch-correct VST object), species-specific metadata, and species-specific conversion dictionary
load("Z://01_Stefano/Collaboration_Data/VST_Sp_corrected.rds")
counts_VST_corrected <- VST_Sp_corrected



load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Sp_samplemetadata_standard.rds")
sample_metadata <- SpGut_design3
rm(SpGut_design3)

#reorder counts columns based on real AP position
counts_VST_corrected <- as.data.frame(counts_VST_corrected)
counts_VST <- counts_VST_corrected
```


```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "gene_ID"

missing_genes$description <- dictionary_spur$symbol[match(missing_genes$gene_ID,dictionary_spur$geneID)]
#tpo and LOC111580672_slco1c1

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "gene_ID"
selected_genes$description <- dictionary_spur$symbol[match(selected_genes$gene_ID,dictionary_spur$geneID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$gene_ID)




#sort in the order that the genes were given
counts_VST_selectedgenes <- counts_VST_selectedgenes[match(selected_genes$gene_ID, rownames(counts_VST_selectedgenes)), ]


#change the rownames with a more complete description (here, only the gene names)
rownames(counts_VST_selectedgenes) <- dictionary_spur$symbol[match(rownames(counts_VST_selectedgenes), dictionary_spur$geneID)]

```


```{r}
#create an empty dataframe with the right number of rows, which will host the average gene values
counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_selectedgenes),ncol=0))

#to start, create a summary vst that contains the average value of each gene across replicates of the same condition
group_indeces <- c(0, cumsum(unname( table(sample_metadata$segment))))
#calculate the average by group of replicates
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- counts_VST_selectedgenes[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
  
}

#set nicer column names
colnames(counts_VST_averaged) <- paste0(unique(sample_metadata$segment), "_mean")

counts_VST_selectedgenes <- counts_VST_averaged
```


```{r}
#now we need to remove genes that have no variance
zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ]

```





```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```


```{r}
#define column proximity matrix C (samples)
sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix)
```


```{r}
#define row proximity matrix R (genes)
gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="spearman"))
Heatmap(gene_correlation_matrix)
```





```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="pearson"))
#Heatmap(gene_correlation_matrix, 
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(gene_correlation_matrix)$u[, 1], svd(gene_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(gene_correlation_matrix,method="pearson"))
#Heatmap(R1,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
#Heatmap(R2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
#Heatmap(R3,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
#Heatmap(R4,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
#Heatmap(R5,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
#Heatmap(R6,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(gene_correlation_matrix)$d[svd(gene_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(gene_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```


```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R5
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
#plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", col = rep(color_categorical_all[1:7],each=3), pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

#ggplot(PC1PC2_df, aes(x=U1, y=U2))+
#   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
#                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
#                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
#                            angle = 0),
#                        color = "gray")+
#   geom_point()+
#  theme_bw()+
#  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[1])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```


```{r}
###SELECT
#cut_index <- 620  #for all TFS
cut_index <- 51

ifelse(cut_index == nrow(tmp), 
       tmp2_genes <- tmp,
       tmp2_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp2_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
Heatmap(gene_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))])
```



```{r, fig.height=10, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"PiYG")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes))),
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2_genes))],
        #column_order = colnames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2))],
        #column_order = colnames(counts_VST_top2000)[c(1,2,3,5,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )

#ht3 <- Heatmap(sample_correlation_matrix,
#        cluster_rows = F,
#        cluster_columns = F,
#        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        col = rev(brewer.pal(9,"PiYG")))



ht_list = ht1 + ht2
draw(ht_list)
```

#### Tradeseq

```{r}
#library(tradeSeq)
time <- matrix(seq(1:9), nrow=ncol(counts_VST_selectedgenes), ncol=1, byrow=FALSE)
rownames(time) <- colnames(counts_VST_selectedgenes)



weights <- matrix(1, nrow=ncol(counts_VST_selectedgenes), ncol=1) #this needs to be a matrix where each column is a condition (different sample, here only 1), and the value be a binary telling which segments are in which

```

```{r}


## evaluate optimal K
infMat <- evaluateK(counts = as.matrix(counts_VST_selectedgenes), 
                    pseudotime=time, 
                    cellWeights=weights, 
                    nGenes=500, 
                    k=3:6)



```


```{r}
## fit GAM
gamList <- fitGAM(counts = as.matrix(counts_VST_selectedgenes), 
                  pseudotime=time, 
                  cellWeights=weights, 
                  nknots=5)


```
```{r}
rowData(gamList)$assocRes <-  associationTest(gamList, global = T,  contrastType = "consecutive")
assocRes <- rowData(gamList)$assocRes

mockGenes <-  rownames(assocRes)[
  which(assocRes$pvalue<= 0.4)
]
```



```{r, fig.height=15, fig.width=10}
### based on mean smoother
yhatSmooth <- predictSmooth(gamList, gene = mockGenes, nPoints = 50, tidy = FALSE)
heatSmooth <- pheatmap(t(scale(t(yhatSmooth[, 1:50]))),
                       cluster_cols = FALSE,
                       show_rownames = T, 
                       show_colnames = T)
heatSmooth
```


##Pf

```{r}
#SELECT THIS TO PLOT ALL TFs of this species
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Pf_TF_ID.xlsx") 
hmsearch_TFs_list <- unlist(hmsearch_TFs[1]) #1749 proteins


dictionary_pf <-  get(load(file = "Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Pf_dictionary_standard.rds"))


selected_genes <- dictionary_pf$geneID[match(gsub("\\..*","",hmsearch_TFs_list),dictionary_pf$proteinID)] #2408 genes
selected_genes <- na.omit(selected_genes) #1749 genes
```


```{r}
##we can now load the platynereis counts matrix, and the sample metadata, to plot
#Both of these come from you (I have modified it a bit)
load("Z://01_Stefano/Collaboration_Data/VST_Pf_corrected.rds")
counts_VST <- VST_Pf_corrected

load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Pf_samplemetadata_standard.rds") #sample_metadata
sample_metadata <- PfAP_design2

dictionary_pf <-  get(load(file = "Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Pf_dictionary_standard.rds"))


#we will also define the colours for the heatmap labels, and the AP order of the segments
color_categorical_segment <- rep(c("dodgerblue3","darkorange2",  "indianred3",
                                   "lightskyblue","lightskyblue1",
                                   "sandybrown","lightgoldenrod1", "lightyellow",
                                   "lightcoral","lightpink","mistyrose"), each=1)

ordered_levels_segment <- c("Co", "Pr", "Ph1", "Ph2", "Ph3", "Es", "He1", "He2", "In1", "In2", "In3")
```



```{r, echo=FALSE}
# Almost ready to plot!
#This is an optional step, but we need to make sure that all the genes we want to plot ("selected_genes") are actually in the counts matrix. It could be that they are not there so we need to skip them.

#this code will print two tables below: one with the missing genes, one with the genes not missing.

# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "gene_ID"

missing_genes$symbol <- dictionary_pf$symbol[match(missing_genes$gene_ID,dictionary_pf$geneID)]


missing_genes$description <- dictionary_pf$description[match(missing_genes$gene_ID,dictionary_pf$geneID)]


# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "gene_ID"
selected_genes$symbol <- dictionary_pf$symbol[match(selected_genes$gene_ID,dictionary_pf$geneID)]
selected_genes$description <- dictionary_pf$description[match(selected_genes$gene_ID,dictionary_pf$geneID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained (retained)")


#note, in this case the missing genes table is empty because there are no missing genes: all genes in the list we want to plot are in the sea urchin counts table for this dataset
```

```{r}
#
#we have our list of genes, and we know we can plot all of them.
#so we can start now:

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$gene_ID)

#sort in the order that the genes were given
counts_VST_selectedgenes <- counts_VST_selectedgenes[match(selected_genes$gene_ID, rownames(counts_VST_selectedgenes)), ]

#1149

```





```{r}
#create an empty dataframe with the right number of rows, which will host the average gene values
counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_selectedgenes),ncol=0))

#to start, create a summary vst that contains the average value of each gene across replicates of the same condition
group_indeces <- c(0, cumsum(unname( table(sample_metadata$segment))))
#calculate the average by group of replicates
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- counts_VST_selectedgenes[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
  
}

#set nicer column names
colnames(counts_VST_averaged) <- paste0(unique(sample_metadata$segment), "_mean")

counts_VST_selectedgenes <- counts_VST_averaged
```



```{r}
#now we need to remove genes that have no variance
zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ]

```





```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```





```{r}
counts_VST_selectedgenes_all <- counts_VST_selectedgenes
counts_VST_selectedgenes <- counts_VST_selectedgenes[,3:11]

zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ]
```

```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```



```{r}
#define column proximity matrix C (samples)
sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix)
```


```{r}
#define row proximity matrix R (genes)
gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="spearman"))
Heatmap(gene_correlation_matrix, show_column_names = FALSE, show_row_names = FALSE)
```





```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="pearson"))
#Heatmap(gene_correlation_matrix, 
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(gene_correlation_matrix)$u[, 1], svd(gene_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(gene_correlation_matrix,method="pearson"))
#Heatmap(R1,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
#Heatmap(R2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
#Heatmap(R3,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
#Heatmap(R4,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
#Heatmap(R5,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
#Heatmap(R6,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(gene_correlation_matrix)$d[svd(gene_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(gene_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```


```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R4
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
#Heatmap(R_r2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

#ggplot(PC1PC2_df, aes(x=U1, y=U2))+
#  ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
#                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
#                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
#                            angle = 0),
#                        color = "gray")+
#   geom_point()+
#  theme_bw()+
#  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```


```{r}
#cut_index <- 994 #for all TFs
cut_index <- 79#for shared TFs

ifelse(cut_index == nrow(tmp), 
       tmp2_genes <- tmp,
       tmp2_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp2_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
Heatmap(gene_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))])
```



```{r, fig.height=15, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(c(c("11", "13"), rownames(tmp2_genes)[1:23]))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"PiYG")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes))),
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2_genes))],
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(c(c("11", "13"), rownames(tmp2_genes)[1:23]))],
        #column_order = c("oesophagus_mean", "stomach_mean", "liver_mean", "pyloric_mean" ,    "A_intestine_mean", "M_intestine_mean","P_intestine_mean"),
        #column_order = colnames(counts_VST_top2000)[c(1,2,3,5,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )

#ht3 <- Heatmap(sample_correlation_matrix,
#        cluster_rows = F,
#        cluster_columns = F,
#        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        col = rev(brewer.pal(9,"PiYG")))



ht_list = ht1 + ht2
draw(ht_list)
```


#### Tradeseq

```{r}
#library(tradeSeq)
time <- matrix(seq(1:9), nrow=ncol(counts_VST_selectedgenes), ncol=1, byrow=FALSE)
rownames(time) <- colnames(counts_VST_selectedgenes)



weights <- matrix(1, nrow=ncol(counts_VST_selectedgenes), ncol=1) #this needs to be a matrix where each column is a condition (different sample, here only 1), and the value be a binary telling which segments are in which

```

```{r}


## evaluate optimal K
infMat <- evaluateK(counts = as.matrix(counts_VST_selectedgenes), 
                    pseudotime=time, 
                    cellWeights=weights, 
                    nGenes=500, 
                    k=3:6)



```


```{r}
## fit GAM
gamList <- fitGAM(counts = as.matrix(counts_VST_selectedgenes), 
                  pseudotime=time, 
                  cellWeights=weights, 
                  nknots=5)


```
```{r}
rowData(gamList)$assocRes <-  associationTest(gamList, global = T,  contrastType = "consecutive")
assocRes <- rowData(gamList)$assocRes

mockGenes <-  rownames(assocRes)[
  which(assocRes$pvalue<= 0.2)
]
```



```{r, fig.height=15, fig.width=10}
### based on mean smoother
yhatSmooth <- predictSmooth(gamList, gene = mockGenes, nPoints = 50, tidy = FALSE)
heatSmooth <- pheatmap(t(scale(t(yhatSmooth[, 1:50]))),
                       cluster_cols = FALSE,
                       show_rownames = T, 
                       show_colnames = T)
heatSmooth
```

##Bf


```{r}
#SELECT THIS TO PLOT ALL TFs of this species
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Bf_TF_ID.xlsx") 
hmsearch_TFs_list <- unlist(hmsearch_TFs[1]) #2209 proteins

dictionary_bf <-  read.table(file = "Z://01_Stefano/Collaboration_Data/Annotations/Bf_dictionary.csv", sep = ',', header = TRUE)


selected_genes <- dictionary_bf$gene_ID[match(hmsearch_TFs_list,dictionary_bf$protein_ID)] #2209 genes
selected_genes <- na.omit(selected_genes) #2209 genes
```

```{r}
load("Z://01_Stefano/Collaboration_Data/counts_VST_corrected_Bf.rds") #counts_VST_corrected
counts_VST <- as.data.frame(counts_VST_corrected)
load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Bf_samplemetadata_standard.rds") #BfAdultGut_design2
sample_metadata <- BfAdultGut_design2


#ordered by segment and then by stage
color_categorical_segment <- rep(c("dodgerblue3","darkorange2",  "indianred3",
                                   "lightskyblue","lightskyblue1"), each=1)

ordered_levels_segment <- c("En", "Gi", "Lv", "Mi", "Hd")
```



```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
#missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#tpo and LOC111580672_slco1c1

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
#selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Manually curated genes (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)

#sort in the order of the genes
counts_VST_selectedgenes <- counts_VST_selectedgenes[match(selected_genes$entrez_ID, rownames(counts_VST_selectedgenes)), ]



#rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]




```



```{r}
#we have our list of genes, and we know we can plot all of them.
#so we can start now:

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)

#sort in the order that the genes were given
counts_VST_selectedgenes <- counts_VST_selectedgenes[match(selected_genes$entrez_ID, rownames(counts_VST_selectedgenes)), ]


#change the rownames with a more complete description (here, only the gene names)
#rownames(counts_VST_selectedgenes) <- dictionary_bf$symbol[match(rownames(counts_VST_selectedgenes), dictionary_bf$gene_ID)]

#1931
```





```{r}
#create an empty dataframe with the right number of rows, which will host the average gene values
counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_selectedgenes),ncol=0))

#to start, create a summary vst that contains the average value of each gene across replicates of the same condition
group_indeces <- c(0, cumsum(unname( table(sample_metadata$segment))))
#calculate the average by group of replicates
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- counts_VST_selectedgenes[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
  
}

#set nicer column names
colnames(counts_VST_averaged) <- paste0(unique(sample_metadata$segment), "_mean")

counts_VST_selectedgenes <- counts_VST_averaged


```



```{r}
#now we need to remove genes that have no variance
zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ]

```





```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```





```{r}
counts_VST_selectedgenes_all <- counts_VST_selectedgenes
counts_VST_selectedgenes <- counts_VST_selectedgenes[,c(2,3,4,5)]

zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ]
```

```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```

```{r}
#define column proximity matrix C (samples)
sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix)
```


```{r}
#define row proximity matrix R (genes)
gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="spearman"))
Heatmap(gene_correlation_matrix, show_column_names = FALSE, show_row_names = FALSE)
```





```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="pearson"))
#Heatmap(gene_correlation_matrix, 
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(gene_correlation_matrix)$u[, 1], svd(gene_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(gene_correlation_matrix,method="pearson"))
#Heatmap(R1,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
#Heatmap(R2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
#Heatmap(R3,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
#Heatmap(R4,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
#Heatmap(R5,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
#Heatmap(R6,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(gene_correlation_matrix)$d[svd(gene_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(gene_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```


```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R4
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
#Heatmap(R_r2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

#ggplot(PC1PC2_df, aes(x=U1, y=U2))+
#  ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
#                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
#                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
#                            angle = 0),
#                        color = "gray")+
#   geom_point()+
#  theme_bw()+
#  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```


```{r}
#cut_index <- 1298 #for all TFs
#cut_index <- 157 #for shared TFs
cut_index <- 197

ifelse(cut_index == nrow(tmp), 
       tmp2_genes <- tmp,
       tmp2_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp2_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
Heatmap(gene_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))])
```



```{r, fig.height=10, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(c(c("11", "13"), rownames(tmp2_genes)[1:23]))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"PiYG")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes))),
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2_genes))],
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(c(c("11", "13"), rownames(tmp2_genes)[1:23]))],
        #column_order = c("oesophagus_mean", "stomach_mean", "liver_mean", "pyloric_mean" ,    "A_intestine_mean", "M_intestine_mean","P_intestine_mean"),
        #column_order = colnames(counts_VST_top2000)[c(1,2,3,5,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )

#ht3 <- Heatmap(sample_correlation_matrix,
#        cluster_rows = F,
#        cluster_columns = F,
#        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        col = rev(brewer.pal(9,"PiYG")))



ht_list = ht1 + ht2
draw(ht_list)
```


#### Tradeseq

```{r}
#library(tradeSeq)
time <- matrix(seq(1:4), nrow=ncol(counts_VST_selectedgenes), ncol=1, byrow=FALSE)
rownames(time) <- colnames(counts_VST_selectedgenes)



weights <- matrix(1, nrow=ncol(counts_VST_selectedgenes), ncol=1) #this needs to be a matrix where each column is a condition (different sample, here only 1), and the value be a binary telling which segments are in which

```

```{r}


## evaluate optimal K
infMat <- evaluateK(counts = as.matrix(counts_VST_selectedgenes), 
                    pseudotime=time, 
                    cellWeights=weights, 
                    nGenes=500, 
                    k=3:6)



```


```{r}
## fit GAM
gamList <- fitGAM(counts = as.matrix(counts_VST_selectedgenes), 
                  pseudotime=time, 
                  cellWeights=weights, 
                  nknots=3)


```
```{r}
rowData(gamList)$assocRes <-  associationTest(gamList, global = T,  contrastType = "consecutive")
assocRes <- rowData(gamList)$assocRes

mockGenes <-  rownames(assocRes)[
  which(assocRes$pvalue<= 0.2)
]
```



```{r, fig.height=15, fig.width=10}
### based on mean smoother
yhatSmooth <- predictSmooth(gamList, gene = mockGenes, nPoints = 50, tidy = FALSE)
heatSmooth <- pheatmap(t(scale(t(yhatSmooth[, 1:50]))),
                       cluster_cols = FALSE,
                       show_rownames = T, 
                       show_colnames = T)
heatSmooth
```










## Only conserved TFs

```{r}

#find bilaterian conserved orthogroups (our 5 species)
dictionary_orthogroups <- read.table(file = "Z://01_Stefano/Collaboration_Data/Annotations/Results_Nov01/Orthogroups/Orthogroups.tsv", sep = '\t', header = TRUE) #24360 orthogroups
dictionary_orthogroups <- dictionary_orthogroups %>% mutate_all(na_if,"")
dictionary_orthogroups <- na.omit(dictionary_orthogroups)
orthogroups_8bilaterians <- dictionary_orthogroups$Orthogroup  #6145 OGs in all 8 species
#load orthofinder results (from ChingYi)


#Ao
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Ao_TF_ID.xlsx") 
TFs_Ao <- unlist(hmsearch_TFs[1]) #2408 proteins
dictionary_orthogroups <- read.table(file = "Z://01_Stefano/Collaboration_Data/Annotations/Results_Nov01/Orthogroups/Orthogroups.tsv", sep = '\t', header = TRUE)
dictionary_orthogroups <- dictionary_orthogroups %>% separate_rows("Ao", sep = ", ")
dictionary_orthogroups <- dictionary_orthogroups %>% mutate_all(na_if,"")
orthogroups_Ao <- unique(dictionary_orthogroups$Orthogroup[match(TFs_Ao,dictionary_orthogroups$Ao)])
orthogroups_Ao <- na.omit(orthogroups_Ao) #834 OGs
orthogroups_Ao <- orthogroups_Ao[orthogroups_Ao %in% orthogroups_8bilaterians] #327

#Bf
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Bf_TF_ID.xlsx") 
TFs_Bf <- unlist(hmsearch_TFs[1]) #2209 proteins
dictionary_orthogroups <- read.table(file = "Z://01_Stefano/Collaboration_Data/Annotations/Results_Nov01/Orthogroups/Orthogroups.tsv", sep = '\t', header = TRUE)
dictionary_orthogroups <- dictionary_orthogroups %>% separate_rows("Bf", sep = ", ")
dictionary_orthogroups <- dictionary_orthogroups %>% mutate_all(na_if,"")
orthogroups_Bf <- unique(dictionary_orthogroups$Orthogroup[match(TFs_Bf,dictionary_orthogroups$Bf)])
orthogroups_Bf <- na.omit(orthogroups_Bf) #660 OGs
orthogroups_Bf <- orthogroups_Bf[orthogroups_Bf %in% orthogroups_8bilaterians] #328


#Pf
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Pf_TF_ID.xlsx") 
TFs_Pf <- unlist(hmsearch_TFs[1]) #1749 proteins
dictionary_orthogroups <- read.table(file = "Z://01_Stefano/Collaboration_Data/Annotations/Results_Nov01/Orthogroups/Orthogroups.tsv", sep = '\t', header = TRUE)
dictionary_orthogroups <- dictionary_orthogroups %>% separate_rows("Pf", sep = ", ")
dictionary_orthogroups <- dictionary_orthogroups %>% mutate_all(na_if,"")
orthogroups_Pf <- unique(dictionary_orthogroups$Orthogroup[match(TFs_Pf,dictionary_orthogroups$Pf)])
orthogroups_Pf <- na.omit(orthogroups_Pf) #671 OGs
orthogroups_Pf <- orthogroups_Pf[orthogroups_Pf %in% orthogroups_8bilaterians] #319

#Sp
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Sp_TF_ID.xlsx") 
TFs_Sp <- unlist(hmsearch_TFs[1]) #1289 proteins
dictionary_orthogroups <- read.table(file = "Z://01_Stefano/Collaboration_Data/Annotations/Results_Nov01/Orthogroups/Orthogroups.tsv", sep = '\t', header = TRUE)
dictionary_orthogroups <- dictionary_orthogroups %>% separate_rows("Sp", sep = ", ")
dictionary_orthogroups <- dictionary_orthogroups %>% mutate_all(na_if,"")
orthogroups_Sp <- unique(dictionary_orthogroups$Orthogroup[match(TFs_Sp,gsub("\\..*","",dictionary_orthogroups$Sp))])
orthogroups_Sp <- na.omit(orthogroups_Sp) #587 OGs
orthogroups_Sp <- orthogroups_Sp[orthogroups_Sp %in% orthogroups_8bilaterians] #320

#Pd
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Pd_TF_ID.xlsx") 
TFs_Pd <- unlist(hmsearch_TFs[1]) #1844 proteins
dictionary_orthogroups <- read.table(file = "Z://01_Stefano/Collaboration_Data/Annotations/Results_Nov01/Orthogroups/Orthogroups.tsv", sep = '\t', header = TRUE)
dictionary_orthogroups <- dictionary_orthogroups %>% separate_rows("Pd", sep = ", ")
dictionary_orthogroups <- dictionary_orthogroups %>% mutate_all(na_if,"")
orthogroups_Pd<- unique(dictionary_orthogroups$Orthogroup[match(TFs_Pd,gsub("\\..*","",dictionary_orthogroups$Pd))])
orthogroups_Pd <- na.omit(orthogroups_Pd) #626 OGs
orthogroups_Pd <- orthogroups_Pd[orthogroups_Pd %in% orthogroups_8bilaterians] #321


```


```{r}
#create upset plot to check overlap between sets
lt <- list(Ao = orthogroups_Ao,
     Bf = orthogroups_Bf,
     Pf = orthogroups_Pf,
     Sp = orthogroups_Sp,
     Pd = orthogroups_Pd
     )


m1 <- make_comb_mat(list_to_matrix(lt), mode="union")
UpSet(m1[comb_degree(m1) > 0], set_order = c("Ao", "Bf", "Pf", "Sp", "Pd"),
      comb_col = c("black","gray30", "gray60", "gray30", "dodgerblue")[comb_degree(m1)],
       top_annotation = upset_top_annotation(m1[comb_degree(m1) > 0], add_numbers = TRUE),
    right_annotation = upset_right_annotation(m1[comb_degree(m1) > 0], add_numbers = TRUE))


m1 <- make_comb_mat(list_to_matrix(lt), mode="distinct")
UpSet(m1[comb_degree(m1) > 0], set_order = c("Ao", "Bf", "Pf", "Sp", "Pd"),
      comb_col = c("black","gray30", "gray60", "gray30", "dodgerblue")[comb_degree(m1)],
       top_annotation = upset_top_annotation(m1[comb_degree(m1) > 0], add_numbers = TRUE),
    right_annotation = upset_right_annotation(m1[comb_degree(m1) > 0], add_numbers = TRUE))
```
```{r}
orthogroups_Ao[(orthogroups_Ao %in% unlist(lt[c("Bf", "Pf", "Sp", "Pd")])) == F]
orthogroups_Bf[(orthogroups_Bf %in% unlist(lt[c("Ao", "Pf", "Sp", "Pd")])) == F]
orthogroups_Pf[(orthogroups_Pf %in% unlist(lt[c("Ao", "Bf",  "Sp", "Pd")])) == F]
orthogroups_Sp[(orthogroups_Sp %in% unlist(lt[c("Ao", "Bf", "Pf",  "Pd")])) == F]
orthogroups_Pd[(orthogroups_Pd %in% unlist(lt[c("Ao", "Bf", "Pf", "Sp")])) == F]
```



```{r}

##find shared orthogroups (restrictive)
#orthogroup_TFs <- Reduce(intersect, list(orthogroups_Ao,orthogroups_Bf,orthogroups_Pd,orthogroups_Pf,orthogroups_Sp)) #311 OGs

#find shared orthogroups (generous)
orthogroup_TFs <- unique(unlist(list(orthogroups_Ao,orthogroups_Bf,orthogroups_Pd,orthogroups_Pf,orthogroups_Sp))) #352 OGs

#fix Hox (remove old ones, add new custom ones)
orthogroup_TFs <- orthogroup_TFs[!(orthogroup_TFs %in% c("OG0002402", "OG0003787","OG0002536", "OG0002082", "OG0003182", "OG0014381", "OG0007873", "OG0001524", "OG0000143", "OG0010095", "OG0014380", "OG0000648", "OG0012499", "OG0019418", "OG0014281", "OG0008007", "OG0014379","OG0014282", "OG0014378", "OG0005102", "OG0014378", "OG0008729"))] #350
orthogroup_TFs <- unique(c(orthogroup_TFs, c("OG000PG01", "OG000PG02", "OG000PG0304", "OG000PG05","OG000PG0607", "OG000PG08", "OG000PG0910", "OG000PG1115"))) #358

orthogroup_TFs_all <- orthogroup_TFs

```


```{r}
#theoretically, could plot all 358 orthogroups, but our best match filtered out some of them (unequal representation)
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")
orthogroup_TFs <- orthogroup_TFs_all[orthogroup_TFs_all %in% rownames(dictionary_orthogroups_best_withHox_genebased)] #356

orthogroup_TFs_all[orthogroup_TFs_all %in% rownames(dictionary_orthogroups_best_withHox_genebased)==F]
# "OG0000015" "OG0000027"

orthogroup_TFs_all <- orthogroup_TFs #356
save(orthogroup_TFs, file= "Z://01_Stefano/Collaboration_Data/356_plottable_TF_orthogroups.rds" )
```

```{r}
# I have this list of TFs too (i.e. TF based on clownfish hmmsearch)
orthogroup_TFs_02 <- get(load("Z://01_Stefano/Collaboration_Data/orthogroups_TFs.rds"))

summary(orthogroup_TFs_all %in% orthogroup_TFs_02)
orthogroup_TFs_all[(orthogroup_TFs_all %in% orthogroup_TFs_02) == F]
#i.e. in the current list, there are 25 orthogroups that were not annotated as TFs in the clownfish search 

summary(orthogroup_TFs_02 %in% orthogroup_TFs_all)
orthogroup_TFs_02[(orthogroup_TFs_02 %in% orthogroup_TFs_all) == F]
#i.e. the current list includes all TF orthogroups of the previous one
```



```{r}
#we here remove genes with no variance
load("Z://01_Stefano/Collaboration_Data/invariantTFs_Ao.rds") #13
load("Z://01_Stefano/Collaboration_Data/invariantTFs_Bf.rds") #0
load("Z://01_Stefano/Collaboration_Data/invariantTFs_Pf.rds") #1
load("Z://01_Stefano/Collaboration_Data/invariantTFs_Sp.rds") #3
load("Z://01_Stefano/Collaboration_Data/invariantTFs_Pd.rds") #4

invariant_TFs <- unique(c(invariantTFs_Ao, invariantTFs_Bf, invariantTFs_Pf, invariantTFs_Sp, invariantTFs_Pd)) #21

orthogroup_TFs <- orthogroup_TFs[!(orthogroup_TFs %in% invariant_TFs)] #335
#save(orthogroup_TFs, file= "Z://01_Stefano/Collaboration_Data/335_plottable_TF_orthogroups.rds" )
```





##Ao

```{r}
#load("Z://01_Stefano/Collaboration_Data/356_plottable_TF_orthogroups.rds")
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species_expressed.rds") #shared_TFs_8species_expressed [277/356]
orthogroup_TFs <- unique(shared_TFs_8species_expressed) #277


#find genes
selected_genes <- dictionary_orthogroups_best_withHox_genebased[orthogroup_TFs, "Ao"]
selected_genes <- na.omit(selected_genes)
selected_genes <- make.unique(as.character(selected_genes)) #277

```




```{r}
##we can now load the platynereis counts matrix, and the sample metadata, to plot
#Both of these come from you (I have modified it a bit)
load("Z://01_Stefano/Collaboration_Data/VST_Ao_corrected.rds")
counts_VST <- VST_Ao_corrected

load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Ao_samplemetadata_standard.rds") #sample_metadata
liver_metadata <- data.frame(segment = rep("liver", 3), replicate = c(1,2,3))
rownames(liver_metadata) <- c("liv_01", "liv_02", "liv_03")
sample_metadata <- rbind(liver_metadata, sample_metadata)
rm(liver_metadata)

dictionary_aoce <-  get(load(file = "Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Aoce_dictionary_standard.rds"))


#we will also define the colours for the heatmap labels, and the AP order of the segments
color_categorical_segment <- rep(c("indianred1","lightpink", "sandybrown", "lightgoldenrod1",
                    "dodgerblue3","lightskyblue","lightskyblue1"),each=1)


ordered_levels_segment <- c("liver","oesophagus", "stomach", "pyloric", "A_intestine", "M_intestine", "P_intestine")
```



```{r, echo=FALSE}
# Almost ready to plot!
#This is an optional step, but we need to make sure that all the genes we want to plot ("selected_genes") are actually in the counts matrix. It could be that they are not there so we need to skip them.

#this code will print two tables below: one with the missing genes, one with the genes not missing.

# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "gene_ID"

missing_genes$symbol <- dictionary_aoce$symbol[match(missing_genes$gene_ID,dictionary_aoce$geneID)]


missing_genes$description <- dictionary_aoce$description[match(missing_genes$gene_ID,dictionary_aoce$geneID)]


# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "gene_ID"
selected_genes$symbol <- dictionary_aoce$symbol[match(selected_genes$gene_ID,dictionary_aoce$geneID)]
selected_genes$description <- dictionary_aoce$description[match(selected_genes$gene_ID,dictionary_aoce$geneID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained (retained)")


#note, in this case the missing genes table is empty because there are no missing genes: all genes in the list we want to plot are in the sea urchin counts table for this dataset
```



```{r}
#we have our list of genes, and we know we can plot all of them.
#so we can start now:

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$gene_ID)

#sort in the order that the genes were given
counts_VST_selectedgenes <- counts_VST_selectedgenes[match(selected_genes$gene_ID, rownames(counts_VST_selectedgenes)), ]


#change the rownames with ORTHOGROUP CODE
rownames(counts_VST_selectedgenes) <- rownames(dictionary_orthogroups_best_withHox_genebased[match(rownames(counts_VST_selectedgenes), dictionary_orthogroups_best_withHox_genebased$Ao),])
```





```{r}
#create an empty dataframe with the right number of rows, which will host the average gene values
counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_selectedgenes),ncol=0))

#to start, create a summary vst that contains the average value of each gene across replicates of the same condition
group_indeces <- c(0, cumsum(unname( table(sample_metadata$segment))))
#calculate the average by group of replicates
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- counts_VST_selectedgenes[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
  
}

#set nicer column names
colnames(counts_VST_averaged) <- paste0(unique(sample_metadata$segment), "_mean")

counts_VST_selectedgenes <- counts_VST_averaged
```


```{r}
#now we need to remove genes that have no variance
zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))
#check which OGs would be lost

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ] #277

#check which ones got lost
invariantTFs_Ao <- setdiff(rownames(zcounts_VST_selectedgenes), rownames(counts_VST_selectedgenes))
invariantTFs_Ao
#save(invariantTFs_Ao, file= "Z://01_Stefano/Collaboration_Data/invariantTFs_Ao.rds")
```





```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```



```{r}
counts_VST_selectedgenes <- counts_VST_averaged
counts_VST_selectedgenes_all <- counts_VST_selectedgenes
counts_VST_selectedgenes <- counts_VST_selectedgenes[,2:7]

zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ] #305

#check which ones got lost
invariantTFs_Ao <- setdiff(rownames(zcounts_VST_selectedgenes), rownames(counts_VST_selectedgenes))
invariantTFs_Ao
#save(invariantTFs_Ao, file= "Z://01_Stefano/Collaboration_Data/invariantTFs_Ao.rds")
```

```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```

```{r}
#define column proximity matrix C (samples)
sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix)
```

```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix, 
        cluster_rows = T,
        cluster_columns = T)
plot(svd(sample_correlation_matrix)$u[, 1], svd(sample_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(sample_correlation_matrix,method="pearson"))
Heatmap(R1,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
Heatmap(R2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
Heatmap(R3,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
Heatmap(R4,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
Heatmap(R5,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
Heatmap(R6,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(sample_correlation_matrix)$d[svd(sample_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(sample_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```




```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R3
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

ggplot(PC1PC2_df, aes(x=U1, y=U2))+
   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
                            angle = 0),
                        color = "gray")+
   geom_point()+
  theme_bw()+
  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = T),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```

```{r}
cut_index <- 5

ifelse(cut_index == nrow(tmp), 
       tmp_genes <- tmp,
       tmp_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
image <- Heatmap(sample_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        col = brewer.pal(9,"BuPu"),
        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))])

htR2E <- draw(image)
```
```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_seriation_segments_Ao_CPM10.pdf")
draw(image)

dev.off()
```


```{r}
#define row proximity matrix R (genes)
gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="spearman"))
Heatmap(gene_correlation_matrix, show_column_names = FALSE, show_row_names = FALSE)
```


```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="pearson"))
#Heatmap(gene_correlation_matrix, 
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(gene_correlation_matrix)$u[, 1], svd(gene_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(gene_correlation_matrix,method="pearson"))
#Heatmap(R1,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
#Heatmap(R2,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
#Heatmap(R3,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
#Heatmap(R4,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
#Heatmap(R5,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
#Heatmap(R6,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(gene_correlation_matrix)$d[svd(gene_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(gene_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```


```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R4
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
#Heatmap(R_r2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

#ggplot(PC1PC2_df, aes(x=U1, y=U2))+
#  ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
#                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
#                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
#                            angle = 0),
#                        color = "gray")+
#   geom_point()+
#  theme_bw()+
#  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = T),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```


```{r}
#cut_index <- 406 #for all Tfs
cut_index <- 82 #for all Tfs


ifelse(cut_index == nrow(tmp), 
       tmp2_genes <- tmp,
       tmp2_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp2_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
Heatmap(gene_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))])
```

```{r}
#if you still want to plot the original full set of segments (counts_VST_selectedgenes_all), even though the order was calculated on a subset of the samples, and some of the genes may have been removed in the process
counts_VST_selectedgenes_all <- counts_VST_selectedgenes_all[rownames(counts_VST_selectedgenes_all) %in% rownames(counts_VST_selectedgenes),]
```


```{r, fig.height=15, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(c(c("11", "13"), rownames(tmp2_genes)[1:23]))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"PiYG")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes_all))),
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(counts_VST_selectedgenes_all)[as.numeric(rownames(tmp2_genes))],
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(c(c("11", "13"), rownames(tmp2_genes)[1:23]))],
        #column_order = c("oesophagus_mean", "stomach_mean", "liver_mean", "pyloric_mean" ,    "A_intestine_mean", "M_intestine_mean","P_intestine_mean"),
        #column_order = colnames(counts_VST_top2000)[c(1,2,3,5,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )


ht_list = ht1 + ht2
draw(ht_list)
```
```{r}
TF_order_R2E_Aoce <- rownames(counts_VST_selectedgenes_all)[as.numeric(rownames(tmp2_genes))]
#save(TF_order_R2E_Aoce, file= "Z://01_Stefano/Collaboration_Data/TF_order_R2E_Aoce.rds")
```

#### Tradeseq

```{r}
#library(tradeSeq)
time <- matrix(seq(1:6), nrow=ncol(counts_VST_selectedgenes), ncol=1, byrow=FALSE)
rownames(time) <- colnames(counts_VST_selectedgenes)

weights <- matrix(1, nrow=ncol(counts_VST_selectedgenes), ncol=1) #this needs to be a matrix where each column is a condition (different sample, here only 1), and the value be a binary telling which segments are in which

```

```{r}
## evaluate optimal K
infMat <- evaluateK(counts = as.matrix(counts_VST_selectedgenes), 
                    pseudotime=time, 
                    cellWeights=weights, 
                    nGenes=nrow(counts_VST_selectedgenes), 
                    k=3:6)



```


```{r}
## fit GAM
gamList <- fitGAM(counts = as.matrix(counts_VST_selectedgenes), 
                  pseudotime=time, 
                  cellWeights=weights, 
                  nknots=3)


```
```{r}
assocRes <-  associationTest(gamList, global = T,  contrastType = "consecutive")

hist(assocRes$pvalue, breaks=100)
plot(x= seq(1:length(assocRes$pvalue)), y=assocRes$pvalue, pch=16, col=scales::alpha("black", 0.5))
abline(h=0.05)
```

```{r}
mockGenes <-  rownames(assocRes)[
  which(assocRes$pvalue<= 0.8)
]
```


```{r, fig.height=15, fig.width=10}
### based on mean smoother
yhatSmooth <- predictSmooth(gamList, gene = mockGenes, nPoints = 50, tidy = FALSE)
tradseqTFs_Ao <- rownames(yhatSmooth) 


rownames(yhatSmooth) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(yhatSmooth),rownames(dictionary_orthogroups_best_withHox_genebased))]
rownames(yhatSmooth) <- dictionary_aoce$description[match(rownames(yhatSmooth),dictionary_aoce$geneID)]

heatSmooth <- pheatmap(t(scale(t(yhatSmooth[, 1:50]))),
                       cluster_cols = FALSE,
                       show_rownames = T, 
                       show_colnames = T)
heatSmooth
```

```{r}
save(tradseqTFs_Ao, file= "Z://01_Stefano/Collaboration_Data/tradseqTFs_Ao.rds")
```


##Pd

```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species_expressed.rds") #shared_TFs_8species_expressed [277/356]
orthogroup_TFs <- unique(shared_TFs_8species_expressed) #277


#find genes
selected_genes <- dictionary_orthogroups_best_withHox_genebased[orthogroup_TFs, "Pd"] 
selected_genes <- na.omit(selected_genes)
selected_genes <- make.unique(as.character(selected_genes)) #277

```




```{r}
##we can now load the platynereis counts matrix, and the sample metadata, to plot
#Both of these come from you (I have modified it a bit)
load("Z://01_Stefano/Collaboration_Data/VST_Pd_corrected.rds")
counts_VST <- VST_Pd_corrected

load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Pd_samplemetadata_standard.rds") #SpGut_design3




#we will also define the colours for the heatmap labels, and the AP order of the segments
color_categorical_segment_pd <- rep(c("dodgerblue3","darkorange2",  "indianred3", "lightskyblue","lightskyblue1", "sandybrown","lightgoldenrod1", "lightyellow", "lightcoral","lightpink"), each=1)

ordered_levels_segment_pd <- unique(sample_metadata$segment)
```



```{r, echo=FALSE}
# Almost ready to plot!
#This is an optional step, but we need to make sure that all the genes we want to plot ("selected_genes") are actually in the counts matrix. It could be that they are not there so we need to skip them.

#this code will print two tables below: one with the missing genes, one with the genes not missing.

# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "gene_ID"

dictionary_pdum <-  get(load(file = "Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Pd_dictionary_standard.rds"))
missing_genes$symbol <- dictionary_pdum$symbol[match(missing_genes$gene_ID,dictionary_pdum$geneID)]


missing_genes$description <- dictionary_pdum$description[match(missing_genes$gene_ID,dictionary_pdum$geneID)]


# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "gene_ID"
selected_genes$symbol <- dictionary_pdum$symbol[match(selected_genes$gene_ID,dictionary_pdum$geneID)]
selected_genes$description <- dictionary_pdum$description[match(selected_genes$gene_ID,dictionary_pdum$geneID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained (retained)")


#note, in this case the missing genes table is empty because there are no missing genes: all genes in the list we want to plot are in the sea urchin counts table for this dataset
```

```{r}
#277
#we have our list of genes, and we know we can plot all of them.
#so we can start now:

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$gene_ID)

#sort in the order that the genes were given
counts_VST_selectedgenes <- counts_VST_selectedgenes[match(selected_genes$gene_ID, rownames(counts_VST_selectedgenes)), ]

#change the rownames with ORTHOGROUP CODE
rownames(counts_VST_selectedgenes) <- rownames(dictionary_orthogroups_best_withHox_genebased[match(rownames(counts_VST_selectedgenes), dictionary_orthogroups_best_withHox_genebased$Pd),])
```





```{r}
#create an empty dataframe with the right number of rows, which will host the average gene values
counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_selectedgenes),ncol=0))

#to start, create a summary vst that contains the average value of each gene across replicates of the same condition
group_indeces <- c(0, cumsum(unname( table(sample_metadata$segment))))
#calculate the average by group of replicates
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- counts_VST_selectedgenes[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
  
}

#set nicer column names
colnames(counts_VST_averaged) <- paste0(unique(sample_metadata$segment), "_mean")

counts_VST_selectedgenes <- counts_VST_averaged
```



```{r}
#now we need to remove genes that have no variance
zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))
#check which OGs would be lost

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ] #277

#check which ones got lost
invariantTFs_Pd <- setdiff(rownames(zcounts_VST_selectedgenes), rownames(counts_VST_selectedgenes))
invariantTFs_Pd
#save(invariantTFs_Pd, file= "Z://01_Stefano/Collaboration_Data/invariantTFs_Pd.rds")
```





```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = F, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```



```{r}
counts_VST_selectedgenes <- counts_VST_averaged
counts_VST_selectedgenes_all <- counts_VST_selectedgenes
counts_VST_selectedgenes <- counts_VST_selectedgenes[,3:10]

zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ] #277

#check which ones got lost
invariantTFs_Pd <- setdiff(rownames(zcounts_VST_selectedgenes), rownames(counts_VST_selectedgenes))
invariantTFs_Pd
#save(invariantTFs_Pd, file= "Z://01_Stefano/Collaboration_Data/invariantTFs_Pd.rds")
```

```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```




```{r}
#define column proximity matrix C (samples)
sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix)
```
```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix, 
        cluster_rows = T,
        cluster_columns = T)
plot(svd(sample_correlation_matrix)$u[, 1], svd(sample_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(sample_correlation_matrix,method="pearson"))
Heatmap(R1,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
Heatmap(R2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
Heatmap(R3,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
Heatmap(R4,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
Heatmap(R5,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
Heatmap(R6,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(sample_correlation_matrix)$d[svd(sample_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(sample_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```
```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R3
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

ggplot(PC1PC2_df, aes(x=U1, y=U2))+
   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
                            angle = 0),
                        color = "gray")+
   geom_point()+
  theme_bw()+
  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = T),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```

```{r}
cut_index <- 8

ifelse(cut_index == nrow(tmp), 
       tmp_genes <- tmp,
       tmp_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
image <- Heatmap(sample_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        col = brewer.pal(9,"BuPu"),
        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))])

htR2E <- draw(image)
```
```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_seriation_segments_Pd_CPM10.pdf")
draw(image)

dev.off()
```

```{r}
#define row proximity matrix R (genes)
gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="spearman"))
Heatmap(gene_correlation_matrix)
```


```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="pearson"))
#Heatmap(gene_correlation_matrix, 
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(gene_correlation_matrix)$u[, 1], svd(gene_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(gene_correlation_matrix,method="pearson"))
#Heatmap(R1,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
#Heatmap(R2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
#Heatmap(R3,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
#Heatmap(R4,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
#Heatmap(R5,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
#Heatmap(R6,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(gene_correlation_matrix)$d[svd(gene_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(gene_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```


```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R5
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
#plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", col = rep(color_categorical_all[1:7],each=3), pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

#ggplot(PC1PC2_df, aes(x=U1, y=U2))+
#   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
#                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
#                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
#                            angle = 0),
#                        color = "gray")+
#   geom_point()+
#  theme_bw()+
#  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = T),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[1])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```


```{r}
###SELECT
#cut_index <- 550 #for all TFs
cut_index <- 188

ifelse(cut_index == nrow(tmp), 
       tmp2_genes <- tmp,
       tmp2_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp2_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
Heatmap(gene_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))])
```
```{r}
#if you still want to plot the original full set of segments (counts_VST_selectedgenes_all), even though the order was calculated on a subset of the samples, and some of the genes may have been removed in the process
counts_VST_selectedgenes_all2 <- counts_VST_selectedgenes_all[rownames(counts_VST_selectedgenes_all) %in% rownames(counts_VST_selectedgenes),]
```


```{r, fig.height=10, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"PiYG")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes_all2))),
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(counts_VST_selectedgenes_all2)[as.numeric(rownames(tmp2_genes))],
        #column_order = colnames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2))],
        #column_order = colnames(counts_VST_top2000)[c(1,2,3,5,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )

#ht3 <- Heatmap(sample_correlation_matrix,
#        cluster_rows = F,
#        cluster_columns = F,
#        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        col = rev(brewer.pal(9,"PiYG")))



ht_list = ht1 + ht2
draw(ht_list)
```

```{r}
TF_order_R2E_Pd <- rownames(counts_VST_selectedgenes_all)[as.numeric(rownames(tmp2_genes))]
save(TF_order_R2E_Pd, file= "Z://01_Stefano/Collaboration_Data/TF_order_R2E_Pd.rds")
```


#### Tradeseq

```{r}
#library(tradeSeq)
time <- matrix(seq(1:8), nrow=ncol(counts_VST_selectedgenes), ncol=1, byrow=FALSE)
rownames(time) <- colnames(counts_VST_selectedgenes)



weights <- matrix(1, nrow=ncol(counts_VST_selectedgenes), ncol=1) #this needs to be a matrix where each column is a condition (different sample, here only 1), and the value be a binary telling which segments are in which

```

```{r}
##for some reason the counts matrix still has negative values
counts_VST_selectedgenes_noneg <-counts_VST_selectedgenes
counts_VST_selectedgenes_noneg$has_negatives<-apply(counts_VST_selectedgenes, 1, function(x) any(x<0))
counts_VST_selectedgenes_noneg <- counts_VST_selectedgenes_noneg[counts_VST_selectedgenes_noneg$has_negatives == F,] #271
counts_VST_selectedgenes_noneg <- counts_VST_selectedgenes_noneg[,1:8]

## evaluate optimal K
infMat <- evaluateK(counts = as.matrix(counts_VST_selectedgenes_noneg), 
                    pseudotime=time, 
                    cellWeights=weights, 
                    nGenes=nrow(counts_VST_selectedgenes_noneg), 
                    k=3:6)



```


```{r}
## fit GAM
gamList <- fitGAM(counts = as.matrix(counts_VST_selectedgenes_noneg), 
                  pseudotime=time, 
                  cellWeights=weights, 
                  nknots=3)


```

```{r}
assocRes <-  associationTest(gamList, global = T,  contrastType = "consecutive")

hist(assocRes$pvalue, breaks=100)
plot(x= seq(1:length(assocRes$pvalue)), y=assocRes$pvalue, pch=16, col=scales::alpha("black", 0.5))
abline(h=0.05)
```

```{r}
mockGenes <-  rownames(assocRes)[
  which(assocRes$pvalue<= 0.8)
]
```

```{r, fig.height=15, fig.width=10}
### based on mean smoother
yhatSmooth <- predictSmooth(gamList, gene = mockGenes, nPoints = 50, tidy = FALSE)
tradseqTFs_Pd <- rownames(yhatSmooth) 

rownames(yhatSmooth) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(yhatSmooth),rownames(dictionary_orthogroups_best_withHox_genebased))]
rownames(yhatSmooth) <- dictionary_aoce$description[match(rownames(yhatSmooth),dictionary_aoce$geneID)]

heatSmooth <- pheatmap(t(scale(t(yhatSmooth[, 1:50]))),
                       cluster_cols = FALSE,
                       show_rownames = T, 
                       show_colnames = T)
heatSmooth
```
```{r}
save(tradseqTFs_Pd, file= "Z://01_Stefano/Collaboration_Data/tradseqTFs_Pd.rds")
```

##Sp

```{r}
#load("Z://01_Stefano/Collaboration_Data/356_plottable_TF_orthogroups.rds")
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species_expressed.rds") #shared_TFs_8species_expressed [277/356]
orthogroup_TFs <- unique(shared_TFs_8species_expressed) #277

#find genes
selected_genes <- dictionary_orthogroups_best_withHox_genebased[orthogroup_TFs, "Sp"]
selected_genes <- na.omit(selected_genes)
selected_genes <- make.unique(as.character(selected_genes)) #277

```


```{r}
color_categorical_segment <- c("dodgerblue2",  "dodgerblue3",  "goldenrod",  "goldenrod","goldenrod1", "goldenrod1", "orchid1", "orchid1", "orchid"
                           )

#load starting point counts matrix (batch-correct VST object), species-specific metadata, and species-specific conversion dictionary
load("Z://01_Stefano/Collaboration_Data/VST_Sp_corrected.rds")
counts_VST_corrected <- VST_Sp_corrected



load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Sp_samplemetadata_standard.rds")
sample_metadata <- SpGut_design3
rm(SpGut_design3)

#reorder counts columns based on real AP position
counts_VST_corrected <- as.data.frame(counts_VST_corrected)
counts_VST <- counts_VST_corrected
```


```{r, echo=FALSE}
dictionary_spur <-  get(load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Sp_dictionary_standard.rds"))

# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "gene_ID"

missing_genes$description <- dictionary_spur$symbol[match(missing_genes$gene_ID,dictionary_spur$geneID)]
#tpo and LOC111580672_slco1c1

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "gene_ID"
selected_genes$description <- dictionary_spur$symbol[match(selected_genes$gene_ID,dictionary_spur$geneID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained (retained)")

```


```{r}
#277
#we have our list of genes, and we know we can plot all of them.
#so we can start now:

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$gene_ID)

#sort in the order that the genes were given
counts_VST_selectedgenes <- counts_VST_selectedgenes[match(selected_genes$gene_ID, rownames(counts_VST_selectedgenes)), ]

#change the rownames with ORTHOGROUP CODE
rownames(counts_VST_selectedgenes) <- rownames(dictionary_orthogroups_best_withHox_genebased[match(rownames(counts_VST_selectedgenes), dictionary_orthogroups_best_withHox_genebased$Sp),])
```


```{r}
#create an empty dataframe with the right number of rows, which will host the average gene values
counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_selectedgenes),ncol=0))

#to start, create a summary vst that contains the average value of each gene across replicates of the same condition
group_indeces <- c(0, cumsum(unname( table(sample_metadata$segment))))
#calculate the average by group of replicates
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- counts_VST_selectedgenes[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
  
}

#set nicer column names
colnames(counts_VST_averaged) <- paste0(unique(sample_metadata$segment), "_mean")

counts_VST_selectedgenes <- counts_VST_averaged
```


```{r}
#now we need to remove genes that have no variance
zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))
#check which OGs would be lost

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ] #277

#check which ones got lost
invariantTFs_Sp <- setdiff(rownames(zcounts_VST_selectedgenes), rownames(counts_VST_selectedgenes))
invariantTFs_Sp
#save(invariantTFs_Sp, file= "Z://01_Stefano/Collaboration_Data/invariantTFs_Sp.rds")
```

```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = F, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```



```{r}
#define column proximity matrix C (samples)
sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix)
```
```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix, 
        cluster_rows = T,
        cluster_columns = T)
plot(svd(sample_correlation_matrix)$u[, 1], svd(sample_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(sample_correlation_matrix,method="pearson"))
Heatmap(R1,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
Heatmap(R2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
Heatmap(R3,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
Heatmap(R4,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
Heatmap(R5,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
Heatmap(R6,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(sample_correlation_matrix)$d[svd(sample_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(sample_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```
```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R3
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

ggplot(PC1PC2_df, aes(x=U1, y=U2))+
   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
                            angle = 0),
                        color = "gray")+
   geom_point()+
  theme_bw()+
  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = T),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```

```{r}
cut_index <- 9

ifelse(cut_index == nrow(tmp), 
       tmp_genes <- tmp,
       tmp_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
image <- Heatmap(sample_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        col = brewer.pal(9,"BuPu"),
        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))])

htR2E <- draw(image)
```
```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_seriation_segments_Sp_CPM10.pdf")
draw(image)

dev.off()
```
















```{r}
#define row proximity matrix R (genes)
gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="spearman"))
Heatmap(gene_correlation_matrix)
```





```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="pearson"))
#Heatmap(gene_correlation_matrix, 
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(gene_correlation_matrix)$u[, 1], svd(gene_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(gene_correlation_matrix,method="pearson"))
#Heatmap(R1,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
#Heatmap(R2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
#Heatmap(R3,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
#Heatmap(R4,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
#Heatmap(R5,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
#Heatmap(R6,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(gene_correlation_matrix)$d[svd(gene_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(gene_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```


```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R5
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
#plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", col = rep(color_categorical_all[1:7],each=3), pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

#ggplot(PC1PC2_df, aes(x=U1, y=U2))+
#   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
#                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
#                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
#                            angle = 0),
#                        color = "gray")+
#   geom_point()+
#  theme_bw()+
#  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[1])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```


```{r}
###SELECT
#cut_index <- 620  #for all TFS
cut_index <- 51

ifelse(cut_index == nrow(tmp), 
       tmp2_genes <- tmp,
       tmp2_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp2_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
Heatmap(gene_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))])
```



```{r, fig.height=10, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"PiYG")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes))),
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2_genes))],
        #column_order = colnames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2))],
        #column_order = colnames(counts_VST_top2000)[c(1,2,3,5,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )

#ht3 <- Heatmap(sample_correlation_matrix,
#        cluster_rows = F,
#        cluster_columns = F,
#        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        col = rev(brewer.pal(9,"PiYG")))



ht_list = ht1 + ht2
draw(ht_list)
```

```{r}
TF_order_R2E_Sp <- rownames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2_genes))]
#save(TF_order_R2E_Sp, file= "Z://01_Stefano/Collaboration_Data/TF_order_R2E_Sp.rds")
```

#### Tradeseq

```{r}
#library(tradeSeq)
time <- matrix(seq(1:9), nrow=ncol(counts_VST_selectedgenes), ncol=1, byrow=FALSE)
rownames(time) <- colnames(counts_VST_selectedgenes)

weights <- matrix(1, nrow=ncol(counts_VST_selectedgenes), ncol=1) #this needs to be a matrix where each column is a condition (different sample, here only 1), and the value be a binary telling which segments are in which

```

```{r}


## evaluate optimal K
infMat <- evaluateK(counts = as.matrix(counts_VST_selectedgenes), 
                    pseudotime=time, 
                    cellWeights=weights, 
                    nGenes=nrow(counts_VST_selectedgenes), 
                    k=3:6)



```


```{r}
## fit GAM
gamList <- fitGAM(counts = as.matrix(counts_VST_selectedgenes), 
                  pseudotime=time, 
                  cellWeights=weights, 
                  nknots=3)


```

```{r}
assocRes <- associationTest(gamList, global = T,  contrastType = "consecutive")

hist(assocRes$pvalue, breaks=100)
plot(x= seq(1:length(assocRes$pvalue)), y=assocRes$pvalue, pch=16, col=scales::alpha("black", 0.5))
abline(h=0.05)
```

```{r}
mockGenes <-  rownames(assocRes)[
  which(assocRes$pvalue<= 0.8)
]
```

```{r, fig.height=15, fig.width=10}
### based on mean smoother
yhatSmooth <- predictSmooth(gamList, gene = mockGenes, nPoints = 50, tidy = FALSE)
tradseqTFs_Sp <- rownames(yhatSmooth) 

rownames(yhatSmooth) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(yhatSmooth),rownames(dictionary_orthogroups_best_withHox_genebased))]
rownames(yhatSmooth) <- dictionary_aoce$description[match(rownames(yhatSmooth),dictionary_aoce$geneID)]

heatSmooth <- pheatmap(t(scale(t(yhatSmooth[, 1:50]))),
                       cluster_cols = FALSE,
                       show_rownames = T, 
                       show_colnames = T)
heatSmooth
```
```{r}
save(tradseqTFs_Sp, file= "Z://01_Stefano/Collaboration_Data/tradseqTFs_Sp.rds")
```


##Pf
```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species_expressed.rds") #shared_TFs_8species_expressed [277/356]
orthogroup_TFs <- unique(shared_TFs_8species_expressed) #277

#find genes
selected_genes <- dictionary_orthogroups_best_withHox_genebased[orthogroup_TFs, "Pf"]
selected_genes <- na.omit(selected_genes)
selected_genes <- make.unique(as.character(selected_genes)) #277

```




```{r}
##we can now load the platynereis counts matrix, and the sample metadata, to plot
#Both of these come from you (I have modified it a bit)
load("Z://01_Stefano/Collaboration_Data/VST_Pf_corrected.rds")
counts_VST <- VST_Pf_corrected

load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Pf_samplemetadata_standard.rds") #sample_metadata
sample_metadata <- PfAP_design2

dictionary_pf <-  get(load(file = "Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Pf_dictionary_standard.rds"))


#we will also define the colours for the heatmap labels, and the AP order of the segments
color_categorical_segment <- rep(c("dodgerblue3","darkorange2",  "indianred3",
                                   "lightskyblue","lightskyblue1",
                                   "sandybrown","lightgoldenrod1", "lightyellow",
                                   "lightcoral","lightpink","mistyrose"), each=1)

ordered_levels_segment <- c("Co", "Pr", "Ph1", "Ph2", "Ph3", "Es", "He1", "He2", "In1", "In2", "In3")
```



```{r, echo=FALSE}
# Almost ready to plot!
#This is an optional step, but we need to make sure that all the genes we want to plot ("selected_genes") are actually in the counts matrix. It could be that they are not there so we need to skip them.

#this code will print two tables below: one with the missing genes, one with the genes not missing.

# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "gene_ID"

missing_genes$symbol <- dictionary_pf$symbol[match(missing_genes$gene_ID,dictionary_pf$geneID)]


missing_genes$description <- dictionary_pf$description[match(missing_genes$gene_ID,dictionary_pf$geneID)]


# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "gene_ID"
selected_genes$symbol <- dictionary_pf$symbol[match(selected_genes$gene_ID,dictionary_pf$geneID)]
selected_genes$description <- dictionary_pf$description[match(selected_genes$gene_ID,dictionary_pf$geneID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Genes retained (retained)")


#note, in this case the missing genes table is empty because there are no missing genes: all genes in the list we want to plot are in the sea urchin counts table for this dataset
```

```{r}
#277

#we have our list of genes, and we know we can plot all of them.
#so we can start now:

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$gene_ID)

#sort in the order that the genes were given
counts_VST_selectedgenes <- counts_VST_selectedgenes[match(selected_genes$gene_ID, rownames(counts_VST_selectedgenes)), ]

#change the rownames with ORTHOGROUP CODE
rownames(counts_VST_selectedgenes) <- rownames(dictionary_orthogroups_best_withHox_genebased[match(rownames(counts_VST_selectedgenes), dictionary_orthogroups_best_withHox_genebased$Pf),])
```





```{r}
#create an empty dataframe with the right number of rows, which will host the average gene values
counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_selectedgenes),ncol=0))

#to start, create a summary vst that contains the average value of each gene across replicates of the same condition
group_indeces <- c(0, cumsum(unname( table(sample_metadata$segment))))
#calculate the average by group of replicates
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- counts_VST_selectedgenes[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
  
}

#set nicer column names
colnames(counts_VST_averaged) <- paste0(unique(sample_metadata$segment), "_mean")

counts_VST_selectedgenes <- counts_VST_averaged
```



```{r}
#now we need to remove genes that have no variance
zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))
#check which OGs would be lost

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ] #277

#check which ones got lost
invariantTFs_Pf <- setdiff(rownames(zcounts_VST_selectedgenes), rownames(counts_VST_selectedgenes))
invariantTFs_Pf
#save(invariantTFs_Pf, file= "Z://01_Stefano/Collaboration_Data/invariantTFs_Pf.rds")
```





```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = F, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```

```{r}
counts_VST_selectedgenes <- counts_VST_averaged
counts_VST_selectedgenes_all <- counts_VST_selectedgenes
counts_VST_selectedgenes <- counts_VST_selectedgenes[,3:11]

zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ] #351

#check which ones got lost
invariantTFs_Pf <- setdiff(rownames(zcounts_VST_selectedgenes), rownames(counts_VST_selectedgenes))
invariantTFs_Pf
#save(invariantTFs_Pf, file= "Z://01_Stefano/Collaboration_Data/invariantTFs_Pf.rds")
```

```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```



```{r}
#define column proximity matrix C (samples)
sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix)
```
```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix, 
        cluster_rows = T,
        cluster_columns = T)
plot(svd(sample_correlation_matrix)$u[, 1], svd(sample_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(sample_correlation_matrix,method="pearson"))
Heatmap(R1,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
Heatmap(R2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
Heatmap(R3,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
Heatmap(R4,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
Heatmap(R5,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
Heatmap(R6,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(sample_correlation_matrix)$d[svd(sample_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(sample_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```
```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R3
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

ggplot(PC1PC2_df, aes(x=U1, y=U2))+
   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
                            angle = 0),
                        color = "gray")+
   geom_point()+
  theme_bw()+
  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = T),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```

```{r}
cut_index <- 9

ifelse(cut_index == nrow(tmp), 
       tmp_genes <- tmp,
       tmp_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
image <- Heatmap(sample_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        col = brewer.pal(9,"BuPu"),
        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))])

htR2E <- draw(image)
```
```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_seriation_segments_Pf_CPM10.pdf")
draw(image)

dev.off()
```












```{r}
#define row proximity matrix R (genes)
gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="spearman"))
Heatmap(gene_correlation_matrix, show_column_names = FALSE, show_row_names = FALSE)
```





```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="pearson"))
#Heatmap(gene_correlation_matrix, 
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(gene_correlation_matrix)$u[, 1], svd(gene_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(gene_correlation_matrix,method="pearson"))
#Heatmap(R1,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
#Heatmap(R2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
#Heatmap(R3,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
#Heatmap(R4,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
#Heatmap(R5,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
#Heatmap(R6,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(gene_correlation_matrix)$d[svd(gene_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(gene_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```


```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R4
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
#Heatmap(R_r2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

#ggplot(PC1PC2_df, aes(x=U1, y=U2))+
#  ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
#                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
#                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
#                            angle = 0),
#                        color = "gray")+
#   geom_point()+
#  theme_bw()+
#  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```


```{r}
#cut_index <- 994 #for all TFs
cut_index <- 79#for shared TFs

ifelse(cut_index == nrow(tmp), 
       tmp2_genes <- tmp,
       tmp2_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp2_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
Heatmap(gene_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))])
```

```{r}
#if you still want to plot the original full set of segments (counts_VST_selectedgenes_all), even though the order was calculated on a subset of the samples, and some of the genes may have been removed in the process
counts_VST_selectedgenes_all2 <- counts_VST_selectedgenes_all[rownames(counts_VST_selectedgenes_all) %in% rownames(counts_VST_selectedgenes),]
```

```{r, fig.height=15, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(c(c("11", "13"), rownames(tmp2_genes)[1:23]))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"PiYG")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes_all2))),
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(counts_VST_selectedgenes_all2)[as.numeric(rownames(tmp2_genes))],
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(c(c("11", "13"), rownames(tmp2_genes)[1:23]))],
        #column_order = c("oesophagus_mean", "stomach_mean", "liver_mean", "pyloric_mean" ,    "A_intestine_mean", "M_intestine_mean","P_intestine_mean"),
        #column_order = colnames(counts_VST_top2000)[c(1,2,3,5,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )

#ht3 <- Heatmap(sample_correlation_matrix,
#        cluster_rows = F,
#        cluster_columns = F,
#        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        col = rev(brewer.pal(9,"PiYG")))



ht_list = ht1 + ht2
draw(ht_list)
```

```{r}
TF_order_R2E_Pf <- rownames(counts_VST_selectedgenes_all2)[as.numeric(rownames(tmp2_genes))]
save(TF_order_R2E_Pf, file= "Z://01_Stefano/Collaboration_Data/TF_order_R2E_Pf.rds")
```

#### Tradeseq

```{r}
#library(tradeSeq)
time <- matrix(seq(1:9), nrow=ncol(counts_VST_selectedgenes), ncol=1, byrow=FALSE)
rownames(time) <- colnames(counts_VST_selectedgenes)

weights <- matrix(1, nrow=ncol(counts_VST_selectedgenes), ncol=1) #this needs to be a matrix where each column is a condition (different sample, here only 1), and the value be a binary telling which segments are in which

```

```{r}


## evaluate optimal K
infMat <- evaluateK(counts = as.matrix(counts_VST_selectedgenes), 
                    pseudotime=time, 
                    cellWeights=weights, 
                    nGenes=nrow(counts_VST_selectedgenes), 
                    k=3:6)



```


```{r}
## fit GAM
gamList <- fitGAM(counts = as.matrix(counts_VST_selectedgenes), 
                  pseudotime=time, 
                  cellWeights=weights, 
                  nknots=3)


```
```{r}
assocRes <-  associationTest(gamList, global = T,  contrastType = "consecutive")

hist(assocRes$pvalue, breaks=100)
plot(x= seq(1:length(assocRes$pvalue)), y=assocRes$pvalue, pch=16, col=scales::alpha("black", 0.5))
abline(h=0.05)
```

```{r}
mockGenes <-  rownames(assocRes)[
  which(assocRes$pvalue<= 0.8)
]
```

```{r, fig.height=15, fig.width=10}
### based on mean smoother
yhatSmooth <- predictSmooth(gamList, gene = mockGenes, nPoints = 50, tidy = FALSE)
tradseqTFs_Pf <- rownames(yhatSmooth) 

rownames(yhatSmooth) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(yhatSmooth),rownames(dictionary_orthogroups_best_withHox_genebased))]
rownames(yhatSmooth) <- dictionary_aoce$description[match(rownames(yhatSmooth),dictionary_aoce$geneID)]

heatSmooth <- pheatmap(t(scale(t(yhatSmooth[, 1:50]))),
                       cluster_cols = FALSE,
                       show_rownames = T, 
                       show_colnames = T)
heatSmooth
```
```{r}
save(tradseqTFs_Pf, file= "Z://01_Stefano/Collaboration_Data/tradseqTFs_Pf.rds")
```

##Bf

```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species_expressed.rds") #shared_TFs_8species_expressed [277/356]
orthogroup_TFs <- unique(shared_TFs_8species_expressed) #277

#find genes
selected_genes <- dictionary_orthogroups_best_withHox_genebased[orthogroup_TFs, "Bf"]
selected_genes <- na.omit(selected_genes)
selected_genes <- make.unique(as.character(selected_genes)) #277

```



```{r}
load("Z://01_Stefano/Collaboration_Data/counts_VST_corrected_Bf.rds") #counts_VST_corrected
counts_VST <- as.data.frame(counts_VST_corrected)
load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/Bf_samplemetadata_standard.rds") #BfAdultGut_design2
sample_metadata <- BfAdultGut_design2


#ordered by segment and then by stage
color_categorical_segment <- rep(c("dodgerblue3","darkorange2",  "indianred3",
                                   "lightskyblue","lightskyblue1"), each=1)

ordered_levels_segment <- c("En", "Gi", "Lv", "Mi", "Hd")
```



```{r, echo=FALSE}
# Returns the missing genes:
missing_genes <- as.data.frame(setdiff(selected_genes, row.names(counts_VST))) 
colnames(missing_genes) <- "entrez_ID"
#missing_genes$description <- annotation_info$merged_description[match(missing_genes$entrez_ID,annotation_info$entrez_ID)]
#tpo and LOC111580672_slco1c1

# Returns the existing genes:
selected_genes <- as.data.frame(intersect(selected_genes, row.names(counts_VST)))
colnames(selected_genes) <- "entrez_ID"
#selected_genes$description <- annotation_info$merged_description[match(selected_genes$entrez_ID,annotation_info$entrez_ID)]

#print list of dicarded genes (because missing) and of retained genes (curated digestion genes, present in the dataset)

kable(missing_genes, caption = "Genes missing from the dataset (ignored)")
kable(selected_genes, caption = "Manually curated genes (retained)")

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)

#sort in the order of the genes
counts_VST_selectedgenes <- counts_VST_selectedgenes[match(selected_genes$entrez_ID, rownames(counts_VST_selectedgenes)), ]



#rownames(counts_VST_selectedgenes) <- annotation_info$merged_description[match(rownames(counts_VST_selectedgenes), annotation_info$entrez_ID)]




```



```{r}
#we have our list of genes, and we know we can plot all of them.
#so we can start now:

## subset the original VST objects to only keep selected genes
counts_VST_selectedgenes <- subset(counts_VST, rownames(counts_VST) %in% selected_genes$entrez_ID)

#sort in the order that the genes were given
counts_VST_selectedgenes <- counts_VST_selectedgenes[match(selected_genes$entrez_ID, rownames(counts_VST_selectedgenes)), ]


#change the rownames with ORTHOGROUP CODE
rownames(counts_VST_selectedgenes) <- rownames(dictionary_orthogroups_best_withHox_genebased[match(rownames(counts_VST_selectedgenes), dictionary_orthogroups_best_withHox_genebased$Bf),])
```





```{r}
#create an empty dataframe with the right number of rows, which will host the average gene values
counts_VST_averaged <- data.frame(matrix(nrow=nrow(counts_VST_selectedgenes),ncol=0))

#to start, create a summary vst that contains the average value of each gene across replicates of the same condition
group_indeces <- c(0, cumsum(unname( table(sample_metadata$segment))))
#calculate the average by group of replicates
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- counts_VST_selectedgenes[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  counts_VST_averaged <- cbind(counts_VST_averaged, tmp_averages)
  
}

#set nicer column names
colnames(counts_VST_averaged) <- paste0(unique(sample_metadata$segment), "_mean")

counts_VST_selectedgenes <- counts_VST_averaged


```




```{r}
#now we need to remove genes that have no variance
zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))
#check which OGs would be lost

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ] #277

#check which ones got lost
invariantTFs_Bf <- setdiff(rownames(zcounts_VST_selectedgenes), rownames(counts_VST_selectedgenes))
invariantTFs_Bf
#save(invariantTFs_Bf, file= "Z://01_Stefano/Collaboration_Data/invariantTFs_Bf.rds")
```

```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```


```{r}
counts_VST_selectedgenes <- counts_VST_averaged
counts_VST_selectedgenes_all <- counts_VST_selectedgenes
counts_VST_selectedgenes <- counts_VST_selectedgenes[,c(2,3,4,5)]

zcounts_VST_selectedgenes <- as.data.frame(t(scale(t(counts_VST_selectedgenes))))

counts_VST_selectedgenes <- counts_VST_selectedgenes[match(rownames(na.omit(zcounts_VST_selectedgenes)), rownames(counts_VST_selectedgenes)), ] #277
#check which ones got lost
invariantTFs_Bf <- setdiff(rownames(zcounts_VST_selectedgenes), rownames(counts_VST_selectedgenes))
invariantTFs_Bf
#save(invariantTFs_Bf, file= "Z://01_Stefano/Collaboration_Data/invariantTFs_Bf.rds")
```

```{r}
Heatmap(t(scale(t(counts_VST_selectedgenes))), cluster_columns = FALSE, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```

```{r}
#define column proximity matrix C (samples)
sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix)
```

```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix, 
        cluster_rows = T,
        cluster_columns = T)
plot(svd(sample_correlation_matrix)$u[, 1], svd(sample_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(sample_correlation_matrix,method="pearson"))
Heatmap(R1,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
Heatmap(R2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
Heatmap(R3,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
Heatmap(R4,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
Heatmap(R5,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
Heatmap(R6,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(sample_correlation_matrix)$d[svd(sample_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(sample_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```
```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R3
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

ggplot(PC1PC2_df, aes(x=U1, y=U2))+
   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
                            angle = 0),
                        color = "gray")+
   geom_point()+
  theme_bw()+
  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = T),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```

```{r}
cut_index <- 4

ifelse(cut_index == nrow(tmp), 
       tmp_genes <- tmp,
       tmp_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
image <- Heatmap(sample_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        col = brewer.pal(9,"BuPu"),
        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))])

htR2E <- draw(image)
```
```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_seriation_segments_Bf_CPM10.pdf")
draw(image)

dev.off()
```



















```{r}
#define row proximity matrix R (genes)
gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="spearman"))
Heatmap(gene_correlation_matrix, show_column_names = FALSE, show_row_names = FALSE)
```





```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="pearson"))
#Heatmap(gene_correlation_matrix, 
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(gene_correlation_matrix)$u[, 1], svd(gene_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(gene_correlation_matrix,method="pearson"))
#Heatmap(R1,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
#Heatmap(R2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
#Heatmap(R3,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
#Heatmap(R4,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
#Heatmap(R5,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
#Heatmap(R6,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(gene_correlation_matrix)$d[svd(gene_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(gene_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```


```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R4
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
#Heatmap(R_r2,
#        cluster_rows = T,
#        cluster_columns = T)
#plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

#ggplot(PC1PC2_df, aes(x=U1, y=U2))+
#  ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
#                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
#                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
#                            angle = 0),
#                        color = "gray")+
#   geom_point()+
#  theme_bw()+
#  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```


```{r}
#cut_index <- 1298 #for all TFs
cut_index <- 207 #for shared TFs #197


ifelse(cut_index == nrow(tmp), 
       tmp2_genes <- tmp,
       tmp2_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp2_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
Heatmap(gene_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))])
```
```{r}
#if you still want to plot the original full set of segments (counts_VST_selectedgenes_all), even though the order was calculated on a subset of the samples, and some of the genes may have been removed in the process
counts_VST_selectedgenes_all2 <- counts_VST_selectedgenes_all[rownames(counts_VST_selectedgenes_all) %in% rownames(counts_VST_selectedgenes),]
```


```{r, fig.height=10, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(c(c("11", "13"), rownames(tmp2_genes)[1:23]))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"PiYG")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes_all2))),
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(counts_VST_selectedgenes_all2)[as.numeric(rownames(tmp2_genes))],
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(c(c("11", "13"), rownames(tmp2_genes)[1:23]))],
        #column_order = c("oesophagus_mean", "stomach_mean", "liver_mean", "pyloric_mean" ,    "A_intestine_mean", "M_intestine_mean","P_intestine_mean"),
        #column_order = colnames(counts_VST_top2000)[c(1,2,3,5,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )

#ht3 <- Heatmap(sample_correlation_matrix,
#        cluster_rows = F,
#        cluster_columns = F,
#        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp2))],
#        col = rev(brewer.pal(9,"PiYG")))



ht_list = ht1 + ht2
draw(ht_list)
```
```{r}
TF_order_R2E_Bf <- rownames(counts_VST_selectedgenes_all2)[as.numeric(rownames(tmp2_genes))]
save(TF_order_R2E_Bf, file= "Z://01_Stefano/Collaboration_Data/TF_order_R2E_Bf.rds")
```

#### Tradeseq

```{r}
#library(tradeSeq)
time <- matrix(seq(1:4), nrow=ncol(counts_VST_selectedgenes), ncol=1, byrow=FALSE)
rownames(time) <- colnames(counts_VST_selectedgenes)

weights <- matrix(1, nrow=ncol(counts_VST_selectedgenes), ncol=1) #this needs to be a matrix where each column is a condition (different sample, here only 1), and the value be a binary telling which segments are in which

```

```{r}


## evaluate optimal K
infMat <- evaluateK(counts = as.matrix(counts_VST_selectedgenes), 
                    pseudotime=time, 
                    cellWeights=weights, 
                    nGenes=nrow(counts_VST_selectedgenes), 
                    k=3:6)



```


```{r}
## fit GAM
gamList <- fitGAM(counts = as.matrix(counts_VST_selectedgenes), 
                  pseudotime=time, 
                  cellWeights=weights, 
                  nknots=3)


```
```{r}
assocRes <-  associationTest(gamList, global = T,  contrastType = "consecutive")

hist(assocRes$pvalue, breaks=100)
plot(x= seq(1:length(assocRes$pvalue)), y=assocRes$pvalue, pch=16, col=scales::alpha("black", 0.5))
abline(h=0.05)
```

```{r}
mockGenes <-  rownames(assocRes)[
  which(assocRes$pvalue<= 0.8)
]
```


```{r, fig.height=15, fig.width=10}
### based on mean smoother
yhatSmooth <- predictSmooth(gamList, gene = mockGenes, nPoints = 50, tidy = FALSE)
tradseqTFs_Bf <- rownames(yhatSmooth) 

rownames(yhatSmooth) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(yhatSmooth),rownames(dictionary_orthogroups_best_withHox_genebased))]
rownames(yhatSmooth) <- dictionary_aoce$description[match(rownames(yhatSmooth),dictionary_aoce$geneID)]

heatSmooth <- pheatmap(t(scale(t(yhatSmooth[, 1:50]))),
                       cluster_cols = FALSE,
                       show_rownames = T, 
                       show_colnames = T)
heatSmooth
```

```{r}
save(tradseqTFs_Bf, file= "Z://01_Stefano/Collaboration_Data/tradseqTFs_Bf.rds")
```










### Tradeseq summary

```{r}
load("Z://01_Stefano/Collaboration_Data/tradseqTFs_Ao.rds")
load("Z://01_Stefano/Collaboration_Data/tradseqTFs_Bf.rds")
load("Z://01_Stefano/Collaboration_Data/tradseqTFs_Pf.rds")
load("Z://01_Stefano/Collaboration_Data/tradseqTFs_Sp.rds")
load("Z://01_Stefano/Collaboration_Data/tradseqTFs_Pd.rds")

```

```{r}
#create upset plot to check overlap between sets
lt <- list(Ao = tradseqTFs_Ao,
     Bf = tradseqTFs_Bf,
     Pf = tradseqTFs_Pf,
     Sp = tradseqTFs_Sp,
     Pd = tradseqTFs_Pd
     )


m1 <- make_comb_mat(list_to_matrix(lt), mode="union")
UpSet(m1[comb_degree(m1) > 0], set_order = c("Ao", "Bf", "Pf", "Sp", "Pd"),
      comb_col = c("black","gray30", "gray60", "gray30", "dodgerblue")[comb_degree(m1)],
       top_annotation = upset_top_annotation(m1[comb_degree(m1) > 0], add_numbers = TRUE),
    right_annotation = upset_right_annotation(m1[comb_degree(m1) > 0], add_numbers = TRUE))


m1 <- make_comb_mat(list_to_matrix(lt), mode="distinct")
UpSet(m1[comb_degree(m1) > 0], set_order = c("Ao", "Bf", "Pf", "Sp", "Pd"),
      comb_col = c("black","gray30", "gray60", "gray30", "dodgerblue")[comb_degree(m1)],
       top_annotation = upset_top_annotation(m1[comb_degree(m1) > 0], add_numbers = TRUE),
    right_annotation = upset_right_annotation(m1[comb_degree(m1) > 0], add_numbers = TRUE))
```

```{r}
##find shared orthogroups (restrictive)
tradseqTFs_restrictive <- Reduce(intersect, list(tradseqTFs_Ao,tradseqTFs_Bf,tradseqTFs_Pd,tradseqTFs_Pf,tradseqTFs_Sp)) #7 OGs
#save(tradseqTFs_restrictive, file= "Z://01_Stefano/Collaboration_Data/tradseqTFs_restrictive.rds")


#find shared orthogroups (generous)
tradseqTFs_generous <- unique(unlist(list(tradseqTFs_Ao,tradseqTFs_Bf,tradseqTFs_Pd,tradseqTFs_Pf,tradseqTFs_Sp))) #85 OGs
#save(tradseqTFs_generous, file= "Z://01_Stefano/Collaboration_Data/tradseqTFs_generous.rds")
```






####THIS PCA (species-specific z-scored matrix, TFs only, only selected tissue)


```{r, fig.width= 10, fig.height=4, echo=FALSE}
#A lot of variability and associations int he datasat are either driven, or organised aorund clownfish liver, sea urchin phatynx + oesophagus, or Pf Co+Pr
#Let us see what happens if we remove them from the analysis (of course, we loose the information about what tissue they may be similar to in other species)

#load and  subset merged_metadata
load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/merged_metadata.rds") #merged_metadata
merged_metadata <- merged_metadata[!(row(merged_metadata)[,1] %in% c(1,2,3, #Ao liver
                                                                     22,23,24,25, #Bf endostyle
                                                                     42, 43, 44,45,46,47, #Pf anterior 2
                                                                     #71,72,73,75,76,77,78,79, 80,81,82,
                                                                     111,112,113, 114,115, 116 #Pd mouh
                                                                     )),]
merged_metadata$segment <- factor(merged_metadata$segment, levels = unique(merged_metadata$segment))

#recreate zscored matrix without considering the values of those samples
load("Z://01_Stefano/Collaboration_Data/Annotations/merged_counts.rds") #merged_counts

zcounts_Ao <- merged_counts[ , 4:21]
zcounts_Bf <- merged_counts[ , 26:41]
zcounts_Pf <- merged_counts[ , 48:74]
zcounts_Sp <- merged_counts[ , 75:110]
zcounts_Pd <- merged_counts[ , 117:140]

zcounts_Ao <- t(scale(t(zcounts_Ao)))
zcounts_Bf <- t(scale(t(zcounts_Bf)))
zcounts_Pf <- t(scale(t(zcounts_Pf)))
zcounts_Sp <- t(scale(t(zcounts_Sp)))
zcounts_Pd <- t(scale(t(zcounts_Pd)))

#some genes have the same values in all samples, and give NaN when z-scored
#replace Nan with 0
zcounts_Ao[is.na(zcounts_Ao)] <- 0
zcounts_Bf[is.na(zcounts_Bf)] <- 0
zcounts_Pf[is.na(zcounts_Pf)] <- 0
zcounts_Sp[is.na(zcounts_Sp)] <- 0
zcounts_Pd[is.na(zcounts_Pd)] <- 0

zmerged_counts <- Reduce(merge, lapply(list(zcounts_Ao, zcounts_Bf, zcounts_Pf, zcounts_Sp, zcounts_Pd), data.table, keep.rownames = TRUE, key = "rn"))
zmerged_counts <- as.data.frame(zmerged_counts)

#remove extra col
rownames(zmerged_counts) <- zmerged_counts$rn
zmerged_counts <- zmerged_counts[,2:ncol(zmerged_counts)]



```

```{r, fig.width= 10, fig.height=4, echo=FALSE}



#### AVERAGE OR NOT? (comment/uncomment)
zmerged_counts_averaged <- data.frame(matrix(nrow=nrow(zmerged_counts),ncol=0))
group_indeces <- c(0, cumsum(unname( table(merged_metadata$segment))))
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- zmerged_counts[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  zmerged_counts_averaged <- cbind(zmerged_counts_averaged, tmp_averages)
  
}
colnames(zmerged_counts_averaged) <- paste0(unique(merged_metadata$segment), "_mean")
zmerged_counts<- zmerged_counts_averaged

merged_metadata_averaged <- merged_metadata
merged_metadata_averaged <- merged_metadata_averaged[!duplicated(merged_metadata_averaged$segment),]
rownames(merged_metadata_averaged) <- paste0(merged_metadata_averaged$segment, "_mean")
merged_metadata <- merged_metadata_averaged
###


#5839 genes
```

```{r}

## For PCA we need to start with the data in the correct format (we need conditions as row, and genes as columns)

load("Z://01_Stefano/Collaboration_Data/tradseqTFs_generous.rds") #85TF orthogroups #orthogroup_TFs
#subset with only TF orthogroups
zmerged_counts_TFs <- zmerged_counts[rownames(zmerged_counts) %in% tradseqTFs_generous,] #85 orthogroups left
# transpose our counts matrix (switch rows and columns)
counts_VST_top2000_transposed <- t(zmerged_counts_TFs)




```


```{r}
#library(tradeSeq)
time <- matrix(seq(1:4), nrow=ncol(zmerged_counts_TFs), ncol=1, byrow=FALSE)
rownames(time) <- colnames(zmerged_counts_TFs)



weights <- matrix(0, nrow=ncol(zmerged_counts_TFs), ncol=5) #this needs to be a matrix where each column is a condition (different sample, here only 1), and the value be a binary telling which segments are in which
weights[1:6,1] <- 1
weights[7:10,2] <- 1
weights[11:19,3] <- 1
weights[20:28,4] <- 1
weights[29:36,5] <- 1

```

```{r}
#for some reason the counts matrix still has negative values
zmerged_counts_TFs_noneg <-zmerged_counts_TFs
zmerged_counts_TFs_noneg$has_negatives<-apply(zmerged_counts_TFs, 1, function(x) any(x<0))
zmerged_counts_TFs_noneg <- zmerged_counts_TFs_noneg[zmerged_counts_TFs_noneg$has_negatives == F,] #1149
zmerged_counts_TFs_noneg <- zmerged_counts_TFs_noneg[,1:8]


## evaluate optimal K
infMat <- evaluateK(counts = as.matrix(zmerged_counts_TFs), 
                    pseudotime=time, 
                    cellWeights=weights, 
                    nGenes=nrow(zmerged_counts_TFs), 
                    k=3:6)



```


```{r}
## fit GAM
gamList <- fitGAM(counts = as.matrix(zmerged_counts_TFs), 
                  pseudotime=time, 
                  cellWeights=weights, 
                  nknots=3)


```
```{r}
rowData(gamList)$assocRes <-  associationTest(gamList, global = T,  contrastType = "consecutive")
assocRes <- rowData(gamList)$assocRes

hist(assocRes$pvalue, breaks=100)
plot(x= seq(1:length(assocRes$pvalue)), y=assocRes$pvalue, pch=16, col=scales::alpha("black", 0.5))
abline(h=0.05)
```

```{r}
mockGenes <-  rownames(assocRes)[
  which(assocRes$pvalue<= 0.8)
]
```


```{r, fig.height=15, fig.width=10}
### based on mean smoother
yhatSmooth <- predictSmooth(gamList, gene = mockGenes, nPoints = 50, tidy = FALSE)
tradseqTFs_Bf <- rownames(yhatSmooth) 

rownames(yhatSmooth) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(yhatSmooth),rownames(dictionary_orthogroups_best_withHox_genebased))]
rownames(yhatSmooth) <- dictionary_aoce$description[match(rownames(yhatSmooth),dictionary_aoce$geneID)]

heatSmooth <- pheatmap(t(scale(t(yhatSmooth[, 1:50]))),
                       cluster_cols = FALSE,
                       show_rownames = T, 
                       show_colnames = T)
heatSmooth
```












###Joint R2E seriation 
```{r, fig.width=10, fig.height=15}
Heatmap(t(scale(t(zmerged_counts_TFs))), cluster_columns = T, cluster_rows = T, na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```

```{r}
counts_VST_selectedgenes_all <- zmerged_counts_TFs
#counts_VST_selectedgenes <- zmerged_counts_TFs[,c(2,3,5,6,7)]
counts_VST_selectedgenes <- zmerged_counts_TFs
```


```{r}
#define column proximity matrix C (samples)
sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
ht <- Heatmap(sample_correlation_matrix)
ht <- draw(ht)
ht
```

```{r, fig.width=10, fig.height=10}
# calculate correlation betwwen samples

# Users should always use circlize::colorRamp2() function to generate the color mapping function
#col_fun = colorRamp2(c(-1, 0, 1), brewer.pal(9,"BuPu")[c(1,5,9)])

color_categorical_segment <- c("skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "orchid",
                               "skyblue2", "indianred", "goldenrod1", "orchid",
                               "skyblue2", "skyblue2", "skyblue2", "dodgerblue", "indianred", "indianred", "magenta", "magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "goldenrod1","goldenrod1", "magenta","magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "magenta", "orchid", "orchid")
names(color_categorical_segment) <- paste0(unique(merged_metadata$segment), "_mean")
color_categorical_segment_named <- color_categorical_segment


colAnn <- HeatmapAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            which = 'col',
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE
                            )

rowAnn <- rowAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                        show_legend = FALSE,
                        show_annotation_name = FALSE
                            )



#### samples


rightAnn <- rowAnnotation(df = data.frame(Ao = paste0(unique(merged_metadata$segment), "_mean"),
                                          Bf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Sp = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pd = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to match the name of the named list
                   
                            
                            col = list("Ao" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=1, to=6)))], "white"),
                                       "Bf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=7, to=10)))], "white"),
                                       "Pf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=11, to=19)))], "white"),
                                       "Sp" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=20, to=28)))], "white"),
                                       "Pd" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=29, to=36)))], "white")), #set the name of the named list so it matches
                   simple_anno_size = unit(0.6, "cm"),
                   empty2 = anno_empty(border = FALSE, width= unit(4, "mm")),
                   show_legend = FALSE
                   
                   )














Heatmap(mat = sample_correlation_matrix,
        name= "Pearson rho",
        column_title = gt_render(paste0("<span style='color:darkorchid4'>**Spearman's ", expression(ρ), "**</span> correlation coeff. <br/> between samples <span style='color:gray60'>(on most variable genes)</span>")),
        #col = brewer.pal(9,"BuPu"),
        col = colorRamp2(c(-1, 0, 1), rev(brewer.pal(9,"RdGy")[c(1,5,9)])),
        #col = colorRamp2(c(-1, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col = brewer.pal(9,"PiYG"),
        #col =  colorRamp2(c(-0.5, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col = 
        na_col = "black",
        cluster_rows = T,
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = T,
        show_column_dend = T,
        #row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        #column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        #column_order = ordered_levels,
        #row_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        #column_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(0.5, "mm"),
        width = unit(12, "cm"), 
        height = unit(12, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        left_annotation = rowAnn,
        right_annotation = rightAnn,
        show_heatmap_legend = T
        )

```

```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

sample_correlation_matrix <- as.matrix(cor(counts_VST_selectedgenes,method="pearson"))
Heatmap(sample_correlation_matrix, 
        cluster_rows = T,
        cluster_columns = T)
plot(svd(sample_correlation_matrix)$u[, 1], svd(sample_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(sample_correlation_matrix,method="pearson"))
Heatmap(R1,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
Heatmap(R2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
Heatmap(R3,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
Heatmap(R4,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
Heatmap(R5,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
Heatmap(R6,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(sample_correlation_matrix)$d[svd(sample_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(sample_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```
```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R3
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

ggplot(PC1PC2_df, aes(x=U1, y=U2))+
   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
                            angle = 0),
                        color = "gray")+
   geom_point()+
  theme_bw()+
  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = T),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```

```{r}
cut_index <- 31

ifelse(cut_index == nrow(tmp), 
       tmp_genes <- tmp,
       tmp_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
htR2E <- Heatmap(sample_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))])

htR2E <- draw(htR2E)
```

```{r, fig.width=10, fig.height=10}
# calculate correlation betwwen samples

# Users should always use circlize::colorRamp2() function to generate the color mapping function
#col_fun = colorRamp2(c(-1, 0, 1), brewer.pal(9,"BuPu")[c(1,5,9)])

color_categorical_segment <- c("skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "orchid",
                               "skyblue2", "indianred", "goldenrod1", "orchid",
                               "skyblue2", "skyblue2", "skyblue2", "dodgerblue", "indianred", "indianred", "magenta", "magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "goldenrod1","goldenrod1", "magenta","magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "magenta", "orchid", "orchid")
names(color_categorical_segment) <- paste0(unique(merged_metadata$segment), "_mean")
color_categorical_segment_named <- color_categorical_segment


colAnn <- HeatmapAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            which = 'col',
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE
                            )

rowAnn <- rowAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                        show_legend = FALSE,
                        show_annotation_name = FALSE
                            )



#### samples


rightAnn <- rowAnnotation(df = data.frame(Ao = paste0(unique(merged_metadata$segment), "_mean"),
                                          Bf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Sp = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pd = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to match the name of the named list
                   
                            
                            col = list("Ao" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=1, to=6)))], "white"),
                                       "Bf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=7, to=10)))], "white"),
                                       "Pf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=11, to=19)))], "white"),
                                       "Sp" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=20, to=28)))], "white"),
                                       "Pd" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=29, to=36)))], "white")), #set the name of the named list so it matches
                   simple_anno_size = unit(0.6, "cm"),
                   empty2 = anno_empty(border = FALSE, width= unit(4, "mm")),
                   show_legend = FALSE
                   
                   )


image <- Heatmap(mat = sample_correlation_matrix,
        name= "Pearson rho",
        column_title = gt_render(paste0("<span style='color:darkorchid4'>**Spearman's ", expression(ρ), "**</span> correlation coeff. <br/> between samples <span style='color:gray60'>(on most variable genes)</span>")),
        #col = brewer.pal(9,"BuPu"),
        col = colorRamp2(c(-1, 0, 1), rev(brewer.pal(9,"RdGy")[c(1,5,9)])),
        #col = colorRamp2(c(-1, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col = brewer.pal(9,"PiYG"),
        #col =  colorRamp2(c(-0.5, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col = 
        na_col = "black",
        cluster_rows = FALSE,
        show_row_dend = FALSE,
        #row_order = ordered_levels,
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        row_order = rownames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        #column_order = ordered_levels,
        #row_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        #column_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(0.5, "mm"),
        width = unit(12, "cm"), 
        height = unit(12, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        left_annotation = rowAnn,
        right_annotation = rightAnn,
        show_heatmap_legend = T
        )


draw(image)
```

```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_APassociated_segmentseriation_R2E.pdf")
draw(image)
dev.off()
```

```{r}
dataframe <- data.frame(gene = rownames(sample_correlation_matrix), original_order = seq(1:nrow(sample_correlation_matrix)))

seriation_order <- row_order(htR2E)

dataframe$original_seriation_order <- seriation_order

for (i in seq(1:nrow(dataframe))) {
  dataframe$R2E_order[i] <- which(seriation_order == dataframe$original_order[i])
}  


Heatmap(sample_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = F, 
        #row_order = rownames(counts_VST_selectedgenes)[seriation_order],
        row_order = dataframe$gene[order(dataframe$R2E_order)],
        column_order= dataframe$gene[order(dataframe$R2E_order)],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```

```{r, fig.width=10, fig.height=7}
hclust <- hclust(dist(sample_correlation_matrix), method = "ward.D2")
hclust_order <- hclust$order

reordered_object <- stats::reorder(x=hclust,
        wts= dataframe$R2E_order,
        agglo.FUN = "mean" #note that package vegan needs to be loaded
        )

#reordered_object <- dendextend::rotate(hclust, dataframe$R2E_order)

reorder <- reordered_object$order

dataframe$original_reorded <- reorder

for (i in seq(1:nrow(dataframe))) {
  dataframe$R2EHCT_order[i] <- which(reorder == dataframe$original_order[i])
} 


Heatmap(sample_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(sample_correlation_matrix)[hclust_order],
        column_order =  rownames(sample_correlation_matrix)[hclust_order],
        na_col = "white", col = rev(brewer.pal(11,"RdBu"))
        )


Heatmap(sample_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = F, 
        #row_order = rownames(sample_correlation_matrix)[reorder],
        row_order = dataframe$gene[order(dataframe$R2E_order)],
        column_order = dataframe$gene[order(dataframe$R2E_order)],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))

Heatmap(sample_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = as.dendrogram(reordered_object), 
        #row_order = rownames(sample_correlation_matrix)[reorder],
        #row_order = dataframe$gene[order(dataframe$R2EHCT_order)],
        column_order= dataframe$gene[order(dataframe$R2EHCT_order)],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```

```{r, fig.width=10, fig.height=10}
# calculate correlation betwwen samples

# Users should always use circlize::colorRamp2() function to generate the color mapping function
#col_fun = colorRamp2(c(-1, 0, 1), brewer.pal(9,"BuPu")[c(1,5,9)])

color_categorical_segment <- c("skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "orchid",
                               "skyblue2", "indianred", "goldenrod1", "orchid",
                               "skyblue2", "skyblue2", "skyblue2", "dodgerblue", "indianred", "indianred", "magenta", "magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "goldenrod1","goldenrod1", "magenta","magenta", "orchid",
                               "skyblue2", "dodgerblue", "goldenrod2", "goldenrod1", "magenta", "magenta", "orchid", "orchid")
names(color_categorical_segment) <- paste0(unique(merged_metadata$segment), "_mean")
color_categorical_segment_named <- color_categorical_segment


colAnn <- HeatmapAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            which = 'col',
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                            #annotation_width = unit(c(1, 4), 'cm'),
                            #gap = unit(1, 'mm')
                            show_legend = FALSE,
                            show_annotation_name = FALSE
                            )

rowAnn <- rowAnnotation(df = data.frame(segment = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to mutch the name of the named list
                            col = list("segment" = color_categorical_segment_named), #set the name of the named list so it matches
                        show_legend = FALSE,
                        show_annotation_name = FALSE
                            )



#### samples


rightAnn <- rowAnnotation(df = data.frame(Ao = paste0(unique(merged_metadata$segment), "_mean"),
                                          Bf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pf = paste0(unique(merged_metadata$segment), "_mean"),
                                          Sp = paste0(unique(merged_metadata$segment), "_mean"),
                                          Pd = paste0(unique(merged_metadata$segment), "_mean")), #the name of the column needs to match the name of the named list
                   
                            
                            col = list("Ao" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=1, to=6)))], "white"),
                                       "Bf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=7, to=10)))], "white"),
                                       "Pf" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=11, to=19)))], "white"),
                                       "Sp" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=20, to=28)))], "white"),
                                       "Pd" = replace(color_categorical_segment_named,seq(1,36)[!(seq(1,36) %in% (seq(from=29, to=36)))], "white")), #set the name of the named list so it matches
                   simple_anno_size = unit(0.6, "cm"),
                   empty2 = anno_empty(border = FALSE, width= unit(4, "mm")),
                   show_legend = FALSE
                   
                   )














Heatmap(mat = sample_correlation_matrix,
        name= "Pearson rho",
        column_title = gt_render(paste0("<span style='color:darkorchid4'>**Spearman's ", expression(ρ), "**</span> correlation coeff. <br/> between samples <span style='color:gray60'>(on most variable genes)</span>")),
        #col = brewer.pal(9,"BuPu"),
        col = colorRamp2(c(-1, 0, 1), rev(brewer.pal(9,"RdGy")[c(1,5,9)])),
        #col = colorRamp2(c(-1, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col = brewer.pal(9,"PiYG"),
        #col =  colorRamp2(c(-0.5, 0, 1), brewer.pal(9,"PiYG")[c(1,5,9)]),
        #col = 
        na_col = "black",
        cluster_rows = as.dendrogram(reordered_object),
        show_row_dend = T,
        #row_order = ordered_levels,
        cluster_columns = as.dendrogram(reordered_object),
        show_column_dend = T,
       #row_order = dataframe$gene[order(dataframe$R2EHCT_order)],
      #  column_order= dataframe$gene[order(dataframe$R2EHCT_order)],
        #column_order = ordered_levels,
        #row_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        #column_split = factor(paste0(unique(sample_metadata$segment), "_mean"), levels = paste0(unique(sample_metadata$segment), "_mean")),
        cluster_row_slices = FALSE,
        cluster_column_slices = FALSE,
        row_title = NULL,
        row_gap = unit(0.5, "mm"),
        column_gap = unit(0.5, "mm"),
        width = unit(12, "cm"), 
        height = unit(12, "cm"),
        column_names_gp = grid::gpar(fontsize = 8),
        row_names_gp = grid::gpar(fontsize = 8),
        top_annotation = colAnn,
        left_annotation = rowAnn,
        right_annotation = rightAnn,
        show_heatmap_legend = T
        )

```

```{r}
#define row proximity matrix R (genes)
gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="spearman"))
Heatmap(gene_correlation_matrix)
```

```{r}
#test R2E seriation, beginning with R the column/sample similarity matrix
#manually (original paper )

gene_correlation_matrix <- as.matrix(cor(t(counts_VST_selectedgenes),method="pearson"))
#Heatmap(gene_correlation_matrix, 
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(gene_correlation_matrix)$u[, 1], svd(gene_correlation_matrix)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R1 <- as.matrix(cor(gene_correlation_matrix,method="pearson"))
#Heatmap(R1,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R1)$u[, 1], svd(R1)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R2 <- as.matrix(cor(R1,method="pearson"))
#Heatmap(R2,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R2)$u[, 1], svd(R2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R3 <- as.matrix(cor(R2,method="pearson"))
#Heatmap(R3,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R3)$u[, 1], svd(R3)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R4 <- as.matrix(cor(R3,method="pearson"))
#Heatmap(R4,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R4)$u[, 1], svd(R4)$u[, 2], xlab = "U1", ylab = "U2", pch=19)


R5 <- as.matrix(cor(R4,method="pearson"))
#Heatmap(R5,
#        cluster_rows = T,
#        cluster_columns = T)
plot(svd(R5)$u[, 1], svd(R5)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

R6 <- as.matrix(cor(R5,method="pearson"))
Heatmap(R6,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R6)$u[, 1], svd(R6)$u[, 2], xlab = "U1", ylab = "U2", pch=19)



#in the original publication, rank is indicated as the number of eigenvalues > e-13
length(svd(gene_correlation_matrix)$d[svd(gene_correlation_matrix)$d >= exp(-13)])
length(svd(R1)$d[svd(R1)$d >= exp(-13)])
length(svd(R2)$d[svd(R2)$d >= exp(-13)])
length(svd(R3)$d[svd(R3)$d >= exp(-13)])
length(svd(R4)$d[svd(R4)$d >= exp(-13)])
length(svd(R5)$d[svd(R5)$d >= exp(-13)])
length(svd(R6)$d[svd(R6)$d >= exp(-13)])

#finally, plot the sum of squares of eigenvalues
df_sos <- data.frame(sum_of_squares = c(sum((svd(gene_correlation_matrix)$d)^2),
                sum((svd(R1)$d)^2),
                sum((svd(R2)$d)^2),
                sum((svd(R3)$d)^2),
                sum((svd(R4)$d)^2),
                sum((svd(R5)$d)^2),
                sum((svd(R6)$d)^2)
                )
)
df_sos$R <- c(0,seq(from=1, to=(nrow(df_sos)-1)))
df_sos

plot(df_sos$R, df_sos$sum_of_squares)
```
```{r}
#identify the first rank 2 matrix (R4 in this case)
R_r2 <- R5
#R_r2 <- as.matrix(cor(R_r2,method="pearson"))
Heatmap(R_r2,
        cluster_rows = T,
        cluster_columns = T)
plot(svd(R_r2)$u[, 1], svd(R_r2)$u[, 2], xlab = "U1", ylab = "U2", pch=19)

#the two axis of the 2D ellipse, given a matrix with rank2, with two eigenvalues, is sqrt(1/eigenvalue1) and srqt(1/eigenvalue2)
#svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
#1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)]
sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])


PC1PC2_df <- data.frame(U1= svd(R_r2)$u[, 1], U2=svd(R_r2)$u[, 2])

ggplot(PC1PC2_df, aes(x=U1, y=U2))+
   ggforce::geom_ellipse(aes(x0 = 0, y0 = 0, 
                            a = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[1], 
                            b = sqrt(1/svd(R_r2)$d[svd(R_r2)$d >= exp(-13)])[2], 
                            angle = 0),
                        color = "gray")+
   geom_point()+
  theme_bw()+
  theme(legend.position = "null")


#find the biggest cut
angle <- function(x,y){
  atan2(y[2],y[1]) - atan2(x[2],x[1])
}

for (i in seq(from=1, to=(nrow(PC1PC2_df)))) {
  x <- c(PC1PC2_df$U1[i],PC1PC2_df$U2[i])
  y <- c(1,0)
  PC1PC2_df$angle[i] <- angle(x, y)
}

tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = T),]  
tmp #this will be ordered counterclocwise

#tmp <- PC1PC2_df[order(PC1PC2_df$angle, decreasing = F),]  
#tmp #this will be ordered clocwise


cuts <-  as.vector(tmp$angle[1:(length(tmp$angle)-1)])-as.vector(tmp$angle[2:length(tmp$angle)])
cuts <- c(cuts, tmp$angle[length(tmp$angle)]+tmp$angle[1])
cuts

plot_ly(data = tmp, 
        x = ~U1, y = ~U2, 
        #color = ~segment, 
        #symbol = ~species,
        #colors = c("chocolate1", "green3", "pink","orchid", "skyblue"),
        #colors = color_categorical_all,
        #colors = c("indianred1", "dodgerblue", "dodgerblue"),
        #colors = colorRampPalette(brewer.pal(name = "RdBu", n = 9))(13),
        type = "scatter", 
        mode = "markers", 
        marker = list(size = 2, width=2), # controls size of points
        text=~seq(1:nrow(tmp)), #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
#cut_index <- which(abs(cuts) == sort(abs(cuts), decreasing = T)[2])
```



```{r}
cut_index <- 49

ifelse(cut_index == nrow(tmp), 
       tmp2_genes <- tmp,
       tmp2_genes <- rbind(tmp[(cut_index+1):nrow(tmp),], tmp[1:cut_index,])
       )

tmp2_genes
#as.numeric(rownames(tmp2_genes))
```

```{r}
htR2E_genes <- Heatmap(gene_correlation_matrix,
        cluster_rows = F,
        cluster_columns = F,
        row_order =  rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))])
htR2E_genes <- draw(htR2E_genes)


dataframe <- data.frame(gene = rownames(gene_correlation_matrix), original_order = seq(1:nrow(gene_correlation_matrix)))

seriation_order <- row_order(htR2E_genes)

dataframe$original_seriation_order <- seriation_order

for (i in seq(1:nrow(dataframe))) {
  dataframe$R2E_order[i] <- which(seriation_order == dataframe$original_order[i])
}  


```



```{r, fig.height=10, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
        cluster_rows = F,
        cluster_columns = F,
        
        #FOR R2E:
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"RdGy")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes))),
               width=3,
               #FOR R2E_HCT
        cluster_rows = as.dendrogram(reordered_object),
        cluster_columns = as.dendrogram(reordered_object),
        #FOR R2E
        #row_order = rownames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2_genes))],
        #column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )


ht_list = ht1 + ht2
draw(ht_list)
```

```{r, fig.width=10, fig.height=7}
hclust <- hclust(dist(gene_correlation_matrix), method = "ward.D2")
hclust_order <- hclust$order

reordered_object_genes <- stats::reorder(x=hclust,
        wts= dataframe$R2E_order,
        agglo.FUN = "mean" #note that package vegan needs to be loaded
        )

#reordered_object_genes <- dendextend::rotate(hclust, dataframe$R2E_order)

reorder <- reordered_object_genes$order

dataframe$original_reorded <- reorder

for (i in seq(1:nrow(dataframe))) {
  dataframe$R2EHCT_order[i] <- which(reorder == dataframe$original_order[i])
} 


Heatmap(gene_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = F, 
        row_order = rownames(gene_correlation_matrix)[hclust_order],
        column_order =  rownames(gene_correlation_matrix)[hclust_order],
        na_col = "white", col = rev(brewer.pal(11,"RdBu"))
        )


Heatmap(gene_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = F, 
        #row_order = rownames(gene_correlation_matrix)[reorder],
        row_order = dataframe$gene[order(dataframe$R2E_order)],
        column_order = dataframe$gene[order(dataframe$R2E_order)],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))

Heatmap(gene_correlation_matrix, 
        cluster_columns = F, 
        cluster_rows = as.dendrogram(reordered_object_genes), 
        #row_order = rownames(gene_correlation_matrix)[reorder],
        #row_order = dataframe$gene[order(dataframe$R2EHCT_order)],
        column_order= dataframe$gene[order(dataframe$R2EHCT_order)],
        na_col = "white", col = rev(brewer.pal(11,"RdBu")))
```

```{r, fig.height=10, fig.width=20}

#we can now plot the three matrices
ht1 <- Heatmap(gene_correlation_matrix,
               width=3,
               #FOR R2E_HCT
        cluster_rows = as.dendrogram(reordered_object_genes),
        cluster_columns = as.dendrogram(reordered_object_genes),
        #cluster_rows = T,
        
        row_order = rownames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        
        #column_order = colnames(gene_correlation_matrix)[as.numeric(rownames(tmp2_genes))],
        col = rev(brewer.pal(9,"RdGy")),
        use_raster = TRUE)


ht2 <- Heatmap(t(scale(t(counts_VST_selectedgenes))),
               width=3,
               #FOR R2E_HCT
        #cluster_rows = as.dendrogram(reordered_object),
        #cluster_columns = as.dendrogram(reordered_object),
        #cluster_columns = T,
        row_order = rownames(counts_VST_selectedgenes)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )

ht_list = ht1 + ht2
draw(ht_list)
```
```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/TF_APassociated_GAP.pdf")
draw(ht_list)
dev.off()
```
```{r, fig.height= 15, fig.width= 10}
load("Z://01_Stefano/Collaboration_Data/Annotations/dictionary_orthogroups_best_withHox_genebased.rds")


counts_VST_selectedgenes_named <- counts_VST_selectedgenes
rownames(counts_VST_selectedgenes_named) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes_named) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes_named) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes_named) ,annotation_info_Ao$entrez_ID)] 


ht <- Heatmap(t(scale(t(counts_VST_selectedgenes_named))),
               width=3,
              cluster_rows = as.dendrogram(reordered_object_genes),
              #cluster_columns = as.dendrogram(reordered_object),
        #cluster_rows = F,
        #cluster_columns = F,
        #row_order = rownames(counts_VST_selectedgenes_named)[as.numeric(rownames(tmp2_genes))],
        column_order = colnames(sample_correlation_matrix)[as.numeric(rownames(tmp_genes))],
        col = rev(brewer.pal(11,"RdBu")),
        use_raster = TRUE
        
        )

dht <- draw(ht)

```


```{r}
summary_dataframe <- data.frame(geneID = NA, symbol = NA, orthogroup = NA, description = rownames(counts_VST_selectedgenes_named)[row_order(dht)])

summary_dataframe$geneID <- annotation_info_Ao$entrez_ID[match(summary_dataframe$description ,annotation_info_Ao$merged_description)] 

summary_dataframe$symbol <- annotation_info_Ao$merged_symbol[match(summary_dataframe$geneID ,annotation_info_Ao$entrez_ID)]

summary_dataframe$orthogroup <- rownames(dictionary_orthogroups_best_withHox_genebased)[match(summary_dataframe$geneID ,dictionary_orthogroups_best_withHox_genebased$Ao)]

#save(summary_dataframe, file="Z://01_Stefano/Collaboration_Data/85TF_conserved_subset.rds")
#write.csv(summary_dataframe, file="Z://01_Stefano/Collaboration_Data/85TF_conserved_subset.csv")
```




























