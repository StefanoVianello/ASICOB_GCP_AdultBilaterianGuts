---
title: "R Notebook"
output: html_notebook
---
```{r}
library(readxl)
library(magrittr)
library(tidyr)
library(dplyr)
library(ComplexHeatmap)
library(RColorBrewer)
```


```{r}

#load orthofinder results (from ChingYi)


#Ao
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Ao_TF_ID.xlsx") 
TFs_Ao <- unlist(hmsearch_TFs[1]) #2408 proteins
dictionary_orthogroups <- read.table(file = "Z://01_Stefano/Collaboration_Data/Annotations/Results_Nov01/Orthogroups/Orthogroups.tsv", sep = '\t', header = TRUE)
dictionary_orthogroups <- dictionary_orthogroups %>% separate_rows("Ao", sep = ", ")
dictionary_orthogroups <- dictionary_orthogroups %>% mutate_all(na_if,"")
orthogroups_Ao <- unique(dictionary_orthogroups$Orthogroup[match(TFs_Ao,dictionary_orthogroups$Ao)])
orthogroups_Ao <- na.omit(orthogroups_Ao) #834 OGs

#Bf
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Bf_TF_ID.xlsx") 
TFs_Bf <- unlist(hmsearch_TFs[1]) #2209 proteins
dictionary_orthogroups <- read.table(file = "Z://01_Stefano/Collaboration_Data/Annotations/Results_Nov01/Orthogroups/Orthogroups.tsv", sep = '\t', header = TRUE)
dictionary_orthogroups <- dictionary_orthogroups %>% separate_rows("Bf", sep = ", ")
dictionary_orthogroups <- dictionary_orthogroups %>% mutate_all(na_if,"")
orthogroups_Bf <- unique(dictionary_orthogroups$Orthogroup[match(TFs_Bf,dictionary_orthogroups$Bf)])
orthogroups_Bf <- na.omit(orthogroups_Bf) #660 OGs

#Pf
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Pf_TF_ID.xlsx") 
TFs_Pf <- unlist(hmsearch_TFs[1]) #2408 proteins
dictionary_orthogroups <- read.table(file = "Z://01_Stefano/Collaboration_Data/Annotations/Results_Nov01/Orthogroups/Orthogroups.tsv", sep = '\t', header = TRUE)
dictionary_orthogroups <- dictionary_orthogroups %>% separate_rows("Pf", sep = ", ")
dictionary_orthogroups <- dictionary_orthogroups %>% mutate_all(na_if,"")
orthogroups_Pf <- unique(dictionary_orthogroups$Orthogroup[match(TFs_Pf,dictionary_orthogroups$Pf)])
orthogroups_Pf <- na.omit(orthogroups_Pf) #671 OGs

#Sp
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Sp_TF_ID.xlsx") 
TFs_Sp <- unlist(hmsearch_TFs[1]) #2408 proteins
dictionary_orthogroups <- read.table(file = "Z://01_Stefano/Collaboration_Data/Annotations/Results_Nov01/Orthogroups/Orthogroups.tsv", sep = '\t', header = TRUE)
dictionary_orthogroups <- dictionary_orthogroups %>% separate_rows("Sp", sep = ", ")
dictionary_orthogroups <- dictionary_orthogroups %>% mutate_all(na_if,"")
orthogroups_Sp <- unique(dictionary_orthogroups$Orthogroup[match(TFs_Sp,gsub("\\..*","",dictionary_orthogroups$Sp))])
orthogroups_Sp <- na.omit(orthogroups_Sp) #587 OGs

#Pd
hmsearch_TFs <- read_excel("Z://01_Stefano/Collaboration_Data/Annotations/TFs/Pd_TF_ID.xlsx") 
TFs_Pd <- unlist(hmsearch_TFs[1]) #2408 proteins
dictionary_orthogroups <- read.table(file = "Z://01_Stefano/Collaboration_Data/Annotations/Results_Nov01/Orthogroups/Orthogroups.tsv", sep = '\t', header = TRUE)
dictionary_orthogroups <- dictionary_orthogroups %>% separate_rows("Pd", sep = ", ")
dictionary_orthogroups <- dictionary_orthogroups %>% mutate_all(na_if,"")
orthogroups_Pd<- unique(dictionary_orthogroups$Orthogroup[match(TFs_Pd,gsub("\\..*","",dictionary_orthogroups$Pd))])
orthogroups_Pd <- na.omit(orthogroups_Pd) #626 OGs


#find shared orthogroups
orthogroup_TFs <- Reduce(intersect, list(orthogroups_Ao,orthogroups_Bf,orthogroups_Pd,orthogroups_Pf,orthogroups_Sp)) #311 OGs

orthogroup_TFs <- unique(c(orthogroup_TFs, c("OG000PG01", "OG000PG02", "OG000PG0304", "OG000PG05","OG000PG0607", "OG000PG08", "OG000PG0910", "OG000PG1115"))) #319
```


## Module 1/foregut
```{r, echo=FALSE}
#BiocManager::install("mixOmics")
library(mixOmics)
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/merged_metadata.rds") #merged_metadata
load("Z://01_Stefano/Collaboration_Data/Annotations/zmerged_counts.rds") #zmerged_counts #5839


#### AVERAGE OR NOT? (comment/uncomment)
merged_counts_averaged <- data.frame(matrix(nrow=nrow(zmerged_counts),ncol=0))
group_indeces <- c(0, cumsum(unname( table(merged_metadata$segment))))
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- zmerged_counts[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  merged_counts_averaged <- cbind(merged_counts_averaged, tmp_averages)
  
}
colnames(merged_counts_averaged) <- paste0(unique(merged_metadata$segment), "_mean")
merged_counts <- merged_counts_averaged

merged_metadata_averaged <- merged_metadata
merged_metadata_averaged <- merged_metadata_averaged[!duplicated(merged_metadata_averaged$segment),]
rownames(merged_metadata_averaged) <- paste0(merged_metadata_averaged$segment, "_mean")
merged_metadata <- merged_metadata_averaged
###



# generate basic MINT pls-da model
#in mixOmics
# X = counts matrix (rows: samples, columns, genes)
# Y = vector of classes (1 per sample)
#study <- vector of different studies to be batch integrated

counts_VST_transposed <- t(merged_counts)
X <- counts_VST_transposed
#Y <- merged_metadata$segment

#what if I force similarity


#hindgut segments (expanded) in averaged dataset
Y <-  c(rep("not-module1", 1), rep("module1", 2), rep("not-module1", 4), #Ao tot7
        rep("not-module1", 1),rep("module1", 1), rep("not-module1", 3), #Bf tot5
        rep("not-module1", 2),rep("module1", 4), rep("not-module1", 5), #Pf tot11
        rep("module1", 2), rep("not-module1", 7), #Sp tot9
        rep("not-module1", 2),rep("module1", 2), rep("not-module1", 6) #Pd tot10
)
        
        


#hindgut segments (strict) in averaged dataset
#Y <-  c(rep("not-hindgut", 6), rep("hindgut", 1), #Ao
#         rep("not-hindgut", 4), rep("hindgut", 1), #Bf
#         rep("not-hindgut", 9),  rep("hindgut", 2), #Pf
#         rep("not-hindgut", 7), rep("hindgut", 2), #Sp
#         rep("not-hindgut", 9), rep("hindgut", 1)) #Pd


study <- merged_metadata$species


basic.splsda.model <- mint.splsda(X, Y, study = study, ncomp = 10) 
#basic.pls.model <- mint.pls(X, Y, study = study, ncomp = 2) 

# plot the samples
plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: module 1 vs others ', ellipse = TRUE,
          col = c("dodgerblue", "gray")) 
```

```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/MINTsPLS_module1_PCA.pdf")

plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: module 1 vs others ', ellipse = TRUE,
          col = c("dodgerblue", "gray")) 

dev.off()
```


```{r, fig.height=12, fig.width=12}
plotIndiv(basic.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```


```{r}
plotIndiv(basic.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 2:3, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 3:4, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 4:5, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 5:6, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 6:7, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(basic.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(basic.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(basic.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```

```{r, echo=FALSE}
#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:10]
#selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species.rds") #shared_TFs_8species [356]
orthogroup_TFs <- shared_TFs_8species

summary(selected_genes %in% orthogroup_TFs)
selected_genes[selected_genes %in% orthogroup_TFs == T]
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")

dictionary_orthogroups_best_withHox_genebased["OG0006718",]
```


```{r, fig.height=6, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


colors <- list(segment = c("gray90", "dodgerblue"))
names(colors[[1]]) <- unique(Y)

colAnn <- HeatmapAnnotation(segment = as.factor(Y),
                            col = colors,
                            show_legend = F,
                            show_annotation_name = F)
htmp <- Heatmap(as.matrix(counts_VST_selectedgenes),
                name= "z-score (within-species)",
                cluster_columns = F,
                column_split = factor(merged_metadata$species, levels = c("Pd", "Sp", "Pf", "Bf", "Ao")),
                column_gap = rep(unit(5, "mm"),4),
                col = rev(brewer.pal(11,"RdBu")),
                top_annotation = colAnn,
                heatmap_legend_param = list(legend_direction = "horizontal", 
                                            legend_width = unit(6, "cm")
                                            )
                )
draw(htmp, 
     heatmap_legend_side="bottom",
     #annotation_legend_side="right",
     #legend_grouping = "original",
     padding = unit(c(2, 2, 2, 100), "mm")
     )
```

```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/MINTsPLS_module1_heatmap_Top10.pdf")

draw(htmp, 
     heatmap_legend_side="bottom"
     ) 

dev.off()
```



#### enrichment


```{r}
#replace with best gene  representative
ordered_genes <-dictionary_orthogroups_best_withHox_genebased$Ao[match(selected_genes,rownames(dictionary_orthogroups_best_withHox_genebased))]
```

```{r}
#we will need to convert to ensembl
ordered_genes_Ensembl <- annotation_info_Ao$ensembl_ID[match(ordered_genes,annotation_info_Ao$entrez_ID)]
```

```{r}
ordered_genes_Ensembl <- na.omit(ordered_genes_Ensembl) #48
```


```{r}
# uncomment if not run this earlier in the code and object "ensembl" does not exist
require(biomaRt)
ensembl <- useMart('ensembl', dataset = 'aocellaris_gene_ensembl')
#tab_GO
GO_annotations <- getBM(attributes = c("ensembl_gene_id", 'namespace_1003', "go_id", "name_1006"),
                        mart = ensembl)
#only keep genes annotated for Biological Process GO terms
GO_annotations <- subset(GO_annotations, (namespace_1003 %in% "biological_process"))

#let us also add a column with the descriptions from our annotation_info file
GO_annotations$description <- annotation_info$merged_description[match(GO_annotations$ensembl_gene_id, annotation_info$ensembl_ID)]
```

```{r, fig.width=8, fig.height=8, echo=FALSE}
#but try also clusterprofiler
#Groups of genes identified by some analyses are used as input list to the mgsa function from the mgsa package13
#(with parameters restarts=3 and steps=1e7).

#The model assumes that some sets to be inferred are active and that all genes member of active sets are themselves active. Active genes are more likely to belong to the observations and inactive genes not. Fitting the model amounts to infer the probability of every set to be active given the observations.
#Classical methods analyze each set in isolation. Because sets such as biological pathways often share genes with each other, the returned list of enriched sets is usually long and redundant. In contrast, MGSA takes set overlap into account by working on all sets simultaneously and substantially reduces the number of redundant sets.

#e.g. take list of DE genes S1/S2 [== example_o]
# take list of GO terms (obtained previously) [== example_go]
#myset = new( "MgsaSets", sets=list(set1=LETTERS[1:3], set2=LETTERS[2:5]) )


#prepare table where each column is a GO:pathwayID and entries are the genes that belong to that group
GO_annotations_wide <- GO_annotations[, c("ensembl_gene_id", "go_id")]
GO_annotations_wide$id <- seq.int(nrow(GO_annotations_wide))
GO_annotations_wide <- GO_annotations_wide %>% pivot_wider(names_from = go_id, values_from = ensembl_gene_id)

#only keep GO groups with at least 4 genes and max 500
GO_annotations_wide <- GO_annotations_wide %>% select_if(~ sum(!is.na(.)) > 4 & sum(!is.na(.)) < 500)

#replace GO codes with full names so the results are easier to interpret
tmp <- GO_annotations[, c("name_1006", "go_id")]
tmp <- tmp[!duplicated(tmp),]

colnames(GO_annotations_wide) <- tmp$name_1006[tmp$go_id %in% colnames(GO_annotations_wide)]
rm(tmp)


```


```{r}
#run the mgsa function
MGSA_result = mgsa(ordered_genes_Ensembl, #this is a list of genes previously obtained during the DE analysis
                   #should maybe just take upregulated in one stage  and upregulated in the other, separatedly
                   GO_annotations_wide, 
                   restarts=5,  
                   steps=1e7)

#show the ordered list of gene sets found
setsResults(MGSA_result)[order(setsResults(MGSA_result)$estimate, decreasing = TRUE),][1:25,]
#plot(MGSA_result)

#The model have three parameters:
# α, the false positive rate i.e. the probability of an inactive gene to actually be observed;
# β, the false negative rate i.e. the probability of an active gene to actually be not observed;
# p, the prior probability for any set to be active, a typically small number ensuring sparse solutions to be inferred

#res = setsResults(MGSA_result)
#subset(res, estimate > 0.5)
```

<br/> Below, for reference, the scoring of all Gene Ontology gene sets considered, and the hyperparameters of the model ( _alpha_ , _beta_, and indirectly _p_ ):

```{r, echo=FALSE, fig.width=9, fig.height=9, warning=FALSE}
#for customisation purposes, let us try to obtain the same plots as plot(MGSA_result)

#set space for 4 plots
par(mfrow=c(2,2))

##p, alpha, beta hyperparameters of the model
## Note this is the information that would be extracted from the original bottom 3 plots

# average number of gene sets expected to be active: p* number of gene sets considered
pPost <- (pPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value)*dim(MGSA_result@setsResults)[1]
# most likely alpha parameter of the model (false positive)
pAlpha <- alphaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value
# most likely beta parameter of the model (false negative rate)
pBeta <- betaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value

title <- paste0("MGSA analysis: \n \n expected active gene sets: ",pPost,"\n alpha (false positives): ", pAlpha, "\n beta (false negatives): ",pBeta)

# TEXT
plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, title , cex=1.2)

## DOTPLOT

tmp <- data.frame(go_id = colnames(GO_annotations_wide), estimate =MGSA_result@setsResults[["estimate"]])
# sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10] #returns the index of the top 10 scoring sets

plot(seq(1:dim(tmp)[1]),
     tmp$estimate,
     xlab="",
     ylab="Posterior Probability of activation",
     #ylim=c(0,3.6),
     xaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(seq(1:dim(tmp)[1]) %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 0.3))
     )
axis(1, sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10],las=2, cex.axis=0.5, font=2, labels = colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]])
title("Posterior probabilities of activation")
abline(h=0.5,col="grey")
#text(sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], tmp$estimate[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]]-0.04, labels=colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]], cex=0.7)

#DENSITY PLOT

plot(density(tmp$estimate),
     col= "dodgerblue",
     lwd= 2,
     main="",
     xlab="Posterior probability of activation",
     ylab="Number of GO sets \n with given probability",
     #ylim=range(pretty(c(0, 1)))
     )
abline(v=0.5,col="grey")
title("Distribution of posterior activation probabilities")

#BARPLOT

sorted_tmp <- tmp
sorted_tmp$sd <- MGSA_result@setsResults[["std.error"]]
sorted_tmp$index <- seq(1:dim(sorted_tmp)[1])
sorted_tmp <- sorted_tmp[order(sorted_tmp$estimate, decreasing = TRUE),]
#sorted_tmp <- as.data.frame(sort(sorted_tmp$estimate, index.return=TRUE, decreasing=TRUE))
sorted_tmp$rank <- seq(1:dim(sorted_tmp)[1])
#colnames(sorted_tmp) <- c("estimate", "index", "rank")

plot(sorted_tmp[1:20,]$estimate,
     sorted_tmp[1:20,]$rank,
     xlab="Posterior Probability of activation \n +/- Standard Error",
     ylab="",
     #ylim=c(1,20),
     ylim = rev(range(sorted_tmp[1:20,]$rank)), #so that higher ranks (lower positions) are at the bottom
     yaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(sorted_tmp$index %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 1))
     )
axis(2, sorted_tmp[1:20,]$rank,las=2, 
     cex.axis=0.5, 
     font=2, 
     labels = colnames(GO_annotations_wide)[sorted_tmp[1:20,]$index])
title("Posterior probabilities of activation")
# Add error bars
#https://www.benjaminbell.co.uk/2019/04/how-to-add-error-bars-in-r.html
arrows(x0=sorted_tmp[1:20,]$estimate - sorted_tmp[1:20,]$sd, 
       y0=sorted_tmp[1:20,]$rank, 
       x1=sorted_tmp[1:20,]$estimate+ sorted_tmp[1:20,]$sd, 
       y1=sorted_tmp[1:20,]$rank, 
       code=3, 
       angle=90, 
       length=0.1,
       col = "gray")

```

<br/> For the top scoring pathways, below the list of the actual genes belonging to that pathway that were found in our list of differentially-expressed genes:


```{r, echo=FALSE}
#for the top pathways, print the genes that have been found amongst DE
#sorted_tmp[1:5,1] #is the colnames of GO-annotation_wide we have to extract gene codes from

#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) #find which of all pathways genes are actually those found amongst DE genes
  #print(top_table[top_table$ensembl_gene_id %in% expressed, c("FC", "adj.P.Val", "ensembl_gene_id", "description", "AveExpr", "CI.L", "CI.R")])
  print(kable(annotation_info_Ao[annotation_info_Ao$ensembl_ID %in% expressed, c("entrez_ID", "ensembl_ID", "merged_symbol", "merged_description") ], 
              caption= paste0("Genes of GO set:[",sorted_tmp[i,1],"] present amonst genes of interest")))
  
}
     
```
```{r,fig.width=10, fig.height=10}





#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) 
  
  expressed <- annotation_info_Ao$entrez_ID[match(expressed,annotation_info_Ao$ensembl_ID)]
expressed_OG <- rownames(dictionary_orthogroups_best_withHox_genebased[match(expressed,dictionary_orthogroups_best_withHox_genebased$Ao),])

#counts_VST_tmp <- counts_VST_selectedgenes[rownames(counts_VST_selectedgenes) %in% expressed_OG,]

counts_VST_tmp <- zmerged_counts_all[rownames(zmerged_counts_all) %in% expressed_OG,]



rownames(counts_VST_tmp) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_tmp) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
rownames(counts_VST_tmp) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_tmp) ,annotation_info_Ao$entrez_ID)] 



htmp <- Heatmap(as.matrix(counts_VST_tmp),
                column_title = paste0("GO set:[",sorted_tmp[i,1],"]"),
        cluster_columns = F,
        column_split = merged_metadata_all$species,
        col = rev(brewer.pal(11,"RdBu"))
        )

plot(htmp)
  
  
}


```



### continue



```{r}
splsda.perf <- perf(basic.splsda.model) # undergo performance optimisation
plot(splsda.perf)
```
```{r}
splsda.perf$choice.ncomp
```

```{r}
# note that usually a call in the below line would be more appropriate:
optimal.ncomp <- splsda.perf$choice.ncomp["overall", "centroids.dist"]

#overwrite
optimal.ncomp <- 2
```


```{r}
splsda.tune <- tune(X = X, Y = Y, study = study,  # tune the number of features
                              ncomp = optimal.ncomp,# using optimal comp number
                              test.keepX = seq(1, 100, 1), 
                              method = 'mint.splsda', 
                              measure = 'BER', # balanced error rate
                              dist = "centroids.dist")
```

```{r}
plot(splsda.tune, sd = FALSE)

```


```{r}
optimal.keepX <- splsda.tune$choice.keepX # extract optimal values

optimal.keepX
```
```{r}
final.splsda.model <- mint.splsda(X = X, Y = Y, study = study, 
                                  ncomp = optimal.ncomp, 
                                  keepX = optimal.keepX)
```

```{r, fig.width=12, fig.height=12}
plotIndiv(final.splsda.model, study = 'global', 
          legend = TRUE,
          title = '(a) Stem cells, MINT sPLS-DA',
          subtitle = 'Global', ellipse = T)

plotIndiv(final.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```




```{r}
plotIndiv(final.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')




# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(final.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(final.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```


```{r}
#loading vectors
test <- as.data.frame(final.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```



```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp1 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")

dictionary_orthogroups_best_withHox_genebased["OG0004625",]
```


```{r, fig.height=10, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```

```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp2, decreasing = T), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp2 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```

```{r, fig.height=3, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```










## Hindgut
```{r, echo=FALSE}
#BiocManager::install("mixOmics")
library(mixOmics)
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/merged_metadata.rds") #merged_metadata
load("Z://01_Stefano/Collaboration_Data/Annotations/zmerged_counts.rds") #zmerged_counts #5839


#### AVERAGE OR NOT? (comment/uncomment)
merged_counts_averaged <- data.frame(matrix(nrow=nrow(zmerged_counts),ncol=0))
group_indeces <- c(0, cumsum(unname( table(merged_metadata$segment))))
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- zmerged_counts[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  merged_counts_averaged <- cbind(merged_counts_averaged, tmp_averages)
  
}
colnames(merged_counts_averaged) <- paste0(unique(merged_metadata$segment), "_mean")
merged_counts <- merged_counts_averaged

merged_metadata_averaged <- merged_metadata
merged_metadata_averaged <- merged_metadata_averaged[!duplicated(merged_metadata_averaged$segment),]
rownames(merged_metadata_averaged) <- paste0(merged_metadata_averaged$segment, "_mean")
merged_metadata <- merged_metadata_averaged
###



# generate basic MINT pls-da model
#in mixOmics
# X = counts matrix (rows: samples, columns, genes)
# Y = vector of classes (1 per sample)
#study <- vector of different studies to be batch integrated

counts_VST_transposed <- t(merged_counts)
X <- counts_VST_transposed
#Y <- merged_metadata$segment

#what if I force similarity


#hindgut segments (expanded) in averaged dataset
Y <-  c(rep("not-hindgut", 6), rep("hindgut", 1), #Ao tot7
        rep("not-hindgut", 4), rep("hindgut", 1), #Bf tot5
        rep("not-hindgut", 8), rep("hindgut", 3), #Pf tot11
        rep("not-hindgut", 6), rep("hindgut", 3), #Sp tot9
        rep("not-hindgut", 8), rep("hindgut", 2) #Pd tot10
)
        
        


#hindgut segments (strict) in averaged dataset
#Y <-  c(rep("not-hindgut", 6), rep("hindgut", 1), #Ao
#         rep("not-hindgut", 4), rep("hindgut", 1), #Bf
#         rep("not-hindgut", 9),  rep("hindgut", 2), #Pf
#         rep("not-hindgut", 7), rep("hindgut", 2), #Sp
#         rep("not-hindgut", 9), rep("hindgut", 1)) #Pd


study <- merged_metadata$species


basic.splsda.model <- mint.splsda(X, Y, study = study, ncomp = 10) 
#basic.pls.model <- mint.pls(X, Y, study = study, ncomp = 2) 

# plot the samples
plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: hindgut vs others ', ellipse = TRUE,
          col = c("orchid", "gray")) 
```

```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/MINTsPLS_hindgut_PCA.pdf")

plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: hindgut vs others ', ellipse = TRUE,
          col = c("orchid", "gray")) 

dev.off()
```


```{r, fig.height=12, fig.width=12}
plotIndiv(basic.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```


```{r}
plotIndiv(basic.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 2:3, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 3:4, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 4:5, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 5:6, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 6:7, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(basic.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(basic.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(basic.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```

```{r, echo=FALSE}
#plot these genes
test <- test[order(test$comp1, decreasing = T), ] 
selected_genes <- rownames(test)[1:10]
#selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species.rds") #shared_TFs_8species [356]
orthogroup_TFs <- shared_TFs_8species

summary(selected_genes %in% orthogroup_TFs)
selected_genes[selected_genes %in% orthogroup_TFs == T]
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")

dictionary_orthogroups_best_withHox_genebased["OG0003690",]
```


```{r, fig.height=6, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


colors <- list(segment = c("gray90", "orchid"))
names(colors[[1]]) <- unique(Y)

colAnn <- HeatmapAnnotation(segment = as.factor(Y),
                            col = colors,
                            show_legend = F,
                            show_annotation_name = F)
htmp <- Heatmap(as.matrix(counts_VST_selectedgenes),
                name= "z-score (within-species)",
                cluster_columns = F,
                column_split = factor(merged_metadata$species, levels = c("Pd", "Sp", "Pf", "Bf", "Ao")),
                column_gap = rep(unit(5, "mm"),4),
                col = rev(brewer.pal(11,"RdBu")),
                top_annotation = colAnn,
                heatmap_legend_param = list(legend_direction = "horizontal", 
                                            legend_width = unit(6, "cm")
                                            )
                )
draw(htmp, 
     heatmap_legend_side="bottom",
     #annotation_legend_side="right",
     #legend_grouping = "original",
     padding = unit(c(2, 2, 2, 100), "mm")
     )
```

```{r}
#pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/MINTsPLS_hindgut_heatmap.pdf")
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/MINTsPLS_hindgut_heatmap_10.pdf")

draw(htmp, 
     heatmap_legend_side="bottom"
     ) 

dev.off()
```



#### enrichment


```{r}
#replace with best gene  representative
ordered_genes <-dictionary_orthogroups_best_withHox_genebased$Ao[match(selected_genes,rownames(dictionary_orthogroups_best_withHox_genebased))]
```

```{r}
#we will need to convert to ensembl
ordered_genes_Ensembl <- annotation_info_Ao$ensembl_ID[match(ordered_genes,annotation_info_Ao$entrez_ID)]
```

```{r}
ordered_genes_Ensembl <- na.omit(ordered_genes_Ensembl) #48
```


```{r}
# uncomment if not run this earlier in the code and object "ensembl" does not exist
require(biomaRt)
ensembl <- useMart('ensembl', dataset = 'aocellaris_gene_ensembl')
#tab_GO
GO_annotations <- getBM(attributes = c("ensembl_gene_id", 'namespace_1003', "go_id", "name_1006"),
                        mart = ensembl)
#only keep genes annotated for Biological Process GO terms
GO_annotations <- subset(GO_annotations, (namespace_1003 %in% "biological_process"))

#let us also add a column with the descriptions from our annotation_info file
GO_annotations$description <- annotation_info$merged_description[match(GO_annotations$ensembl_gene_id, annotation_info$ensembl_ID)]
```

```{r, fig.width=8, fig.height=8, echo=FALSE}
#but try also clusterprofiler
#Groups of genes identified by some analyses are used as input list to the mgsa function from the mgsa package13
#(with parameters restarts=3 and steps=1e7).

#The model assumes that some sets to be inferred are active and that all genes member of active sets are themselves active. Active genes are more likely to belong to the observations and inactive genes not. Fitting the model amounts to infer the probability of every set to be active given the observations.
#Classical methods analyze each set in isolation. Because sets such as biological pathways often share genes with each other, the returned list of enriched sets is usually long and redundant. In contrast, MGSA takes set overlap into account by working on all sets simultaneously and substantially reduces the number of redundant sets.

#e.g. take list of DE genes S1/S2 [== example_o]
# take list of GO terms (obtained previously) [== example_go]
#myset = new( "MgsaSets", sets=list(set1=LETTERS[1:3], set2=LETTERS[2:5]) )


#prepare table where each column is a GO:pathwayID and entries are the genes that belong to that group
GO_annotations_wide <- GO_annotations[, c("ensembl_gene_id", "go_id")]
GO_annotations_wide$id <- seq.int(nrow(GO_annotations_wide))
GO_annotations_wide <- GO_annotations_wide %>% pivot_wider(names_from = go_id, values_from = ensembl_gene_id)

#only keep GO groups with at least 4 genes and max 500
GO_annotations_wide <- GO_annotations_wide %>% select_if(~ sum(!is.na(.)) > 4 & sum(!is.na(.)) < 500)

#replace GO codes with full names so the results are easier to interpret
tmp <- GO_annotations[, c("name_1006", "go_id")]
tmp <- tmp[!duplicated(tmp),]

colnames(GO_annotations_wide) <- tmp$name_1006[tmp$go_id %in% colnames(GO_annotations_wide)]
rm(tmp)


```


```{r}
#run the mgsa function
MGSA_result = mgsa(ordered_genes_Ensembl, #this is a list of genes previously obtained during the DE analysis
                   #should maybe just take upregulated in one stage  and upregulated in the other, separatedly
                   GO_annotations_wide, 
                   restarts=5,  
                   steps=1e7)

#show the ordered list of gene sets found
setsResults(MGSA_result)[order(setsResults(MGSA_result)$estimate, decreasing = TRUE),][1:25,]
#plot(MGSA_result)

#The model have three parameters:
# α, the false positive rate i.e. the probability of an inactive gene to actually be observed;
# β, the false negative rate i.e. the probability of an active gene to actually be not observed;
# p, the prior probability for any set to be active, a typically small number ensuring sparse solutions to be inferred

#res = setsResults(MGSA_result)
#subset(res, estimate > 0.5)
```

<br/> Below, for reference, the scoring of all Gene Ontology gene sets considered, and the hyperparameters of the model ( _alpha_ , _beta_, and indirectly _p_ ):

```{r, echo=FALSE, fig.width=9, fig.height=9, warning=FALSE}
#for customisation purposes, let us try to obtain the same plots as plot(MGSA_result)

#set space for 4 plots
par(mfrow=c(2,2))

##p, alpha, beta hyperparameters of the model
## Note this is the information that would be extracted from the original bottom 3 plots

# average number of gene sets expected to be active: p* number of gene sets considered
pPost <- (pPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value)*dim(MGSA_result@setsResults)[1]
# most likely alpha parameter of the model (false positive)
pAlpha <- alphaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value
# most likely beta parameter of the model (false negative rate)
pBeta <- betaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value

title <- paste0("MGSA analysis: \n \n expected active gene sets: ",pPost,"\n alpha (false positives): ", pAlpha, "\n beta (false negatives): ",pBeta)

# TEXT
plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, title , cex=1.2)

## DOTPLOT

tmp <- data.frame(go_id = colnames(GO_annotations_wide), estimate =MGSA_result@setsResults[["estimate"]])
# sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10] #returns the index of the top 10 scoring sets

plot(seq(1:dim(tmp)[1]),
     tmp$estimate,
     xlab="",
     ylab="Posterior Probability of activation",
     #ylim=c(0,3.6),
     xaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(seq(1:dim(tmp)[1]) %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 0.3))
     )
axis(1, sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10],las=2, cex.axis=0.5, font=2, labels = colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]])
title("Posterior probabilities of activation")
abline(h=0.5,col="grey")
#text(sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], tmp$estimate[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]]-0.04, labels=colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]], cex=0.7)

#DENSITY PLOT

plot(density(tmp$estimate),
     col= "dodgerblue",
     lwd= 2,
     main="",
     xlab="Posterior probability of activation",
     ylab="Number of GO sets \n with given probability",
     #ylim=range(pretty(c(0, 1)))
     )
abline(v=0.5,col="grey")
title("Distribution of posterior activation probabilities")

#BARPLOT

sorted_tmp <- tmp
sorted_tmp$sd <- MGSA_result@setsResults[["std.error"]]
sorted_tmp$index <- seq(1:dim(sorted_tmp)[1])
sorted_tmp <- sorted_tmp[order(sorted_tmp$estimate, decreasing = TRUE),]
#sorted_tmp <- as.data.frame(sort(sorted_tmp$estimate, index.return=TRUE, decreasing=TRUE))
sorted_tmp$rank <- seq(1:dim(sorted_tmp)[1])
#colnames(sorted_tmp) <- c("estimate", "index", "rank")

plot(sorted_tmp[1:20,]$estimate,
     sorted_tmp[1:20,]$rank,
     xlab="Posterior Probability of activation \n +/- Standard Error",
     ylab="",
     #ylim=c(1,20),
     ylim = rev(range(sorted_tmp[1:20,]$rank)), #so that higher ranks (lower positions) are at the bottom
     yaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(sorted_tmp$index %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 1))
     )
axis(2, sorted_tmp[1:20,]$rank,las=2, 
     cex.axis=0.5, 
     font=2, 
     labels = colnames(GO_annotations_wide)[sorted_tmp[1:20,]$index])
title("Posterior probabilities of activation")
# Add error bars
#https://www.benjaminbell.co.uk/2019/04/how-to-add-error-bars-in-r.html
arrows(x0=sorted_tmp[1:20,]$estimate - sorted_tmp[1:20,]$sd, 
       y0=sorted_tmp[1:20,]$rank, 
       x1=sorted_tmp[1:20,]$estimate+ sorted_tmp[1:20,]$sd, 
       y1=sorted_tmp[1:20,]$rank, 
       code=3, 
       angle=90, 
       length=0.1,
       col = "gray")

```

<br/> For the top scoring pathways, below the list of the actual genes belonging to that pathway that were found in our list of differentially-expressed genes:


```{r, echo=FALSE}
#for the top pathways, print the genes that have been found amongst DE
#sorted_tmp[1:5,1] #is the colnames of GO-annotation_wide we have to extract gene codes from

#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) #find which of all pathways genes are actually those found amongst DE genes
  #print(top_table[top_table$ensembl_gene_id %in% expressed, c("FC", "adj.P.Val", "ensembl_gene_id", "description", "AveExpr", "CI.L", "CI.R")])
  print(kable(annotation_info_Ao[annotation_info_Ao$ensembl_ID %in% expressed, c("entrez_ID", "ensembl_ID", "merged_symbol", "merged_description") ], 
              caption= paste0("Genes of GO set:[",sorted_tmp[i,1],"] present amonst genes of interest")))
  
}
     
```
```{r,fig.width=10, fig.height=10}





#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) 
  
  expressed <- annotation_info_Ao$entrez_ID[match(expressed,annotation_info_Ao$ensembl_ID)]
expressed_OG <- rownames(dictionary_orthogroups_best_withHox_genebased[match(expressed,dictionary_orthogroups_best_withHox_genebased$Ao),])

#counts_VST_tmp <- counts_VST_selectedgenes[rownames(counts_VST_selectedgenes) %in% expressed_OG,]

counts_VST_tmp <- zmerged_counts_all[rownames(zmerged_counts_all) %in% expressed_OG,]



rownames(counts_VST_tmp) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_tmp) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
rownames(counts_VST_tmp) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_tmp) ,annotation_info_Ao$entrez_ID)] 



htmp <- Heatmap(as.matrix(counts_VST_tmp),
                column_title = paste0("GO set:[",sorted_tmp[i,1],"]"),
        cluster_columns = F,
        column_split = merged_metadata_all$species,
        col = rev(brewer.pal(11,"RdBu"))
        )

plot(htmp)
  
  
}


```



### continue



```{r}
splsda.perf <- perf(basic.splsda.model) # undergo performance optimisation
plot(splsda.perf)
```
```{r}
splsda.perf$choice.ncomp
```

```{r}
# note that usually a call in the below line would be more appropriate:
optimal.ncomp <- splsda.perf$choice.ncomp["overall", "centroids.dist"]

#overwrite
optimal.ncomp <- 2
```


```{r}
splsda.tune <- tune(X = X, Y = Y, study = study,  # tune the number of features
                              ncomp = optimal.ncomp,# using optimal comp number
                              test.keepX = seq(1, 100, 1), 
                              method = 'mint.splsda', 
                              measure = 'BER', # balanced error rate
                              dist = "centroids.dist")
```

```{r}
plot(splsda.tune, sd = FALSE)

```


```{r}
optimal.keepX <- splsda.tune$choice.keepX # extract optimal values

optimal.keepX
```
```{r}
final.splsda.model <- mint.splsda(X = X, Y = Y, study = study, 
                                  ncomp = optimal.ncomp, 
                                  keepX = optimal.keepX)
```

```{r, fig.width=12, fig.height=12}
plotIndiv(final.splsda.model, study = 'global', 
          legend = TRUE,
          title = '(a) Stem cells, MINT sPLS-DA',
          subtitle = 'Global', ellipse = T)

plotIndiv(final.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```




```{r}
plotIndiv(final.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')




# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(final.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(final.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```


```{r}
#loading vectors
test <- as.data.frame(final.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```



```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp1 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
dictionary_orthogroups_best_genebased["OG0004226",]
```


```{r, fig.height=3, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```

```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp2, decreasing = T), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp2 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```

```{r, fig.height=3, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```
















## Ptf transition signature
```{r, echo=FALSE}
#BiocManager::install("mixOmics")
library(mixOmics)
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/merged_metadata.rds") #merged_metadata
load("Z://01_Stefano/Collaboration_Data/Annotations/zmerged_counts.rds") #zmerged_counts


#### AVERAGE OR NOT? (comment/uncomment)
merged_counts_averaged <- data.frame(matrix(nrow=nrow(zmerged_counts),ncol=0))
group_indeces <- c(0, cumsum(unname( table(merged_metadata$segment))))
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- zmerged_counts[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  merged_counts_averaged <- cbind(merged_counts_averaged, tmp_averages)
  
}
colnames(merged_counts_averaged) <- paste0(unique(merged_metadata$segment), "_mean")
merged_counts <- merged_counts_averaged

merged_metadata_averaged <- merged_metadata
merged_metadata_averaged <- merged_metadata_averaged[!duplicated(merged_metadata_averaged$segment),]
rownames(merged_metadata_averaged) <- paste0(merged_metadata_averaged$segment, "_mean")
merged_metadata <- merged_metadata_averaged
###



# generate basic MINT pls-da model
#in mixOmics
# X = counts matrix (rows: samples, columns, genes)
# Y = vector of classes (1 per sample)
#study <- vector of different studies to be batch integrated

counts_VST_transposed <- t(merged_counts)
X <- counts_VST_transposed
#Y <- merged_metadata$segment

#what if I force similarity


#hindgut segments (expanded) in averaged dataset
Y <-  c(rep("not-transition", 3), rep("transition", 1), rep("not-transition", 3), #Ao
         rep("not-transition", 3), rep("transition", 1), rep("not-transition", 1), #Bf
         rep("not-transition", 6),  rep("transition", 2), rep("not-transition", 3), #Pf
         rep("not-transition", 2), rep("transition", 1),rep("not-transition", 6), #Sp
         rep("not-transition", 4), rep("transition", 2), rep("not-transition", 4)) #Pd


#hindgut segments (strict) in averaged dataset
#Y <-  c(rep("not-hindgut", 6), rep("hindgut", 1), #Ao
#         rep("not-hindgut", 4), rep("hindgut", 1), #Bf
#         rep("not-hindgut", 9),  rep("hindgut", 2), #Pf
#         rep("not-hindgut", 7), rep("hindgut", 2), #Sp
#         rep("not-hindgut", 9), rep("hindgut", 1)) #Pd


study <- merged_metadata$species


basic.splsda.model <- mint.splsda(X, Y, study = study, ncomp = 10) 
#basic.pls.model <- mint.pls(X, Y, study = study, ncomp = 2) 

# plot the samples
plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: hindgut vs others ', ellipse = TRUE,
          col = c("gray", "goldenrod1")) 
```
```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/MINTsPLS_transition_PCA.pdf")

plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: hindgut vs others ', ellipse = TRUE,
          col = c("gray", "goldenrod1")) 

dev.off()
```


```{r, fig.height=12, fig.width=12}
plotIndiv(basic.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```


```{r}
plotIndiv(basic.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 2:3, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 3:4, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 4:5, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 5:6, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 6:7, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(basic.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(basic.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(basic.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```

```{r, echo=FALSE}
#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:10]
#selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species.rds") #shared_TFs_8species [356]
orthogroup_TFs <- shared_TFs_8species

summary(selected_genes %in% orthogroup_TFs)
selected_genes[selected_genes %in% orthogroup_TFs == T]
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")

dictionary_orthogroups_best_withHox_genebased["OG0003690",]
```


```{r, fig.height=10, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


colors <- list(segment = c("gray90", "goldenrod1"))
names(colors[[1]]) <- unique(Y)

colAnn <- HeatmapAnnotation(segment = as.factor(Y),
                            col = colors,
                            show_legend = F,
                            show_annotation_name = F)
htmp <- Heatmap(as.matrix(counts_VST_selectedgenes),
                name= "z-score (within-species)",
                cluster_columns = F,
                column_split = factor(merged_metadata$species, levels=c("Pd", "Sp", "Pf", "Bf", "Ao")),
                column_gap = rep(unit(5, "mm"),4),
                col = rev(brewer.pal(11,"RdBu")),
                top_annotation = colAnn,
                heatmap_legend_param = list(legend_direction = "horizontal", 
                                            legend_width = unit(6, "cm")
                                            )
                )
draw(htmp, 
     heatmap_legend_side="bottom",
     #annotation_legend_side="right",
     #legend_grouping = "original",
     padding = unit(c(2, 2, 2, 100), "mm")
     )
```

```{r}
#pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/MINTsPLS_transition_heatmap_top50.pdf")
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/MINTsPLS_transition_heatmap_top10.pdf")

draw(htmp, 
     heatmap_legend_side="bottom"
     ) 

dev.off()
```


#### enrichment


```{r}
#replace with best gene  representative
ordered_genes <-dictionary_orthogroups_best_withHox_genebased$Ao[match(selected_genes,rownames(dictionary_orthogroups_best_withHox_genebased))]
```

```{r}
#we will need to convert to ensembl
ordered_genes_Ensembl <- annotation_info_Ao$ensembl_ID[match(ordered_genes,annotation_info_Ao$entrez_ID)]
```

```{r}
ordered_genes_Ensembl <- na.omit(ordered_genes_Ensembl) #48
```


```{r}
# uncomment if not run this earlier in the code and object "ensembl" does not exist
require(biomaRt)
ensembl <- useMart('ensembl', dataset = 'aocellaris_gene_ensembl')
#tab_GO
GO_annotations <- getBM(attributes = c("ensembl_gene_id", 'namespace_1003', "go_id", "name_1006"),
                        mart = ensembl)
#only keep genes annotated for Biological Process GO terms
GO_annotations <- subset(GO_annotations, (namespace_1003 %in% "biological_process"))

#let us also add a column with the descriptions from our annotation_info file
GO_annotations$description <- annotation_info$merged_description[match(GO_annotations$ensembl_gene_id, annotation_info$ensembl_ID)]
```

```{r, fig.width=8, fig.height=8, echo=FALSE}
#but try also clusterprofiler
#Groups of genes identified by some analyses are used as input list to the mgsa function from the mgsa package13
#(with parameters restarts=3 and steps=1e7).

#The model assumes that some sets to be inferred are active and that all genes member of active sets are themselves active. Active genes are more likely to belong to the observations and inactive genes not. Fitting the model amounts to infer the probability of every set to be active given the observations.
#Classical methods analyze each set in isolation. Because sets such as biological pathways often share genes with each other, the returned list of enriched sets is usually long and redundant. In contrast, MGSA takes set overlap into account by working on all sets simultaneously and substantially reduces the number of redundant sets.

#e.g. take list of DE genes S1/S2 [== example_o]
# take list of GO terms (obtained previously) [== example_go]
#myset = new( "MgsaSets", sets=list(set1=LETTERS[1:3], set2=LETTERS[2:5]) )


#prepare table where each column is a GO:pathwayID and entries are the genes that belong to that group
GO_annotations_wide <- GO_annotations[, c("ensembl_gene_id", "go_id")]
GO_annotations_wide$id <- seq.int(nrow(GO_annotations_wide))
GO_annotations_wide <- GO_annotations_wide %>% pivot_wider(names_from = go_id, values_from = ensembl_gene_id)

#only keep GO groups with at least 4 genes and max 500
GO_annotations_wide <- GO_annotations_wide %>% select_if(~ sum(!is.na(.)) > 4 & sum(!is.na(.)) < 500)

#replace GO codes with full names so the results are easier to interpret
tmp <- GO_annotations[, c("name_1006", "go_id")]
tmp <- tmp[!duplicated(tmp),]

colnames(GO_annotations_wide) <- tmp$name_1006[tmp$go_id %in% colnames(GO_annotations_wide)]
rm(tmp)


```


```{r}
#run the mgsa function
MGSA_result = mgsa(ordered_genes_Ensembl, #this is a list of genes previously obtained during the DE analysis
                   #should maybe just take upregulated in one stage  and upregulated in the other, separatedly
                   GO_annotations_wide, 
                   restarts=5,  
                   steps=1e7)

#show the ordered list of gene sets found
setsResults(MGSA_result)[order(setsResults(MGSA_result)$estimate, decreasing = TRUE),][1:25,]
#plot(MGSA_result)

#The model have three parameters:
# α, the false positive rate i.e. the probability of an inactive gene to actually be observed;
# β, the false negative rate i.e. the probability of an active gene to actually be not observed;
# p, the prior probability for any set to be active, a typically small number ensuring sparse solutions to be inferred

#res = setsResults(MGSA_result)
#subset(res, estimate > 0.5)
```

<br/> Below, for reference, the scoring of all Gene Ontology gene sets considered, and the hyperparameters of the model ( _alpha_ , _beta_, and indirectly _p_ ):

```{r, echo=FALSE, fig.width=9, fig.height=9, warning=FALSE}
#for customisation purposes, let us try to obtain the same plots as plot(MGSA_result)

#set space for 4 plots
par(mfrow=c(2,2))

##p, alpha, beta hyperparameters of the model
## Note this is the information that would be extracted from the original bottom 3 plots

# average number of gene sets expected to be active: p* number of gene sets considered
pPost <- (pPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value)*dim(MGSA_result@setsResults)[1]
# most likely alpha parameter of the model (false positive)
pAlpha <- alphaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value
# most likely beta parameter of the model (false negative rate)
pBeta <- betaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value

title <- paste0("MGSA analysis: \n \n expected active gene sets: ",pPost,"\n alpha (false positives): ", pAlpha, "\n beta (false negatives): ",pBeta)

# TEXT
plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, title , cex=1.2)

## DOTPLOT

tmp <- data.frame(go_id = colnames(GO_annotations_wide), estimate =MGSA_result@setsResults[["estimate"]])
# sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10] #returns the index of the top 10 scoring sets

plot(seq(1:dim(tmp)[1]),
     tmp$estimate,
     xlab="",
     ylab="Posterior Probability of activation",
     #ylim=c(0,3.6),
     xaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(seq(1:dim(tmp)[1]) %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 0.3))
     )
axis(1, sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10],las=2, cex.axis=0.5, font=2, labels = colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]])
title("Posterior probabilities of activation")
abline(h=0.5,col="grey")
#text(sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], tmp$estimate[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]]-0.04, labels=colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]], cex=0.7)

#DENSITY PLOT

plot(density(tmp$estimate),
     col= "dodgerblue",
     lwd= 2,
     main="",
     xlab="Posterior probability of activation",
     ylab="Number of GO sets \n with given probability",
     #ylim=range(pretty(c(0, 1)))
     )
abline(v=0.5,col="grey")
title("Distribution of posterior activation probabilities")

#BARPLOT

sorted_tmp <- tmp
sorted_tmp$sd <- MGSA_result@setsResults[["std.error"]]
sorted_tmp$index <- seq(1:dim(sorted_tmp)[1])
sorted_tmp <- sorted_tmp[order(sorted_tmp$estimate, decreasing = TRUE),]
#sorted_tmp <- as.data.frame(sort(sorted_tmp$estimate, index.return=TRUE, decreasing=TRUE))
sorted_tmp$rank <- seq(1:dim(sorted_tmp)[1])
#colnames(sorted_tmp) <- c("estimate", "index", "rank")

plot(sorted_tmp[1:20,]$estimate,
     sorted_tmp[1:20,]$rank,
     xlab="Posterior Probability of activation \n +/- Standard Error",
     ylab="",
     #ylim=c(1,20),
     ylim = rev(range(sorted_tmp[1:20,]$rank)), #so that higher ranks (lower positions) are at the bottom
     yaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(sorted_tmp$index %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 1))
     )
axis(2, sorted_tmp[1:20,]$rank,las=2, 
     cex.axis=0.5, 
     font=2, 
     labels = colnames(GO_annotations_wide)[sorted_tmp[1:20,]$index])
title("Posterior probabilities of activation")
# Add error bars
#https://www.benjaminbell.co.uk/2019/04/how-to-add-error-bars-in-r.html
arrows(x0=sorted_tmp[1:20,]$estimate - sorted_tmp[1:20,]$sd, 
       y0=sorted_tmp[1:20,]$rank, 
       x1=sorted_tmp[1:20,]$estimate+ sorted_tmp[1:20,]$sd, 
       y1=sorted_tmp[1:20,]$rank, 
       code=3, 
       angle=90, 
       length=0.1,
       col = "gray")

```

<br/> For the top scoring pathways, below the list of the actual genes belonging to that pathway that were found in our list of differentially-expressed genes:


```{r, echo=FALSE}
#for the top pathways, print the genes that have been found amongst DE
#sorted_tmp[1:5,1] #is the colnames of GO-annotation_wide we have to extract gene codes from

#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) #find which of all pathways genes are actually those found amongst DE genes
  #print(top_table[top_table$ensembl_gene_id %in% expressed, c("FC", "adj.P.Val", "ensembl_gene_id", "description", "AveExpr", "CI.L", "CI.R")])
  print(kable(annotation_info_Ao[annotation_info_Ao$ensembl_ID %in% expressed, c("entrez_ID", "ensembl_ID", "merged_symbol", "merged_description") ], 
              caption= paste0("Genes of GO set:[",sorted_tmp[i,1],"] present amonst genes of interest")))
  
}
     
```
```{r,fig.width=10, fig.height=10}





#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) 
  
  expressed <- annotation_info_Ao$entrez_ID[match(expressed,annotation_info_Ao$ensembl_ID)]
expressed_OG <- rownames(dictionary_orthogroups_best_withHox_genebased[match(expressed,dictionary_orthogroups_best_withHox_genebased$Ao),])

#counts_VST_tmp <- counts_VST_selectedgenes[rownames(counts_VST_selectedgenes) %in% expressed_OG,]

counts_VST_tmp <- zmerged_counts_all[rownames(zmerged_counts_all) %in% expressed_OG,]



rownames(counts_VST_tmp) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_tmp) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
rownames(counts_VST_tmp) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_tmp) ,annotation_info_Ao$entrez_ID)] 



htmp <- Heatmap(as.matrix(counts_VST_tmp),
                column_title = paste0("GO set:[",sorted_tmp[i,1],"]"),
        cluster_columns = F,
        column_split = merged_metadata_all$species,
        col = rev(brewer.pal(11,"RdBu"))
        )

plot(htmp)
  
  
}


```



### continue



```{r}
splsda.perf <- perf(basic.splsda.model) # undergo performance optimisation
plot(splsda.perf)
```
```{r}
splsda.perf$choice.ncomp
```

```{r}
# note that usually a call in the below line would be more appropriate:
optimal.ncomp <- splsda.perf$choice.ncomp["overall", "centroids.dist"]

#overwrite
optimal.ncomp <- 2
```


```{r}
splsda.tune <- tune(X = X, Y = Y, study = study,  # tune the number of features
                              ncomp = optimal.ncomp,# using optimal comp number
                              test.keepX = seq(1, 100, 1), 
                              method = 'mint.splsda', 
                              measure = 'BER', # balanced error rate
                              dist = "centroids.dist")
```

```{r}
plot(splsda.tune, sd = FALSE)

```


```{r}
optimal.keepX <- splsda.tune$choice.keepX # extract optimal values

optimal.keepX
```
```{r}
final.splsda.model <- mint.splsda(X = X, Y = Y, study = study, 
                                  ncomp = optimal.ncomp, 
                                  keepX = optimal.keepX)
```

```{r, fig.width=12, fig.height=12}
plotIndiv(final.splsda.model, study = 'global', 
          legend = TRUE,
          title = '(a) Stem cells, MINT sPLS-DA',
          subtitle = 'Global', ellipse = T)

plotIndiv(final.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```




```{r}
plotIndiv(final.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')




# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(final.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(final.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(final.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```



```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp1 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
dictionary_orthogroups_best_genebased["OG0004226",]
```


```{r, fig.height=3, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```

```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp2, decreasing = T), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp2 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```

```{r, fig.height=3, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```

## Ptf Module2 signature (with Liver)
```{r, echo=FALSE}
#BiocManager::install("mixOmics")
library(mixOmics)
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/merged_metadata.rds") #merged_metadata
load("Z://01_Stefano/Collaboration_Data/Annotations/zmerged_counts.rds") #zmerged_counts


#### AVERAGE OR NOT? (comment/uncomment)
merged_counts_averaged <- data.frame(matrix(nrow=nrow(zmerged_counts),ncol=0))
group_indeces <- c(0, cumsum(unname( table(merged_metadata$segment))))
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- zmerged_counts[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  merged_counts_averaged <- cbind(merged_counts_averaged, tmp_averages)
  
}
colnames(merged_counts_averaged) <- paste0(unique(merged_metadata$segment), "_mean")
merged_counts <- merged_counts_averaged

merged_metadata_averaged <- merged_metadata
merged_metadata_averaged <- merged_metadata_averaged[!duplicated(merged_metadata_averaged$segment),]
rownames(merged_metadata_averaged) <- paste0(merged_metadata_averaged$segment, "_mean")
merged_metadata <- merged_metadata_averaged
###



# generate basic MINT pls-da model
#in mixOmics
# X = counts matrix (rows: samples, columns, genes)
# Y = vector of classes (1 per sample)
#study <- vector of different studies to be batch integrated

counts_VST_transposed <- t(merged_counts)
X <- counts_VST_transposed
#Y <- merged_metadata$segment

#what if I force similarity


#hindgut segments (expanded) in averaged dataset
Y <-  c( rep("transition", 1), rep("not-transition", 6), #Ao
         rep("not-transition", 2), rep("transition", 2), rep("not-transition", 1), #Bf
         rep("not-transition", 6),  rep("transition", 2), rep("not-transition", 3), #Pf
         rep("not-transition", 2), rep("transition", 1),rep("not-transition", 6), #Sp
         rep("not-transition", 4), rep("transition", 2), rep("not-transition", 4)) #Pd


#hindgut segments (strict) in averaged dataset
#Y <-  c(rep("not-hindgut", 6), rep("hindgut", 1), #Ao
#         rep("not-hindgut", 4), rep("hindgut", 1), #Bf
#         rep("not-hindgut", 9),  rep("hindgut", 2), #Pf
#         rep("not-hindgut", 7), rep("hindgut", 2), #Sp
#         rep("not-hindgut", 9), rep("hindgut", 1)) #Pd


study <- merged_metadata$species


basic.splsda.model <- mint.splsda(X, Y, study = study, ncomp = 10) 
#basic.pls.model <- mint.pls(X, Y, study = study, ncomp = 2) 

# plot the samples
plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: hindgut vs others ', ellipse = TRUE,
          col = c("gray", "goldenrod1")) 
```
```{r, fig.height=12, fig.width=12}
plotIndiv(basic.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```


```{r}
plotIndiv(basic.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 2:3, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 3:4, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 4:5, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 5:6, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 6:7, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(basic.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(basic.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(basic.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```

```{r, echo=FALSE}
#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:50]
#selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species.rds") #shared_TFs_8species [356]
orthogroup_TFs <- shared_TFs_8species

summary(selected_genes %in% orthogroup_TFs)
selected_genes[selected_genes %in% orthogroup_TFs == T]
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")

dictionary_orthogroups_best_withHox_genebased["OG0003690",]
```


```{r, fig.height=6, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


colors <- list(segment = c("goldenrod1", "gray90"))
names(colors[[1]]) <- unique(Y)

colAnn <- HeatmapAnnotation(segment = as.factor(Y),
                            col = colors,
                            show_legend = F,
                            show_annotation_name = F)
htmp <- Heatmap(as.matrix(counts_VST_selectedgenes),
                name= "z-score (within-species)",
                cluster_columns = F,
                column_split = merged_metadata$species,
                column_gap = rep(unit(5, "mm"),4),
                col = rev(brewer.pal(11,"RdBu")),
                top_annotation = colAnn,
                heatmap_legend_param = list(legend_direction = "horizontal", 
                                            legend_width = unit(6, "cm")
                                            )
                )
draw(htmp, 
     heatmap_legend_side="bottom",
     #annotation_legend_side="right",
     #legend_grouping = "original",
     padding = unit(c(2, 2, 2, 100), "mm")
     )
```

#### enrichment


```{r}
#replace with best gene  representative
ordered_genes <-dictionary_orthogroups_best_withHox_genebased$Ao[match(selected_genes,rownames(dictionary_orthogroups_best_withHox_genebased))]
```

```{r}
#we will need to convert to ensembl
ordered_genes_Ensembl <- annotation_info_Ao$ensembl_ID[match(ordered_genes,annotation_info_Ao$entrez_ID)]
```

```{r}
ordered_genes_Ensembl <- na.omit(ordered_genes_Ensembl) #48
```


```{r}
#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

# uncomment if not run this earlier in the code and object "ensembl" does not exist
require(biomaRt)
ensembl <- useMart('ensembl', dataset = 'aocellaris_gene_ensembl')
#tab_GO
GO_annotations <- getBM(attributes = c("ensembl_gene_id", 'namespace_1003', "go_id", "name_1006"),
                        mart = ensembl)
#only keep genes annotated for Biological Process GO terms
GO_annotations <- subset(GO_annotations, (namespace_1003 %in% "biological_process"))

#let us also add a column with the descriptions from our annotation_info file
GO_annotations$description <- annotation_info$merged_description[match(GO_annotations$ensembl_gene_id, annotation_info$ensembl_ID)]
```

```{r, fig.width=8, fig.height=8, echo=FALSE}
#but try also clusterprofiler
#Groups of genes identified by some analyses are used as input list to the mgsa function from the mgsa package13
#(with parameters restarts=3 and steps=1e7).

#The model assumes that some sets to be inferred are active and that all genes member of active sets are themselves active. Active genes are more likely to belong to the observations and inactive genes not. Fitting the model amounts to infer the probability of every set to be active given the observations.
#Classical methods analyze each set in isolation. Because sets such as biological pathways often share genes with each other, the returned list of enriched sets is usually long and redundant. In contrast, MGSA takes set overlap into account by working on all sets simultaneously and substantially reduces the number of redundant sets.

#e.g. take list of DE genes S1/S2 [== example_o]
# take list of GO terms (obtained previously) [== example_go]
#myset = new( "MgsaSets", sets=list(set1=LETTERS[1:3], set2=LETTERS[2:5]) )


#prepare table where each column is a GO:pathwayID and entries are the genes that belong to that group
GO_annotations_wide <- GO_annotations[, c("ensembl_gene_id", "go_id")]
GO_annotations_wide$id <- seq.int(nrow(GO_annotations_wide))
GO_annotations_wide <- GO_annotations_wide %>% pivot_wider(names_from = go_id, values_from = ensembl_gene_id)

#only keep GO groups with at least 4 genes and max 500
GO_annotations_wide <- GO_annotations_wide %>% select_if(~ sum(!is.na(.)) > 4 & sum(!is.na(.)) < 500)

#replace GO codes with full names so the results are easier to interpret
tmp <- GO_annotations[, c("name_1006", "go_id")]
tmp <- tmp[!duplicated(tmp),]

colnames(GO_annotations_wide) <- tmp$name_1006[tmp$go_id %in% colnames(GO_annotations_wide)]
rm(tmp)


```


```{r}
#run the mgsa function
MGSA_result = mgsa(ordered_genes_Ensembl, #this is a list of genes previously obtained during the DE analysis
                   #should maybe just take upregulated in one stage  and upregulated in the other, separatedly
                   GO_annotations_wide, 
                   restarts=5,  
                   steps=1e7)

#show the ordered list of gene sets found
setsResults(MGSA_result)[order(setsResults(MGSA_result)$estimate, decreasing = TRUE),][1:25,]
#plot(MGSA_result)

#The model have three parameters:
# α, the false positive rate i.e. the probability of an inactive gene to actually be observed;
# β, the false negative rate i.e. the probability of an active gene to actually be not observed;
# p, the prior probability for any set to be active, a typically small number ensuring sparse solutions to be inferred

#res = setsResults(MGSA_result)
#subset(res, estimate > 0.5)
```

<br/> Below, for reference, the scoring of all Gene Ontology gene sets considered, and the hyperparameters of the model ( _alpha_ , _beta_, and indirectly _p_ ):

```{r, echo=FALSE, fig.width=9, fig.height=9, warning=FALSE}
#for customisation purposes, let us try to obtain the same plots as plot(MGSA_result)

#set space for 4 plots
par(mfrow=c(2,2))

##p, alpha, beta hyperparameters of the model
## Note this is the information that would be extracted from the original bottom 3 plots

# average number of gene sets expected to be active: p* number of gene sets considered
pPost <- (pPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value)*dim(MGSA_result@setsResults)[1]
# most likely alpha parameter of the model (false positive)
pAlpha <- alphaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value
# most likely beta parameter of the model (false negative rate)
pBeta <- betaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value

title <- paste0("MGSA analysis: \n \n expected active gene sets: ",pPost,"\n alpha (false positives): ", pAlpha, "\n beta (false negatives): ",pBeta)

# TEXT
plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, title , cex=1.2)

## DOTPLOT

tmp <- data.frame(go_id = colnames(GO_annotations_wide), estimate =MGSA_result@setsResults[["estimate"]])
# sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10] #returns the index of the top 10 scoring sets

plot(seq(1:dim(tmp)[1]),
     tmp$estimate,
     xlab="",
     ylab="Posterior Probability of activation",
     #ylim=c(0,3.6),
     xaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(seq(1:dim(tmp)[1]) %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 0.3))
     )
axis(1, sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10],las=2, cex.axis=0.5, font=2, labels = colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]])
title("Posterior probabilities of activation")
abline(h=0.5,col="grey")
#text(sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], tmp$estimate[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]]-0.04, labels=colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]], cex=0.7)

#DENSITY PLOT

plot(density(tmp$estimate),
     col= "dodgerblue",
     lwd= 2,
     main="",
     xlab="Posterior probability of activation",
     ylab="Number of GO sets \n with given probability",
     #ylim=range(pretty(c(0, 1)))
     )
abline(v=0.5,col="grey")
title("Distribution of posterior activation probabilities")

#BARPLOT

sorted_tmp <- tmp
sorted_tmp$sd <- MGSA_result@setsResults[["std.error"]]
sorted_tmp$index <- seq(1:dim(sorted_tmp)[1])
sorted_tmp <- sorted_tmp[order(sorted_tmp$estimate, decreasing = TRUE),]
#sorted_tmp <- as.data.frame(sort(sorted_tmp$estimate, index.return=TRUE, decreasing=TRUE))
sorted_tmp$rank <- seq(1:dim(sorted_tmp)[1])
#colnames(sorted_tmp) <- c("estimate", "index", "rank")

plot(sorted_tmp[1:20,]$estimate,
     sorted_tmp[1:20,]$rank,
     xlab="Posterior Probability of activation \n +/- Standard Error",
     ylab="",
     #ylim=c(1,20),
     ylim = rev(range(sorted_tmp[1:20,]$rank)), #so that higher ranks (lower positions) are at the bottom
     yaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(sorted_tmp$index %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 1))
     )
axis(2, sorted_tmp[1:20,]$rank,las=2, 
     cex.axis=0.5, 
     font=2, 
     labels = colnames(GO_annotations_wide)[sorted_tmp[1:20,]$index])
title("Posterior probabilities of activation")
# Add error bars
#https://www.benjaminbell.co.uk/2019/04/how-to-add-error-bars-in-r.html
arrows(x0=sorted_tmp[1:20,]$estimate - sorted_tmp[1:20,]$sd, 
       y0=sorted_tmp[1:20,]$rank, 
       x1=sorted_tmp[1:20,]$estimate+ sorted_tmp[1:20,]$sd, 
       y1=sorted_tmp[1:20,]$rank, 
       code=3, 
       angle=90, 
       length=0.1,
       col = "gray")

```

<br/> For the top scoring pathways, below the list of the actual genes belonging to that pathway that were found in our list of differentially-expressed genes:


```{r, echo=FALSE}
#for the top pathways, print the genes that have been found amongst DE
#sorted_tmp[1:5,1] #is the colnames of GO-annotation_wide we have to extract gene codes from

#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) #find which of all pathways genes are actually those found amongst DE genes
  #print(top_table[top_table$ensembl_gene_id %in% expressed, c("FC", "adj.P.Val", "ensembl_gene_id", "description", "AveExpr", "CI.L", "CI.R")])
  print(kable(annotation_info_Ao[annotation_info_Ao$ensembl_ID %in% expressed, c("entrez_ID", "ensembl_ID", "merged_symbol", "merged_description") ], 
              caption= paste0("Genes of GO set:[",sorted_tmp[i,1],"] present amonst genes of interest")))
  
}
     
```


#### sufficient subset











```{r}
splsda.perf <- perf(basic.splsda.model) # undergo performance optimisation
plot(splsda.perf)
```
```{r}
splsda.perf$choice.ncomp
```

```{r}
# note that usually a call in the below line would be more appropriate:
optimal.ncomp <- splsda.perf$choice.ncomp["overall", "centroids.dist"]

#overwrite
optimal.ncomp <- 2
```


```{r}
splsda.tune <- tune(X = X, Y = Y, study = study,  # tune the number of features
                              ncomp = optimal.ncomp,# using optimal comp number
                              test.keepX = seq(1, 100, 1), 
                              method = 'mint.splsda', 
                              measure = 'BER', # balanced error rate
                              dist = "centroids.dist")
```

```{r}
plot(splsda.tune, sd = FALSE)

```


```{r}
optimal.keepX <- splsda.tune$choice.keepX # extract optimal values

optimal.keepX
```
```{r}
final.splsda.model <- mint.splsda(X = X, Y = Y, study = study, 
                                  ncomp = optimal.ncomp, 
                                  keepX = optimal.keepX)
```

```{r, fig.width=12, fig.height=12}
plotIndiv(final.splsda.model, study = 'global', 
          legend = TRUE,
          title = '(a) Stem cells, MINT sPLS-DA',
          subtitle = 'Global', ellipse = T)

plotIndiv(final.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```




```{r}
plotIndiv(final.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')




# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(final.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(final.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(final.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```



```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp1 != 0,])]


head(test)

```
```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp1, decreasing = T), ] 
selected_genes2 <- rownames(test)[1:20]
selected_genes2 <- c(selected_genes2, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes2 <- selected_genes2[selected_genes2 %in% rownames(test[test$comp2 != 0,])]


head(test)

```
```{r}
selected_genes <- c(selected_genes, selected_genes2)
```



```{r, fig.height=3, fig.width=15}
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```

```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp2, decreasing = T), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp2 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```

```{r, fig.height=3, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```

## Ptf Module2 signature (with Oesophagus)
```{r, echo=FALSE}
#BiocManager::install("mixOmics")
library(mixOmics)
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/merged_metadata.rds") #merged_metadata
load("Z://01_Stefano/Collaboration_Data/Annotations/zmerged_counts.rds") #zmerged_counts


#### AVERAGE OR NOT? (comment/uncomment)
merged_counts_averaged <- data.frame(matrix(nrow=nrow(zmerged_counts),ncol=0))
group_indeces <- c(0, cumsum(unname( table(merged_metadata$segment))))
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- zmerged_counts[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  merged_counts_averaged <- cbind(merged_counts_averaged, tmp_averages)
  
}
colnames(merged_counts_averaged) <- paste0(unique(merged_metadata$segment), "_mean")
merged_counts <- merged_counts_averaged

merged_metadata_averaged <- merged_metadata
merged_metadata_averaged <- merged_metadata_averaged[!duplicated(merged_metadata_averaged$segment),]
rownames(merged_metadata_averaged) <- paste0(merged_metadata_averaged$segment, "_mean")
merged_metadata <- merged_metadata_averaged
###



# generate basic MINT pls-da model
#in mixOmics
# X = counts matrix (rows: samples, columns, genes)
# Y = vector of classes (1 per sample)
#study <- vector of different studies to be batch integrated

counts_VST_transposed <- t(merged_counts)
X <- counts_VST_transposed
#Y <- merged_metadata$segment

#what if I force similarity


#hindgut segments (expanded) in averaged dataset
Y <-  c( rep("not-module 2", 1), rep("module 2", 1), rep("not-module 2", 5), #Ao
         rep("not-module 2", 2), rep("module 2", 2), rep("not-module 2", 1), #Bf
         rep("not-module 2", 6),  rep("module 2", 2), rep("not-module 2", 3), #Pf
         rep("not-module 2", 2), rep("module 2", 1),rep("not-module 2", 6), #Sp
         rep("not-module 2", 4), rep("module 2", 2), rep("not-module 2", 4)) #Pd


#hindgut segments (strict) in averaged dataset
#Y <-  c(rep("not-hindgut", 6), rep("hindgut", 1), #Ao
#         rep("not-hindgut", 4), rep("hindgut", 1), #Bf
#         rep("not-hindgut", 9),  rep("hindgut", 2), #Pf
#         rep("not-hindgut", 7), rep("hindgut", 2), #Sp
#         rep("not-hindgut", 9), rep("hindgut", 1)) #Pd


study <- merged_metadata$species


basic.splsda.model <- mint.splsda(X, Y, study = study, ncomp = 10) 
#basic.pls.model <- mint.pls(X, Y, study = study, ncomp = 2) 

# plot the samples
plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: module 2 vs others ', ellipse = TRUE,
          col = c("goldenrod1", "gray")) 
```

```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/MINTsPLS_module2_PCA.pdf")

plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: module 2 vs others ', ellipse = TRUE,
          col = c("goldenrod1", "gray")) 

dev.off()
```

```{r, fig.height=12, fig.width=12}
plotIndiv(basic.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```


```{r}
plotIndiv(basic.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 2:3, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 3:4, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 4:5, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 5:6, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 6:7, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(basic.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(basic.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(basic.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```

```{r, echo=FALSE}
#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:25]
#selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species.rds") #shared_TFs_8species [356]
orthogroup_TFs <- shared_TFs_8species

summary(selected_genes %in% orthogroup_TFs)
selected_genes[selected_genes %in% orthogroup_TFs == T]
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")

dictionary_orthogroups_best_withHox_genebased["OG0006865",] #bhlha15
dictionary_orthogroups_best_withHox_genebased["OG0003690",] #tgif1
```


```{r, fig.height=8, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


colors <- list(segment = c("gray90", "goldenrod1"))
names(colors[[1]]) <- unique(Y)

colAnn <- HeatmapAnnotation(segment = as.factor(Y),
                            col = colors,
                            show_legend = F,
                            show_annotation_name = F)
htmp <- Heatmap(as.matrix(counts_VST_selectedgenes),
                name= "z-score (within-species)",
                cluster_columns = F,
                column_split = factor(merged_metadata$species, levels = c("Pd", "Sp", "Pf", "Bf", "Ao")),
                column_gap = rep(unit(5, "mm"),4),
                col = rev(brewer.pal(11,"RdBu")),
                top_annotation = colAnn,
                heatmap_legend_param = list(legend_direction = "horizontal", 
                                            legend_width = unit(6, "cm")
                                            )
                )
draw(htmp, 
     heatmap_legend_side="bottom",
     #annotation_legend_side="right",
     #legend_grouping = "original",
     padding = unit(c(2, 2, 2, 100), "mm")
     )
```


```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/MINTsPLS_module2_heatmap.pdf")

draw(htmp, 
     heatmap_legend_side="bottom"
     ) 

dev.off()
```



#### enrichment


```{r}
#replace with best gene  representative
ordered_genes <-dictionary_orthogroups_best_withHox_genebased$Ao[match(selected_genes,rownames(dictionary_orthogroups_best_withHox_genebased))]
```

```{r}
#we will need to convert to ensembl
ordered_genes_Ensembl <- annotation_info_Ao$ensembl_ID[match(ordered_genes,annotation_info_Ao$entrez_ID)]
```

```{r}
ordered_genes_Ensembl <- na.omit(ordered_genes_Ensembl) #48
```


```{r}
#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

# uncomment if not run this earlier in the code and object "ensembl" does not exist
require(biomaRt)
ensembl <- useMart('ensembl', dataset = 'aocellaris_gene_ensembl')
#tab_GO
GO_annotations <- getBM(attributes = c("ensembl_gene_id", 'namespace_1003', "go_id", "name_1006"),
                        mart = ensembl)
#only keep genes annotated for Biological Process GO terms
GO_annotations <- subset(GO_annotations, (namespace_1003 %in% "biological_process"))

#let us also add a column with the descriptions from our annotation_info file
GO_annotations$description <- annotation_info$merged_description[match(GO_annotations$ensembl_gene_id, annotation_info$ensembl_ID)]
```

```{r, fig.width=8, fig.height=8, echo=FALSE}
#but try also clusterprofiler
#Groups of genes identified by some analyses are used as input list to the mgsa function from the mgsa package13
#(with parameters restarts=3 and steps=1e7).

#The model assumes that some sets to be inferred are active and that all genes member of active sets are themselves active. Active genes are more likely to belong to the observations and inactive genes not. Fitting the model amounts to infer the probability of every set to be active given the observations.
#Classical methods analyze each set in isolation. Because sets such as biological pathways often share genes with each other, the returned list of enriched sets is usually long and redundant. In contrast, MGSA takes set overlap into account by working on all sets simultaneously and substantially reduces the number of redundant sets.

#e.g. take list of DE genes S1/S2 [== example_o]
# take list of GO terms (obtained previously) [== example_go]
#myset = new( "MgsaSets", sets=list(set1=LETTERS[1:3], set2=LETTERS[2:5]) )


#prepare table where each column is a GO:pathwayID and entries are the genes that belong to that group
GO_annotations_wide <- GO_annotations[, c("ensembl_gene_id", "go_id")]
GO_annotations_wide$id <- seq.int(nrow(GO_annotations_wide))
GO_annotations_wide <- GO_annotations_wide %>% pivot_wider(names_from = go_id, values_from = ensembl_gene_id)

#only keep GO groups with at least 4 genes and max 500
GO_annotations_wide <- GO_annotations_wide %>% select_if(~ sum(!is.na(.)) > 4 & sum(!is.na(.)) < 500)

#replace GO codes with full names so the results are easier to interpret
tmp <- GO_annotations[, c("name_1006", "go_id")]
tmp <- tmp[!duplicated(tmp),]

colnames(GO_annotations_wide) <- tmp$name_1006[tmp$go_id %in% colnames(GO_annotations_wide)]
rm(tmp)


```


```{r}
#run the mgsa function
MGSA_result = mgsa(ordered_genes_Ensembl, #this is a list of genes previously obtained during the DE analysis
                   #should maybe just take upregulated in one stage  and upregulated in the other, separatedly
                   GO_annotations_wide, 
                   restarts=5,  
                   steps=1e7)

#show the ordered list of gene sets found
setsResults(MGSA_result)[order(setsResults(MGSA_result)$estimate, decreasing = TRUE),][1:25,]
#plot(MGSA_result)

#The model have three parameters:
# α, the false positive rate i.e. the probability of an inactive gene to actually be observed;
# β, the false negative rate i.e. the probability of an active gene to actually be not observed;
# p, the prior probability for any set to be active, a typically small number ensuring sparse solutions to be inferred

#res = setsResults(MGSA_result)
#subset(res, estimate > 0.5)
```

<br/> Below, for reference, the scoring of all Gene Ontology gene sets considered, and the hyperparameters of the model ( _alpha_ , _beta_, and indirectly _p_ ):

```{r, echo=FALSE, fig.width=9, fig.height=9, warning=FALSE}
#for customisation purposes, let us try to obtain the same plots as plot(MGSA_result)

#set space for 4 plots
par(mfrow=c(2,2))

##p, alpha, beta hyperparameters of the model
## Note this is the information that would be extracted from the original bottom 3 plots

# average number of gene sets expected to be active: p* number of gene sets considered
pPost <- (pPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value)*dim(MGSA_result@setsResults)[1]
# most likely alpha parameter of the model (false positive)
pAlpha <- alphaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value
# most likely beta parameter of the model (false negative rate)
pBeta <- betaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value

title <- paste0("MGSA analysis: \n \n expected active gene sets: ",pPost,"\n alpha (false positives): ", pAlpha, "\n beta (false negatives): ",pBeta)

# TEXT
plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, title , cex=1.2)

## DOTPLOT

tmp <- data.frame(go_id = colnames(GO_annotations_wide), estimate =MGSA_result@setsResults[["estimate"]])
# sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10] #returns the index of the top 10 scoring sets

plot(seq(1:dim(tmp)[1]),
     tmp$estimate,
     xlab="",
     ylab="Posterior Probability of activation",
     #ylim=c(0,3.6),
     xaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(seq(1:dim(tmp)[1]) %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 0.3))
     )
axis(1, sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10],las=2, cex.axis=0.5, font=2, labels = colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]])
title("Posterior probabilities of activation")
abline(h=0.5,col="grey")
#text(sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], tmp$estimate[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]]-0.04, labels=colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]], cex=0.7)

#DENSITY PLOT

plot(density(tmp$estimate),
     col= "dodgerblue",
     lwd= 2,
     main="",
     xlab="Posterior probability of activation",
     ylab="Number of GO sets \n with given probability",
     #ylim=range(pretty(c(0, 1)))
     )
abline(v=0.5,col="grey")
title("Distribution of posterior activation probabilities")

#BARPLOT

sorted_tmp <- tmp
sorted_tmp$sd <- MGSA_result@setsResults[["std.error"]]
sorted_tmp$index <- seq(1:dim(sorted_tmp)[1])
sorted_tmp <- sorted_tmp[order(sorted_tmp$estimate, decreasing = TRUE),]
#sorted_tmp <- as.data.frame(sort(sorted_tmp$estimate, index.return=TRUE, decreasing=TRUE))
sorted_tmp$rank <- seq(1:dim(sorted_tmp)[1])
#colnames(sorted_tmp) <- c("estimate", "index", "rank")

plot(sorted_tmp[1:20,]$estimate,
     sorted_tmp[1:20,]$rank,
     xlab="Posterior Probability of activation \n +/- Standard Error",
     ylab="",
     #ylim=c(1,20),
     ylim = rev(range(sorted_tmp[1:20,]$rank)), #so that higher ranks (lower positions) are at the bottom
     yaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(sorted_tmp$index %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 1))
     )
axis(2, sorted_tmp[1:20,]$rank,las=2, 
     cex.axis=0.5, 
     font=2, 
     labels = colnames(GO_annotations_wide)[sorted_tmp[1:20,]$index])
title("Posterior probabilities of activation")
# Add error bars
#https://www.benjaminbell.co.uk/2019/04/how-to-add-error-bars-in-r.html
arrows(x0=sorted_tmp[1:20,]$estimate - sorted_tmp[1:20,]$sd, 
       y0=sorted_tmp[1:20,]$rank, 
       x1=sorted_tmp[1:20,]$estimate+ sorted_tmp[1:20,]$sd, 
       y1=sorted_tmp[1:20,]$rank, 
       code=3, 
       angle=90, 
       length=0.1,
       col = "gray")

```

<br/> For the top scoring pathways, below the list of the actual genes belonging to that pathway that were found in our list of differentially-expressed genes:


```{r, echo=FALSE}
#for the top pathways, print the genes that have been found amongst DE
#sorted_tmp[1:5,1] #is the colnames of GO-annotation_wide we have to extract gene codes from

#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) #find which of all pathways genes are actually those found amongst DE genes
  #print(top_table[top_table$ensembl_gene_id %in% expressed, c("FC", "adj.P.Val", "ensembl_gene_id", "description", "AveExpr", "CI.L", "CI.R")])
  print(kable(annotation_info_Ao[annotation_info_Ao$ensembl_ID %in% expressed, c("entrez_ID", "ensembl_ID", "merged_symbol", "merged_description") ], 
              caption= paste0("Genes of GO set:[",sorted_tmp[i,1],"] present amonst genes of interest")))
  
}
     
```


#### sufficient subset


```{r}
splsda.perf <- perf(basic.splsda.model) # undergo performance optimisation
plot(splsda.perf)
```

```{r}
splsda.perf$choice.ncomp
```

```{r}
# note that usually a call in the below line would be more appropriate:
optimal.ncomp <- splsda.perf$choice.ncomp["overall", "centroids.dist"]

#overwrite
optimal.ncomp <- 2
```


```{r}
splsda.tune <- tune(X = X, Y = Y, study = study,  # tune the number of features
                              ncomp = optimal.ncomp,# using optimal comp number
                              test.keepX = seq(1, 100, 1), 
                              method = 'mint.splsda', 
                              measure = 'BER', # balanced error rate
                              dist = "centroids.dist")
```

```{r}
plot(splsda.tune, sd = FALSE)

```


```{r}
optimal.keepX <- splsda.tune$choice.keepX # extract optimal values

optimal.keepX
```
```{r}
final.splsda.model <- mint.splsda(X = X, Y = Y, study = study, 
                                  ncomp = optimal.ncomp, 
                                  keepX = optimal.keepX)
```

```{r, fig.width=12, fig.height=12}
plotIndiv(final.splsda.model, study = 'global', 
          legend = TRUE,
          title = '(a) Stem cells, MINT sPLS-DA',
          subtitle = 'Global', ellipse = T)

plotIndiv(final.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```




```{r}
plotIndiv(final.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')




# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(final.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(final.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(final.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```



```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp1 != 0,])]


head(test)

```
```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp1, decreasing = T), ] 
selected_genes2 <- rownames(test)[1:20]
selected_genes2 <- c(selected_genes2, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes2 <- selected_genes2[selected_genes2 %in% rownames(test[test$comp2 != 0,])]


head(test)

```
```{r}
selected_genes <- c(selected_genes, selected_genes2)
```



```{r, fig.height=10, fig.width=15}
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```

```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp2, decreasing = T), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp2 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```

```{r, fig.height=3, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```

## Ptf Module2 signature (with Oesophagus+Stomach)
```{r, echo=FALSE}
#BiocManager::install("mixOmics")
library(mixOmics)
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/merged_metadata.rds") #merged_metadata
load("Z://01_Stefano/Collaboration_Data/Annotations/zmerged_counts.rds") #zmerged_counts


#### AVERAGE OR NOT? (comment/uncomment)
merged_counts_averaged <- data.frame(matrix(nrow=nrow(zmerged_counts),ncol=0))
group_indeces <- c(0, cumsum(unname( table(merged_metadata$segment))))
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- zmerged_counts[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  merged_counts_averaged <- cbind(merged_counts_averaged, tmp_averages)
  
}
colnames(merged_counts_averaged) <- paste0(unique(merged_metadata$segment), "_mean")
merged_counts <- merged_counts_averaged

merged_metadata_averaged <- merged_metadata
merged_metadata_averaged <- merged_metadata_averaged[!duplicated(merged_metadata_averaged$segment),]
rownames(merged_metadata_averaged) <- paste0(merged_metadata_averaged$segment, "_mean")
merged_metadata <- merged_metadata_averaged
###



# generate basic MINT pls-da model
#in mixOmics
# X = counts matrix (rows: samples, columns, genes)
# Y = vector of classes (1 per sample)
#study <- vector of different studies to be batch integrated

counts_VST_transposed <- t(merged_counts)
X <- counts_VST_transposed
#Y <- merged_metadata$segment

#what if I force similarity


#hindgut segments (expanded) in averaged dataset
Y <-  c( rep("not-transition", 1), rep("transition", 2), rep("not-transition", 4), #Ao
         rep("not-transition", 2), rep("transition", 2), rep("not-transition", 1), #Bf
         rep("not-transition", 6),  rep("transition", 2), rep("not-transition", 3), #Pf
         rep("not-transition", 2), rep("transition", 1),rep("not-transition", 6), #Sp
         rep("not-transition", 4), rep("transition", 2), rep("not-transition", 4)) #Pd


#hindgut segments (strict) in averaged dataset
#Y <-  c(rep("not-hindgut", 6), rep("hindgut", 1), #Ao
#         rep("not-hindgut", 4), rep("hindgut", 1), #Bf
#         rep("not-hindgut", 9),  rep("hindgut", 2), #Pf
#         rep("not-hindgut", 7), rep("hindgut", 2), #Sp
#         rep("not-hindgut", 9), rep("hindgut", 1)) #Pd


study <- merged_metadata$species


basic.splsda.model <- mint.splsda(X, Y, study = study, ncomp = 10) 
#basic.pls.model <- mint.pls(X, Y, study = study, ncomp = 2) 

# plot the samples
plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: hindgut vs others ', ellipse = TRUE,
          col = c("gray", "goldenrod1")) 
```
```{r, fig.height=12, fig.width=12}
plotIndiv(basic.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```


```{r}
plotIndiv(basic.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 2:3, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 3:4, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 4:5, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 5:6, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 6:7, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(basic.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(basic.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(basic.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```

```{r, echo=FALSE}
#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:200]
#selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species.rds") #shared_TFs_8species [356]
orthogroup_TFs <- shared_TFs_8species

summary(selected_genes %in% orthogroup_TFs)
selected_genes[selected_genes %in% orthogroup_TFs == T]
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")

dictionary_orthogroups_best_withHox_genebased["OG0006865",] #bhlha15
dictionary_orthogroups_best_withHox_genebased["OG0003690",] #tgif1
dictionary_orthogroups_best_withHox_genebased["OG0006699",] #polr1a
dictionary_orthogroups_best_withHox_genebased["OG0003475",] #myrf
dictionary_orthogroups_best_withHox_genebased["OG0004226",] #ptf1
```


```{r, fig.height=20, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


colors <- list(segment = c("gray90", "goldenrod1"))
names(colors[[1]]) <- unique(Y)

colAnn <- HeatmapAnnotation(segment = as.factor(Y),
                            col = colors,
                            show_legend = F,
                            show_annotation_name = F)
htmp <- Heatmap(as.matrix(counts_VST_selectedgenes),
                name= "z-score (within-species)",
                cluster_columns = F,
                column_split = merged_metadata$species,
                column_gap = rep(unit(5, "mm"),4),
                col = rev(brewer.pal(11,"RdBu")),
                top_annotation = colAnn,
                heatmap_legend_param = list(legend_direction = "horizontal", 
                                            legend_width = unit(6, "cm")
                                            )
                )
draw(htmp, 
     heatmap_legend_side="bottom",
     #annotation_legend_side="right",
     #legend_grouping = "original",
     padding = unit(c(2, 2, 2, 100), "mm")
     )
```

#### enrichment


```{r}
#replace with best gene  representative
ordered_genes <-dictionary_orthogroups_best_withHox_genebased$Ao[match(selected_genes,rownames(dictionary_orthogroups_best_withHox_genebased))]
```

```{r}
#we will need to convert to ensembl
ordered_genes_Ensembl <- annotation_info_Ao$ensembl_ID[match(ordered_genes,annotation_info_Ao$entrez_ID)]
```

```{r}
ordered_genes_Ensembl <- na.omit(ordered_genes_Ensembl) #48
```


```{r}
#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

# uncomment if not run this earlier in the code and object "ensembl" does not exist
require(biomaRt)
ensembl <- useMart('ensembl', dataset = 'aocellaris_gene_ensembl')
#tab_GO
GO_annotations <- getBM(attributes = c("ensembl_gene_id", 'namespace_1003', "go_id", "name_1006"),
                        mart = ensembl)
#only keep genes annotated for Biological Process GO terms
GO_annotations <- subset(GO_annotations, (namespace_1003 %in% "biological_process"))

#let us also add a column with the descriptions from our annotation_info file
GO_annotations$description <- annotation_info$merged_description[match(GO_annotations$ensembl_gene_id, annotation_info$ensembl_ID)]
```

```{r, fig.width=8, fig.height=8, echo=FALSE}
#but try also clusterprofiler
#Groups of genes identified by some analyses are used as input list to the mgsa function from the mgsa package13
#(with parameters restarts=3 and steps=1e7).

#The model assumes that some sets to be inferred are active and that all genes member of active sets are themselves active. Active genes are more likely to belong to the observations and inactive genes not. Fitting the model amounts to infer the probability of every set to be active given the observations.
#Classical methods analyze each set in isolation. Because sets such as biological pathways often share genes with each other, the returned list of enriched sets is usually long and redundant. In contrast, MGSA takes set overlap into account by working on all sets simultaneously and substantially reduces the number of redundant sets.

#e.g. take list of DE genes S1/S2 [== example_o]
# take list of GO terms (obtained previously) [== example_go]
#myset = new( "MgsaSets", sets=list(set1=LETTERS[1:3], set2=LETTERS[2:5]) )


#prepare table where each column is a GO:pathwayID and entries are the genes that belong to that group
GO_annotations_wide <- GO_annotations[, c("ensembl_gene_id", "go_id")]
GO_annotations_wide$id <- seq.int(nrow(GO_annotations_wide))
GO_annotations_wide <- GO_annotations_wide %>% pivot_wider(names_from = go_id, values_from = ensembl_gene_id)

#only keep GO groups with at least 4 genes and max 500
GO_annotations_wide <- GO_annotations_wide %>% select_if(~ sum(!is.na(.)) > 4 & sum(!is.na(.)) < 500)

#replace GO codes with full names so the results are easier to interpret
tmp <- GO_annotations[, c("name_1006", "go_id")]
tmp <- tmp[!duplicated(tmp),]

colnames(GO_annotations_wide) <- tmp$name_1006[tmp$go_id %in% colnames(GO_annotations_wide)]
rm(tmp)


```


```{r}
#run the mgsa function
MGSA_result = mgsa(ordered_genes_Ensembl, #this is a list of genes previously obtained during the DE analysis
                   #should maybe just take upregulated in one stage  and upregulated in the other, separatedly
                   GO_annotations_wide, 
                   restarts=5,  
                   steps=1e7)

#show the ordered list of gene sets found
setsResults(MGSA_result)[order(setsResults(MGSA_result)$estimate, decreasing = TRUE),][1:25,]
#plot(MGSA_result)

#The model have three parameters:
# α, the false positive rate i.e. the probability of an inactive gene to actually be observed;
# β, the false negative rate i.e. the probability of an active gene to actually be not observed;
# p, the prior probability for any set to be active, a typically small number ensuring sparse solutions to be inferred

#res = setsResults(MGSA_result)
#subset(res, estimate > 0.5)
```

<br/> Below, for reference, the scoring of all Gene Ontology gene sets considered, and the hyperparameters of the model ( _alpha_ , _beta_, and indirectly _p_ ):

```{r, echo=FALSE, fig.width=9, fig.height=9, warning=FALSE}
#for customisation purposes, let us try to obtain the same plots as plot(MGSA_result)

#set space for 4 plots
par(mfrow=c(2,2))

##p, alpha, beta hyperparameters of the model
## Note this is the information that would be extracted from the original bottom 3 plots

# average number of gene sets expected to be active: p* number of gene sets considered
pPost <- (pPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value)*dim(MGSA_result@setsResults)[1]
# most likely alpha parameter of the model (false positive)
pAlpha <- alphaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value
# most likely beta parameter of the model (false negative rate)
pBeta <- betaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value

title <- paste0("MGSA analysis: \n \n expected active gene sets: ",pPost,"\n alpha (false positives): ", pAlpha, "\n beta (false negatives): ",pBeta)

# TEXT
plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, title , cex=1.2)

## DOTPLOT

tmp <- data.frame(go_id = colnames(GO_annotations_wide), estimate =MGSA_result@setsResults[["estimate"]])
# sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10] #returns the index of the top 10 scoring sets

plot(seq(1:dim(tmp)[1]),
     tmp$estimate,
     xlab="",
     ylab="Posterior Probability of activation",
     #ylim=c(0,3.6),
     xaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(seq(1:dim(tmp)[1]) %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 0.3))
     )
axis(1, sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10],las=2, cex.axis=0.5, font=2, labels = colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]])
title("Posterior probabilities of activation")
abline(h=0.5,col="grey")
#text(sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], tmp$estimate[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]]-0.04, labels=colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]], cex=0.7)

#DENSITY PLOT

plot(density(tmp$estimate),
     col= "dodgerblue",
     lwd= 2,
     main="",
     xlab="Posterior probability of activation",
     ylab="Number of GO sets \n with given probability",
     #ylim=range(pretty(c(0, 1)))
     )
abline(v=0.5,col="grey")
title("Distribution of posterior activation probabilities")

#BARPLOT

sorted_tmp <- tmp
sorted_tmp$sd <- MGSA_result@setsResults[["std.error"]]
sorted_tmp$index <- seq(1:dim(sorted_tmp)[1])
sorted_tmp <- sorted_tmp[order(sorted_tmp$estimate, decreasing = TRUE),]
#sorted_tmp <- as.data.frame(sort(sorted_tmp$estimate, index.return=TRUE, decreasing=TRUE))
sorted_tmp$rank <- seq(1:dim(sorted_tmp)[1])
#colnames(sorted_tmp) <- c("estimate", "index", "rank")

plot(sorted_tmp[1:20,]$estimate,
     sorted_tmp[1:20,]$rank,
     xlab="Posterior Probability of activation \n +/- Standard Error",
     ylab="",
     #ylim=c(1,20),
     ylim = rev(range(sorted_tmp[1:20,]$rank)), #so that higher ranks (lower positions) are at the bottom
     yaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(sorted_tmp$index %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 1))
     )
axis(2, sorted_tmp[1:20,]$rank,las=2, 
     cex.axis=0.5, 
     font=2, 
     labels = colnames(GO_annotations_wide)[sorted_tmp[1:20,]$index])
title("Posterior probabilities of activation")
# Add error bars
#https://www.benjaminbell.co.uk/2019/04/how-to-add-error-bars-in-r.html
arrows(x0=sorted_tmp[1:20,]$estimate - sorted_tmp[1:20,]$sd, 
       y0=sorted_tmp[1:20,]$rank, 
       x1=sorted_tmp[1:20,]$estimate+ sorted_tmp[1:20,]$sd, 
       y1=sorted_tmp[1:20,]$rank, 
       code=3, 
       angle=90, 
       length=0.1,
       col = "gray")

```

<br/> For the top scoring pathways, below the list of the actual genes belonging to that pathway that were found in our list of differentially-expressed genes:


```{r, echo=FALSE}
#for the top pathways, print the genes that have been found amongst DE
#sorted_tmp[1:5,1] #is the colnames of GO-annotation_wide we have to extract gene codes from

#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) #find which of all pathways genes are actually those found amongst DE genes
  #print(top_table[top_table$ensembl_gene_id %in% expressed, c("FC", "adj.P.Val", "ensembl_gene_id", "description", "AveExpr", "CI.L", "CI.R")])
  print(kable(annotation_info_Ao[annotation_info_Ao$ensembl_ID %in% expressed, c("entrez_ID", "ensembl_ID", "merged_symbol", "merged_description") ], 
              caption= paste0("Genes of GO set:[",sorted_tmp[i,1],"] present amonst genes of interest")))
  
}
     
```


#### sufficient subset


```{r}
splsda.perf <- perf(basic.splsda.model) # undergo performance optimisation
plot(splsda.perf)
```
```{r}
splsda.perf$choice.ncomp
```

```{r}
# note that usually a call in the below line would be more appropriate:
optimal.ncomp <- splsda.perf$choice.ncomp["overall", "centroids.dist"]

#overwrite
optimal.ncomp <- 2
```


```{r}
splsda.tune <- tune(X = X, Y = Y, study = study,  # tune the number of features
                              ncomp = optimal.ncomp,# using optimal comp number
                              test.keepX = seq(1, 100, 1), 
                              method = 'mint.splsda', 
                              measure = 'BER', # balanced error rate
                              dist = "centroids.dist")
```

```{r}
plot(splsda.tune, sd = FALSE)

```


```{r}
optimal.keepX <- splsda.tune$choice.keepX # extract optimal values

optimal.keepX
```
```{r}
final.splsda.model <- mint.splsda(X = X, Y = Y, study = study, 
                                  ncomp = optimal.ncomp, 
                                  keepX = optimal.keepX)
```

```{r, fig.width=12, fig.height=12}
plotIndiv(final.splsda.model, study = 'global', 
          legend = TRUE,
          title = '(a) Stem cells, MINT sPLS-DA',
          subtitle = 'Global', ellipse = T)

plotIndiv(final.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```




```{r}
plotIndiv(final.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')




# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(final.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(final.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(final.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```



```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp1 != 0,])]


head(test)

```
```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp1, decreasing = T), ] 
selected_genes2 <- rownames(test)[1:20]
selected_genes2 <- c(selected_genes2, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes2 <- selected_genes2[selected_genes2 %in% rownames(test[test$comp2 != 0,])]


head(test)

```
```{r}
selected_genes <- c(selected_genes, selected_genes2)
```



```{r, fig.height=10, fig.width=15}
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```

```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp2, decreasing = T), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp2 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```

```{r, fig.height=3, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```





## Midgut
```{r, echo=FALSE}
#BiocManager::install("mixOmics")
library(mixOmics)
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/merged_metadata.rds") #merged_metadata
load("Z://01_Stefano/Collaboration_Data/Annotations/zmerged_counts.rds") #zmerged_counts


#### AVERAGE OR NOT? (comment/uncomment)
merged_counts_averaged <- data.frame(matrix(nrow=nrow(zmerged_counts),ncol=0))
group_indeces <- c(0, cumsum(unname( table(merged_metadata$segment))))
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- zmerged_counts[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  merged_counts_averaged <- cbind(merged_counts_averaged, tmp_averages)
  
}
colnames(merged_counts_averaged) <- paste0(unique(merged_metadata$segment), "_mean")
merged_counts <- merged_counts_averaged

merged_metadata_averaged <- merged_metadata
merged_metadata_averaged <- merged_metadata_averaged[!duplicated(merged_metadata_averaged$segment),]
rownames(merged_metadata_averaged) <- paste0(merged_metadata_averaged$segment, "_mean")
merged_metadata <- merged_metadata_averaged
###



# generate basic MINT pls-da model
#in mixOmics
# X = counts matrix (rows: samples, columns, genes)
# Y = vector of classes (1 per sample)
#study <- vector of different studies to be batch integrated

counts_VST_transposed <- t(merged_counts)
X <- counts_VST_transposed
#Y <- merged_metadata$segment

#what if I force similarity


#hindgut segments (expanded) in averaged dataset
Y <-  c(rep("not-midgut", 5), rep("midgut", 1), rep("not-midgut", 1), #Ao
         rep("not-midgut", 3), rep("midgut", 1), rep("not-midgut", 1), #Bf
         rep("not-midgut", 8),  rep("midgut", 2), rep("not-midgut", 1), #Pf
         rep("not-midgut", 6), rep("midgut", 2),rep("not-midgut", 1), #Sp
         rep("not-midgut", 6), rep("midgut", 2), rep("not-midgut",2)) #Pd


#hindgut segments (strict) in averaged dataset
#Y <-  c(rep("not-hindgut", 6), rep("hindgut", 1), #Ao
#         rep("not-hindgut", 4), rep("hindgut", 1), #Bf
#         rep("not-hindgut", 9),  rep("hindgut", 2), #Pf
#         rep("not-hindgut", 7), rep("hindgut", 2), #Sp
#         rep("not-hindgut", 9), rep("hindgut", 1)) #Pd


study <- merged_metadata$species


basic.splsda.model <- mint.splsda(X, Y, study = study, ncomp = 10) 
#basic.pls.model <- mint.pls(X, Y, study = study, ncomp = 2) 

# plot the samples
plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: hindgut vs others ', ellipse = TRUE,
          col = c("tan3", "gray")) 
```
```{r, fig.height=12, fig.width=12}
plotIndiv(basic.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```


```{r}
plotIndiv(basic.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 2:3, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 3:4, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 4:5, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 5:6, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 6:7, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(basic.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(basic.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(basic.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```

```{r, echo=FALSE}
#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:20]
#selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
summary(selected_genes %in% orthogroup_TFs)
selected_genes[selected_genes %in% orthogroup_TFs == T]
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")

dictionary_orthogroups_best_withHox_genebased["OG0002072",]
```


```{r, fig.height=12, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


colors <- list(segment = c("gray90", "tan3"))
names(colors[[1]]) <- unique(Y)

colAnn <- HeatmapAnnotation(segment = as.factor(Y),
                            col = colors,
                            show_legend = F,
                            show_annotation_name = F)
htmp <- Heatmap(as.matrix(counts_VST_selectedgenes),
                name= "z-score (within-species)",
                cluster_columns = F,
                column_split = merged_metadata$species,
                column_gap = rep(unit(5, "mm"),4),
                col = rev(brewer.pal(11,"RdBu")),
                top_annotation = colAnn,
                heatmap_legend_param = list(legend_direction = "horizontal", 
                                            legend_width = unit(6, "cm")
                                            )
                )
draw(htmp, 
     heatmap_legend_side="bottom",
     #annotation_legend_side="right",
     #legend_grouping = "original",
     padding = unit(c(2, 2, 2, 100), "mm")
     )
```

#### enrichment


```{r}
#replace with best gene  representative
ordered_genes <-dictionary_orthogroups_best_withHox_genebased$Ao[match(selected_genes,rownames(dictionary_orthogroups_best_withHox_genebased))]
```

```{r}
#we will need to convert to ensembl
ordered_genes_Ensembl <- annotation_info_Ao$ensembl_ID[match(ordered_genes,annotation_info_Ao$entrez_ID)]
```

```{r}
ordered_genes_Ensembl <- na.omit(ordered_genes_Ensembl) #48
```


```{r}
# uncomment if not run this earlier in the code and object "ensembl" does not exist
require(biomaRt)
ensembl <- useMart('ensembl', dataset = 'aocellaris_gene_ensembl')
#tab_GO
GO_annotations <- getBM(attributes = c("ensembl_gene_id", 'namespace_1003', "go_id", "name_1006"),
                        mart = ensembl)
#only keep genes annotated for Biological Process GO terms
GO_annotations <- subset(GO_annotations, (namespace_1003 %in% "biological_process"))

#let us also add a column with the descriptions from our annotation_info file
GO_annotations$description <- annotation_info$merged_description[match(GO_annotations$ensembl_gene_id, annotation_info$ensembl_ID)]
```

```{r, fig.width=8, fig.height=8, echo=FALSE}
#but try also clusterprofiler
#Groups of genes identified by some analyses are used as input list to the mgsa function from the mgsa package13
#(with parameters restarts=3 and steps=1e7).

#The model assumes that some sets to be inferred are active and that all genes member of active sets are themselves active. Active genes are more likely to belong to the observations and inactive genes not. Fitting the model amounts to infer the probability of every set to be active given the observations.
#Classical methods analyze each set in isolation. Because sets such as biological pathways often share genes with each other, the returned list of enriched sets is usually long and redundant. In contrast, MGSA takes set overlap into account by working on all sets simultaneously and substantially reduces the number of redundant sets.

#e.g. take list of DE genes S1/S2 [== example_o]
# take list of GO terms (obtained previously) [== example_go]
#myset = new( "MgsaSets", sets=list(set1=LETTERS[1:3], set2=LETTERS[2:5]) )


#prepare table where each column is a GO:pathwayID and entries are the genes that belong to that group
GO_annotations_wide <- GO_annotations[, c("ensembl_gene_id", "go_id")]
GO_annotations_wide$id <- seq.int(nrow(GO_annotations_wide))
GO_annotations_wide <- GO_annotations_wide %>% pivot_wider(names_from = go_id, values_from = ensembl_gene_id)

#only keep GO groups with at least 4 genes and max 500
GO_annotations_wide <- GO_annotations_wide %>% select_if(~ sum(!is.na(.)) > 4 & sum(!is.na(.)) < 500)

#replace GO codes with full names so the results are easier to interpret
tmp <- GO_annotations[, c("name_1006", "go_id")]
tmp <- tmp[!duplicated(tmp),]

colnames(GO_annotations_wide) <- tmp$name_1006[tmp$go_id %in% colnames(GO_annotations_wide)]
rm(tmp)


```


```{r}
#run the mgsa function
MGSA_result = mgsa(ordered_genes_Ensembl, #this is a list of genes previously obtained during the DE analysis
                   #should maybe just take upregulated in one stage  and upregulated in the other, separatedly
                   GO_annotations_wide, 
                   restarts=5,  
                   steps=1e7)

#show the ordered list of gene sets found
setsResults(MGSA_result)[order(setsResults(MGSA_result)$estimate, decreasing = TRUE),][1:25,]
#plot(MGSA_result)

#The model have three parameters:
# α, the false positive rate i.e. the probability of an inactive gene to actually be observed;
# β, the false negative rate i.e. the probability of an active gene to actually be not observed;
# p, the prior probability for any set to be active, a typically small number ensuring sparse solutions to be inferred

#res = setsResults(MGSA_result)
#subset(res, estimate > 0.5)
```

<br/> Below, for reference, the scoring of all Gene Ontology gene sets considered, and the hyperparameters of the model ( _alpha_ , _beta_, and indirectly _p_ ):

```{r, echo=FALSE, fig.width=9, fig.height=9, warning=FALSE}
#for customisation purposes, let us try to obtain the same plots as plot(MGSA_result)

#set space for 4 plots
par(mfrow=c(2,2))

##p, alpha, beta hyperparameters of the model
## Note this is the information that would be extracted from the original bottom 3 plots

# average number of gene sets expected to be active: p* number of gene sets considered
pPost <- (pPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value)*dim(MGSA_result@setsResults)[1]
# most likely alpha parameter of the model (false positive)
pAlpha <- alphaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value
# most likely beta parameter of the model (false negative rate)
pBeta <- betaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value

title <- paste0("MGSA analysis: \n \n expected active gene sets: ",pPost,"\n alpha (false positives): ", pAlpha, "\n beta (false negatives): ",pBeta)

# TEXT
plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, title , cex=1.2)

## DOTPLOT

tmp <- data.frame(go_id = colnames(GO_annotations_wide), estimate =MGSA_result@setsResults[["estimate"]])
# sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10] #returns the index of the top 10 scoring sets

plot(seq(1:dim(tmp)[1]),
     tmp$estimate,
     xlab="",
     ylab="Posterior Probability of activation",
     #ylim=c(0,3.6),
     xaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(seq(1:dim(tmp)[1]) %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 0.3))
     )
axis(1, sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10],las=2, cex.axis=0.5, font=2, labels = colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]])
title("Posterior probabilities of activation")
abline(h=0.5,col="grey")
#text(sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], tmp$estimate[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]]-0.04, labels=colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]], cex=0.7)

#DENSITY PLOT

plot(density(tmp$estimate),
     col= "dodgerblue",
     lwd= 2,
     main="",
     xlab="Posterior probability of activation",
     ylab="Number of GO sets \n with given probability",
     #ylim=range(pretty(c(0, 1)))
     )
abline(v=0.5,col="grey")
title("Distribution of posterior activation probabilities")

#BARPLOT

sorted_tmp <- tmp
sorted_tmp$sd <- MGSA_result@setsResults[["std.error"]]
sorted_tmp$index <- seq(1:dim(sorted_tmp)[1])
sorted_tmp <- sorted_tmp[order(sorted_tmp$estimate, decreasing = TRUE),]
#sorted_tmp <- as.data.frame(sort(sorted_tmp$estimate, index.return=TRUE, decreasing=TRUE))
sorted_tmp$rank <- seq(1:dim(sorted_tmp)[1])
#colnames(sorted_tmp) <- c("estimate", "index", "rank")

plot(sorted_tmp[1:20,]$estimate,
     sorted_tmp[1:20,]$rank,
     xlab="Posterior Probability of activation \n +/- Standard Error",
     ylab="",
     #ylim=c(1,20),
     ylim = rev(range(sorted_tmp[1:20,]$rank)), #so that higher ranks (lower positions) are at the bottom
     yaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(sorted_tmp$index %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 1))
     )
axis(2, sorted_tmp[1:20,]$rank,las=2, 
     cex.axis=0.5, 
     font=2, 
     labels = colnames(GO_annotations_wide)[sorted_tmp[1:20,]$index])
title("Posterior probabilities of activation")
# Add error bars
#https://www.benjaminbell.co.uk/2019/04/how-to-add-error-bars-in-r.html
arrows(x0=sorted_tmp[1:20,]$estimate - sorted_tmp[1:20,]$sd, 
       y0=sorted_tmp[1:20,]$rank, 
       x1=sorted_tmp[1:20,]$estimate+ sorted_tmp[1:20,]$sd, 
       y1=sorted_tmp[1:20,]$rank, 
       code=3, 
       angle=90, 
       length=0.1,
       col = "gray")

```

<br/> For the top scoring pathways, below the list of the actual genes belonging to that pathway that were found in our list of differentially-expressed genes:


```{r, echo=FALSE}
#for the top pathways, print the genes that have been found amongst DE
#sorted_tmp[1:5,1] #is the colnames of GO-annotation_wide we have to extract gene codes from

#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) #find which of all pathways genes are actually those found amongst DE genes
  #print(top_table[top_table$ensembl_gene_id %in% expressed, c("FC", "adj.P.Val", "ensembl_gene_id", "description", "AveExpr", "CI.L", "CI.R")])
  print(kable(annotation_info_Ao[annotation_info_Ao$ensembl_ID %in% expressed, c("entrez_ID", "ensembl_ID", "merged_symbol", "merged_description") ], 
              caption= paste0("Genes of GO set:[",sorted_tmp[i,1],"] present amonst genes of interest")))
  
}
     
```
```{r,fig.width=10, fig.height=10}





#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) 
  
  expressed <- annotation_info_Ao$entrez_ID[match(expressed,annotation_info_Ao$ensembl_ID)]
expressed_OG <- rownames(dictionary_orthogroups_best_withHox_genebased[match(expressed,dictionary_orthogroups_best_withHox_genebased$Ao),])

#counts_VST_tmp <- counts_VST_selectedgenes[rownames(counts_VST_selectedgenes) %in% expressed_OG,]

counts_VST_tmp <- zmerged_counts_all[rownames(zmerged_counts_all) %in% expressed_OG,]



rownames(counts_VST_tmp) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_tmp) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
rownames(counts_VST_tmp) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_tmp) ,annotation_info_Ao$entrez_ID)] 



htmp <- Heatmap(as.matrix(counts_VST_tmp),
                column_title = paste0("GO set:[",sorted_tmp[i,1],"]"),
        cluster_columns = F,
        column_split = merged_metadata_all$species,
        col = rev(brewer.pal(11,"RdBu"))
        )

plot(htmp)
  
  
}


```












#### continue



```{r}
splsda.perf <- perf(basic.splsda.model) # undergo performance optimisation
plot(splsda.perf)
```
```{r}
splsda.perf$choice.ncomp
```

```{r}
# note that usually a call in the below line would be more appropriate:
optimal.ncomp <- splsda.perf$choice.ncomp["overall", "centroids.dist"]

#overwrite
optimal.ncomp <- 2
```


```{r}
splsda.tune <- tune(X = X, Y = Y, study = study,  # tune the number of features
                              ncomp = optimal.ncomp,# using optimal comp number
                              test.keepX = seq(1, 100, 1), 
                              method = 'mint.splsda', 
                              measure = 'BER', # balanced error rate
                              dist = "centroids.dist")
```

```{r}
plot(splsda.tune, sd = FALSE)

```


```{r}
optimal.keepX <- splsda.tune$choice.keepX # extract optimal values

optimal.keepX
```
```{r}
final.splsda.model <- mint.splsda(X = X, Y = Y, study = study, 
                                  ncomp = optimal.ncomp, 
                                  keepX = optimal.keepX)
```

```{r, fig.width=12, fig.height=12}
plotIndiv(final.splsda.model, study = 'global', 
          legend = TRUE,
          title = '(a) Stem cells, MINT sPLS-DA',
          subtitle = 'Global', ellipse = T)

plotIndiv(final.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```




```{r}
plotIndiv(final.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')




# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(final.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(final.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(final.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```



```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp1, decreasing = T), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp1 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
dictionary_orthogroups_best_withHox_genebased["OG0008865",]
```


```{r, fig.height=10, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```

```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp2, decreasing = F), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp2 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```

```{r}
dictionary_orthogroups_best_withHox_genebased["OG0002704",]
```


```{r, fig.height=10, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```




## Midgut (with Bf gills)
```{r, echo=FALSE}
#BiocManager::install("mixOmics")
library(mixOmics)
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/merged_metadata.rds") #merged_metadata
load("Z://01_Stefano/Collaboration_Data/Annotations/zmerged_counts.rds") #zmerged_counts


#### AVERAGE OR NOT? (comment/uncomment)
merged_counts_averaged <- data.frame(matrix(nrow=nrow(zmerged_counts),ncol=0))
group_indeces <- c(0, cumsum(unname( table(merged_metadata$segment))))
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- zmerged_counts[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  merged_counts_averaged <- cbind(merged_counts_averaged, tmp_averages)
  
}
colnames(merged_counts_averaged) <- paste0(unique(merged_metadata$segment), "_mean")
merged_counts <- merged_counts_averaged

merged_metadata_averaged <- merged_metadata
merged_metadata_averaged <- merged_metadata_averaged[!duplicated(merged_metadata_averaged$segment),]
rownames(merged_metadata_averaged) <- paste0(merged_metadata_averaged$segment, "_mean")
merged_metadata <- merged_metadata_averaged
###



# generate basic MINT pls-da model
#in mixOmics
# X = counts matrix (rows: samples, columns, genes)
# Y = vector of classes (1 per sample)
#study <- vector of different studies to be batch integrated

counts_VST_transposed <- t(merged_counts)
X <- counts_VST_transposed
#Y <- merged_metadata$segment

#what if I force similarity


#hindgut segments (expanded) in averaged dataset
Y <-  c(rep("not-midgut", 5), rep("midgut", 1), rep("not-midgut", 1), #Ao
         rep("not-midgut", 1), rep("midgut", 1), rep("not-midgut", 3), #Bf
         rep("not-midgut", 8),  rep("midgut", 2), rep("not-midgut", 1), #Pf
         rep("not-midgut", 6), rep("midgut", 2),rep("not-midgut", 1), #Sp
         rep("not-midgut", 6), rep("midgut", 2), rep("not-midgut",2)) #Pd


#hindgut segments (strict) in averaged dataset
#Y <-  c(rep("not-hindgut", 6), rep("hindgut", 1), #Ao
#         rep("not-hindgut", 4), rep("hindgut", 1), #Bf
#         rep("not-hindgut", 9),  rep("hindgut", 2), #Pf
#         rep("not-hindgut", 7), rep("hindgut", 2), #Sp
#         rep("not-hindgut", 9), rep("hindgut", 1)) #Pd


study <- merged_metadata$species


basic.splsda.model <- mint.splsda(X, Y, study = study, ncomp = 10) 
#basic.pls.model <- mint.pls(X, Y, study = study, ncomp = 2) 

# plot the samples
plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: hindgut vs others ', ellipse = TRUE,
          col = c("tan3", "gray")) 
```

```{r}
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/MINTsPLS_module3_PCA.pdf")

plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: hindgut vs others ', ellipse = TRUE,
          col = c("tan3", "gray")) 

dev.off()
```

```{r, fig.height=12, fig.width=12}
plotIndiv(basic.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```


```{r}
plotIndiv(basic.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 2:3, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 3:4, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 4:5, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 5:6, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 6:7, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(basic.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(basic.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(basic.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```

```{r, echo=FALSE}
#plot these genes
test <- test[order(test$comp1, decreasing = T), ] 
selected_genes <- rownames(test)[1:10]
#selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species.rds") #shared_TFs_8species [356]
orthogroup_TFs <- shared_TFs_8species


summary(selected_genes %in% orthogroup_TFs)
selected_genes[selected_genes %in% orthogroup_TFs == T]
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")

dictionary_orthogroups_best_withHox_genebased["OG0000765",] #jun2
dictionary_orthogroups_best_withHox_genebased["OG0003669",] #mlxip
dictionary_orthogroups_best_withHox_genebased["OG0002690",] #pknox1.1
dictionary_orthogroups_best_withHox_genebased["OG000PG0607",] #hox pg06/7
dictionary_orthogroups_best_withHox_genebased["OG0002781",] #zfp36l1a
dictionary_orthogroups_best_withHox_genebased["OG0001668",] #ncoa2

dictionary_orthogroups_best_withHox_genebased["OG0004325",] #kctd10
dictionary_orthogroups_best_withHox_genebased["OG0001855",] #mideasb
dictionary_orthogroups_best_withHox_genebased["OG0002486",] #atf7a
dictionary_orthogroups_best_withHox_genebased["OG0004554",] #klf13
dictionary_orthogroups_best_withHox_genebased["OG0001639",] #foxo3b
dictionary_orthogroups_best_withHox_genebased["OG0003194",] #nr5a2
dictionary_orthogroups_best_withHox_genebased["OG0001322",] #tfe3b

```


```{r, fig.height=8, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


colors <- list(segment = c("gray90", "tan3"))
names(colors[[1]]) <- unique(Y)

colAnn <- HeatmapAnnotation(segment = as.factor(Y),
                            col = colors,
                            show_legend = F,
                            show_annotation_name = F)
htmp <- Heatmap(as.matrix(counts_VST_selectedgenes),
                name= "z-score (within-species)",
                cluster_columns = F,
                column_split = factor(merged_metadata$species, levels = c("Pd", "Sp", "Pf", "Bf", "Ao")),
                column_gap = rep(unit(5, "mm"),4),
                col = rev(brewer.pal(11,"RdBu")),
                top_annotation = colAnn,
                heatmap_legend_param = list(legend_direction = "horizontal", 
                                            legend_width = unit(6, "cm")
                                            )
                )
draw(htmp, 
     heatmap_legend_side="bottom",
     #annotation_legend_side="right",
     #legend_grouping = "original",
     padding = unit(c(2, 2, 2, 100), "mm")
     )
```

```{r}
#pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/MINTsPLS_module3_heatmap_top25.pdf")
pdf(file="Z://01_Stefano/Collaboration_Data/Figure_elements/MINTsPLS_module3_heatmap_top10.pdf")

draw(htmp, 
     heatmap_legend_side="bottom"
     ) 

dev.off()
```
```{r, echo=FALSE}
#plot these genes
test <- test[order(test$comp1, decreasing = T), ] 
selected_genes <- rownames(test)[1:50]
#selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species.rds") #shared_TFs_8species [356]
orthogroup_TFs <- shared_TFs_8species


summary(selected_genes %in% orthogroup_TFs)
selected_genes[selected_genes %in% orthogroup_TFs == T]
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Best_orthologue_all_orthogroups/dictionary_orthogroups_best_all_withHox_genebased.rds")

dictionary_orthogroups_best_withHox_genebased["OG0000765",] #jun2
dictionary_orthogroups_best_withHox_genebased["OG0003669",] #mlxip
dictionary_orthogroups_best_withHox_genebased["OG0002690",] #pknox1.1
dictionary_orthogroups_best_withHox_genebased["OG000PG0607",] #hox pg06/7
dictionary_orthogroups_best_withHox_genebased["OG0002781",] #zfp36l1a
dictionary_orthogroups_best_withHox_genebased["OG0001668",] #ncoa2

dictionary_orthogroups_best_withHox_genebased["OG0004325",] #kctd10
dictionary_orthogroups_best_withHox_genebased["OG0001855",] #mideasb
dictionary_orthogroups_best_withHox_genebased["OG0002486",] #atf7a
dictionary_orthogroups_best_withHox_genebased["OG0004554",] #klf13
dictionary_orthogroups_best_withHox_genebased["OG0001639",] #foxo3b
dictionary_orthogroups_best_withHox_genebased["OG0003194",] #nr5a2
dictionary_orthogroups_best_withHox_genebased["OG0001322",] #tfe3b

```


```{r, fig.height=14, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


colors <- list(segment = c("gray90", "tan3"))
names(colors[[1]]) <- unique(Y)

colAnn <- HeatmapAnnotation(segment = as.factor(Y),
                            col = colors,
                            show_legend = F,
                            show_annotation_name = F)
htmp <- Heatmap(as.matrix(counts_VST_selectedgenes),
                name= "z-score (within-species)",
                cluster_columns = F,
                column_split = factor(merged_metadata$species, levels = c("Pd", "Sp", "Pf", "Bf", "Ao")),
                column_gap = rep(unit(5, "mm"),4),
                col = rev(brewer.pal(11,"RdBu")),
                top_annotation = colAnn,
                heatmap_legend_param = list(legend_direction = "horizontal", 
                                            legend_width = unit(6, "cm")
                                            )
                )
draw(htmp, 
     heatmap_legend_side="bottom",
     #annotation_legend_side="right",
     #legend_grouping = "original",
     padding = unit(c(2, 2, 2, 100), "mm")
     )
```









#### enrichment


```{r}
#replace with best gene  representative
ordered_genes <-dictionary_orthogroups_best_withHox_genebased$Ao[match(selected_genes,rownames(dictionary_orthogroups_best_withHox_genebased))]
```

```{r}
#we will need to convert to ensembl
ordered_genes_Ensembl <- annotation_info_Ao$ensembl_ID[match(ordered_genes,annotation_info_Ao$entrez_ID)]
```

```{r}
ordered_genes_Ensembl <- na.omit(ordered_genes_Ensembl) #48
```


```{r}
# uncomment if not run this earlier in the code and object "ensembl" does not exist
require(biomaRt)
ensembl <- useMart('ensembl', dataset = 'aocellaris_gene_ensembl')
#tab_GO
GO_annotations <- getBM(attributes = c("ensembl_gene_id", 'namespace_1003', "go_id", "name_1006"),
                        mart = ensembl)
#only keep genes annotated for Biological Process GO terms
GO_annotations <- subset(GO_annotations, (namespace_1003 %in% "biological_process"))

#let us also add a column with the descriptions from our annotation_info file
GO_annotations$description <- annotation_info$merged_description[match(GO_annotations$ensembl_gene_id, annotation_info$ensembl_ID)]
```

```{r, fig.width=8, fig.height=8, echo=FALSE}
#but try also clusterprofiler
#Groups of genes identified by some analyses are used as input list to the mgsa function from the mgsa package13
#(with parameters restarts=3 and steps=1e7).

#The model assumes that some sets to be inferred are active and that all genes member of active sets are themselves active. Active genes are more likely to belong to the observations and inactive genes not. Fitting the model amounts to infer the probability of every set to be active given the observations.
#Classical methods analyze each set in isolation. Because sets such as biological pathways often share genes with each other, the returned list of enriched sets is usually long and redundant. In contrast, MGSA takes set overlap into account by working on all sets simultaneously and substantially reduces the number of redundant sets.

#e.g. take list of DE genes S1/S2 [== example_o]
# take list of GO terms (obtained previously) [== example_go]
#myset = new( "MgsaSets", sets=list(set1=LETTERS[1:3], set2=LETTERS[2:5]) )


#prepare table where each column is a GO:pathwayID and entries are the genes that belong to that group
GO_annotations_wide <- GO_annotations[, c("ensembl_gene_id", "go_id")]
GO_annotations_wide$id <- seq.int(nrow(GO_annotations_wide))
GO_annotations_wide <- GO_annotations_wide %>% pivot_wider(names_from = go_id, values_from = ensembl_gene_id)

#only keep GO groups with at least 4 genes and max 500
GO_annotations_wide <- GO_annotations_wide %>% select_if(~ sum(!is.na(.)) > 4 & sum(!is.na(.)) < 500)

#replace GO codes with full names so the results are easier to interpret
tmp <- GO_annotations[, c("name_1006", "go_id")]
tmp <- tmp[!duplicated(tmp),]

colnames(GO_annotations_wide) <- tmp$name_1006[tmp$go_id %in% colnames(GO_annotations_wide)]
rm(tmp)


```


```{r}
#run the mgsa function
MGSA_result = mgsa(ordered_genes_Ensembl, #this is a list of genes previously obtained during the DE analysis
                   #should maybe just take upregulated in one stage  and upregulated in the other, separatedly
                   GO_annotations_wide, 
                   restarts=5,  
                   steps=1e7)

#show the ordered list of gene sets found
setsResults(MGSA_result)[order(setsResults(MGSA_result)$estimate, decreasing = TRUE),][1:25,]
#plot(MGSA_result)

#The model have three parameters:
# α, the false positive rate i.e. the probability of an inactive gene to actually be observed;
# β, the false negative rate i.e. the probability of an active gene to actually be not observed;
# p, the prior probability for any set to be active, a typically small number ensuring sparse solutions to be inferred

#res = setsResults(MGSA_result)
#subset(res, estimate > 0.5)
```

<br/> Below, for reference, the scoring of all Gene Ontology gene sets considered, and the hyperparameters of the model ( _alpha_ , _beta_, and indirectly _p_ ):

```{r, echo=FALSE, fig.width=9, fig.height=9, warning=FALSE}
#for customisation purposes, let us try to obtain the same plots as plot(MGSA_result)

#set space for 4 plots
par(mfrow=c(2,2))

##p, alpha, beta hyperparameters of the model
## Note this is the information that would be extracted from the original bottom 3 plots

# average number of gene sets expected to be active: p* number of gene sets considered
pPost <- (pPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value)*dim(MGSA_result@setsResults)[1]
# most likely alpha parameter of the model (false positive)
pAlpha <- alphaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value
# most likely beta parameter of the model (false negative rate)
pBeta <- betaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value

title <- paste0("MGSA analysis: \n \n expected active gene sets: ",pPost,"\n alpha (false positives): ", pAlpha, "\n beta (false negatives): ",pBeta)

# TEXT
plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, title , cex=1.2)

## DOTPLOT

tmp <- data.frame(go_id = colnames(GO_annotations_wide), estimate =MGSA_result@setsResults[["estimate"]])
# sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10] #returns the index of the top 10 scoring sets

plot(seq(1:dim(tmp)[1]),
     tmp$estimate,
     xlab="",
     ylab="Posterior Probability of activation",
     #ylim=c(0,3.6),
     xaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(seq(1:dim(tmp)[1]) %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 0.3))
     )
axis(1, sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10],las=2, cex.axis=0.5, font=2, labels = colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]])
title("Posterior probabilities of activation")
abline(h=0.5,col="grey")
#text(sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], tmp$estimate[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]]-0.04, labels=colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]], cex=0.7)

#DENSITY PLOT

plot(density(tmp$estimate),
     col= "dodgerblue",
     lwd= 2,
     main="",
     xlab="Posterior probability of activation",
     ylab="Number of GO sets \n with given probability",
     #ylim=range(pretty(c(0, 1)))
     )
abline(v=0.5,col="grey")
title("Distribution of posterior activation probabilities")

#BARPLOT

sorted_tmp <- tmp
sorted_tmp$sd <- MGSA_result@setsResults[["std.error"]]
sorted_tmp$index <- seq(1:dim(sorted_tmp)[1])
sorted_tmp <- sorted_tmp[order(sorted_tmp$estimate, decreasing = TRUE),]
#sorted_tmp <- as.data.frame(sort(sorted_tmp$estimate, index.return=TRUE, decreasing=TRUE))
sorted_tmp$rank <- seq(1:dim(sorted_tmp)[1])
#colnames(sorted_tmp) <- c("estimate", "index", "rank")

plot(sorted_tmp[1:20,]$estimate,
     sorted_tmp[1:20,]$rank,
     xlab="Posterior Probability of activation \n +/- Standard Error",
     ylab="",
     #ylim=c(1,20),
     ylim = rev(range(sorted_tmp[1:20,]$rank)), #so that higher ranks (lower positions) are at the bottom
     yaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(sorted_tmp$index %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 1))
     )
axis(2, sorted_tmp[1:20,]$rank,las=2, 
     cex.axis=0.5, 
     font=2, 
     labels = colnames(GO_annotations_wide)[sorted_tmp[1:20,]$index])
title("Posterior probabilities of activation")
# Add error bars
#https://www.benjaminbell.co.uk/2019/04/how-to-add-error-bars-in-r.html
arrows(x0=sorted_tmp[1:20,]$estimate - sorted_tmp[1:20,]$sd, 
       y0=sorted_tmp[1:20,]$rank, 
       x1=sorted_tmp[1:20,]$estimate+ sorted_tmp[1:20,]$sd, 
       y1=sorted_tmp[1:20,]$rank, 
       code=3, 
       angle=90, 
       length=0.1,
       col = "gray")

```

<br/> For the top scoring pathways, below the list of the actual genes belonging to that pathway that were found in our list of differentially-expressed genes:


```{r, echo=FALSE}
#for the top pathways, print the genes that have been found amongst DE
#sorted_tmp[1:5,1] #is the colnames of GO-annotation_wide we have to extract gene codes from

#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) #find which of all pathways genes are actually those found amongst DE genes
  #print(top_table[top_table$ensembl_gene_id %in% expressed, c("FC", "adj.P.Val", "ensembl_gene_id", "description", "AveExpr", "CI.L", "CI.R")])
  print(kable(annotation_info_Ao[annotation_info_Ao$ensembl_ID %in% expressed, c("entrez_ID", "ensembl_ID", "merged_symbol", "merged_description") ], 
              caption= paste0("Genes of GO set:[",sorted_tmp[i,1],"] present amonst genes of interest")))
  
}
     
```
```{r,fig.width=10, fig.height=10}





#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) 
  
  expressed <- annotation_info_Ao$entrez_ID[match(expressed,annotation_info_Ao$ensembl_ID)]
expressed_OG <- rownames(dictionary_orthogroups_best_withHox_genebased[match(expressed,dictionary_orthogroups_best_withHox_genebased$Ao),])

#counts_VST_tmp <- counts_VST_selectedgenes[rownames(counts_VST_selectedgenes) %in% expressed_OG,]

counts_VST_tmp <- zmerged_counts_all[rownames(zmerged_counts_all) %in% expressed_OG,]



rownames(counts_VST_tmp) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_tmp) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
rownames(counts_VST_tmp) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_tmp) ,annotation_info_Ao$entrez_ID)] 



htmp <- Heatmap(as.matrix(counts_VST_tmp),
                column_title = paste0("GO set:[",sorted_tmp[i,1],"]"),
        cluster_columns = F,
        column_split = merged_metadata_all$species,
        col = rev(brewer.pal(11,"RdBu"))
        )

plot(htmp)
  
  
}


```












#### continue



```{r}
splsda.perf <- perf(basic.splsda.model) # undergo performance optimisation
plot(splsda.perf)
```
```{r}
splsda.perf$choice.ncomp
```

```{r}
# note that usually a call in the below line would be more appropriate:
optimal.ncomp <- splsda.perf$choice.ncomp["overall", "centroids.dist"]

#overwrite
optimal.ncomp <- 2
```


```{r}
splsda.tune <- tune(X = X, Y = Y, study = study,  # tune the number of features
                              ncomp = optimal.ncomp,# using optimal comp number
                              test.keepX = seq(1, 100, 1), 
                              method = 'mint.splsda', 
                              measure = 'BER', # balanced error rate
                              dist = "centroids.dist")
```

```{r}
plot(splsda.tune, sd = FALSE)

```


```{r}
optimal.keepX <- splsda.tune$choice.keepX # extract optimal values

optimal.keepX
```
```{r}
final.splsda.model <- mint.splsda(X = X, Y = Y, study = study, 
                                  ncomp = optimal.ncomp, 
                                  keepX = optimal.keepX)
```

```{r, fig.width=12, fig.height=12}
plotIndiv(final.splsda.model, study = 'global', 
          legend = TRUE,
          title = '(a) Stem cells, MINT sPLS-DA',
          subtitle = 'Global', ellipse = T)

plotIndiv(final.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```




```{r}
plotIndiv(final.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')




# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(final.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(final.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(final.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```



```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp1, decreasing = T), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp1 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}
dictionary_orthogroups_best_withHox_genebased["OG0008865",]
```


```{r, fig.height=10, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```

```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp2, decreasing = F), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp2 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```

```{r}
dictionary_orthogroups_best_withHox_genebased["OG0002704",]
```


```{r, fig.height=10, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```


## Exocrine pancreas signature
```{r, echo=FALSE}
#BiocManager::install("mixOmics")
library(mixOmics)
```


```{r}
load("Z://01_Stefano/Collaboration_Data/Annotations/Dictionaries_standard/merged_metadata.rds") #merged_metadata
load("Z://01_Stefano/Collaboration_Data/Annotations/zmerged_counts.rds") #zmerged_counts


#### AVERAGE OR NOT? (comment/uncomment)
merged_counts_averaged <- data.frame(matrix(nrow=nrow(zmerged_counts),ncol=0))
group_indeces <- c(0, cumsum(unname( table(merged_metadata$segment))))
for (i in seq(1:(length(group_indeces)-1))) {
  #print(i)
  #print(paste0(i, "->" ,(group_indeces[i]+1),"_" ,group_indeces[i+1]))
  tmp <- zmerged_counts[,(group_indeces[i]+1):group_indeces[i+1]]
  
  tmp_averages <- rowMeans(tmp)
  merged_counts_averaged <- cbind(merged_counts_averaged, tmp_averages)
  
}
colnames(merged_counts_averaged) <- paste0(unique(merged_metadata$segment), "_mean")
merged_counts <- merged_counts_averaged

merged_metadata_averaged <- merged_metadata
merged_metadata_averaged <- merged_metadata_averaged[!duplicated(merged_metadata_averaged$segment),]
rownames(merged_metadata_averaged) <- paste0(merged_metadata_averaged$segment, "_mean")
merged_metadata <- merged_metadata_averaged
###



# generate basic MINT pls-da model
#in mixOmics
# X = counts matrix (rows: samples, columns, genes)
# Y = vector of classes (1 per sample)
#study <- vector of different studies to be batch integrated

counts_VST_transposed <- t(merged_counts)
X <- counts_VST_transposed
#Y <- merged_metadata$segment

#what if I force similarity


#hindgut segments (expanded) in averaged dataset
Y <-  c( rep("not-exocrine", 1),rep("exocrine", 2), rep("not-exocrine", 4), #Ao
         rep("not-exocrine", 2), rep("exocrine", 1), rep("not-exocrine", 2), #Bf
         rep("not-exocrine", 6),  rep("exocrine", 2), rep("not-exocrine", 3), #Pf
         rep("not-exocrine", 2), rep("exocrine", 1),rep("not-exocrine", 6), #Sp
         rep("not-exocrine", 2), rep("exocrine", 2),  rep("not-exocrine", 6)) #Pd


#hindgut segments (strict) in averaged dataset
#Y <-  c(rep("not-hindgut", 6), rep("hindgut", 1), #Ao
#         rep("not-hindgut", 4), rep("hindgut", 1), #Bf
#         rep("not-hindgut", 9),  rep("hindgut", 2), #Pf
#         rep("not-hindgut", 7), rep("hindgut", 2), #Sp
#         rep("not-hindgut", 9), rep("hindgut", 1)) #Pd


study <- merged_metadata$species


basic.splsda.model <- mint.splsda(X, Y, study = study, ncomp = 10) 
#basic.pls.model <- mint.pls(X, Y, study = study, ncomp = 2) 

# plot the samples
plotIndiv(basic.splsda.model, legend = TRUE, 
          title = '', subtitle = 'MINT sPLS-DA: hindgut vs others ', ellipse = TRUE,
          col = c("darkseagreen", "gray")) 
```
```{r, fig.height=12, fig.width=12}
plotIndiv(basic.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```


```{r}
plotIndiv(basic.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 2:3, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 3:4, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 4:5, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 5:6, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

plotIndiv(basic.splsda.model , 
          comp = 6:7, 
          group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')

# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(basic.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(basic.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(basic.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```

```{r, echo=FALSE}
#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:50]
#selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```
```{r}

load("Z://01_Stefano/Collaboration_Data/Annotations/TFs/shared_TFs_8species.rds") #shared_TFs_8species [356]
orthogroup_TFs <- shared_TFs_8species

summary(selected_genes %in% orthogroup_TFs)
selected_genes[selected_genes %in% orthogroup_TFs == T]
```





```{r, fig.height=15, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


colors <- list(segment = c("gray90", "darkseagreen"))
names(colors[[1]]) <- unique(Y)

colAnn <- HeatmapAnnotation(segment = as.factor(Y),
                            col = colors,
                            show_legend = F,
                            show_annotation_name = F)
htmp <- Heatmap(as.matrix(counts_VST_selectedgenes),
                name= "z-score (within-species)",
                cluster_columns = F,
                column_split = factor(merged_metadata$species, levels= c("Pd", "Sp", "Pf", "Bf", "Ao")),
                column_gap = rep(unit(5, "mm"),4),
                col = rev(brewer.pal(11,"RdBu")),
                top_annotation = colAnn,
                heatmap_legend_param = list(legend_direction = "horizontal", 
                                            legend_width = unit(6, "cm")
                                            )
                )
draw(htmp, 
     heatmap_legend_side="bottom",
     #annotation_legend_side="right",
     #legend_grouping = "original",
     padding = unit(c(2, 2, 2, 100), "mm")
     )
```

#### enrichment


```{r}
#replace with best gene  representative
ordered_genes <-dictionary_orthogroups_best_withHox_genebased$Ao[match(selected_genes,rownames(dictionary_orthogroups_best_withHox_genebased))]
```

```{r}
#we will need to convert to ensembl
ordered_genes_Ensembl <- annotation_info_Ao$ensembl_ID[match(ordered_genes,annotation_info_Ao$entrez_ID)]
```

```{r}
ordered_genes_Ensembl <- na.omit(ordered_genes_Ensembl) #48
```


```{r}
#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

# uncomment if not run this earlier in the code and object "ensembl" does not exist
require(biomaRt)
ensembl <- useMart('ensembl', dataset = 'aocellaris_gene_ensembl')
#tab_GO
GO_annotations <- getBM(attributes = c("ensembl_gene_id", 'namespace_1003', "go_id", "name_1006"),
                        mart = ensembl)
#only keep genes annotated for Biological Process GO terms
GO_annotations <- subset(GO_annotations, (namespace_1003 %in% "biological_process"))

#let us also add a column with the descriptions from our annotation_info file
GO_annotations$description <- annotation_info$merged_description[match(GO_annotations$ensembl_gene_id, annotation_info$ensembl_ID)]
```

```{r, fig.width=8, fig.height=8, echo=FALSE}
#but try also clusterprofiler
#Groups of genes identified by some analyses are used as input list to the mgsa function from the mgsa package13
#(with parameters restarts=3 and steps=1e7).

#The model assumes that some sets to be inferred are active and that all genes member of active sets are themselves active. Active genes are more likely to belong to the observations and inactive genes not. Fitting the model amounts to infer the probability of every set to be active given the observations.
#Classical methods analyze each set in isolation. Because sets such as biological pathways often share genes with each other, the returned list of enriched sets is usually long and redundant. In contrast, MGSA takes set overlap into account by working on all sets simultaneously and substantially reduces the number of redundant sets.

#e.g. take list of DE genes S1/S2 [== example_o]
# take list of GO terms (obtained previously) [== example_go]
#myset = new( "MgsaSets", sets=list(set1=LETTERS[1:3], set2=LETTERS[2:5]) )


#prepare table where each column is a GO:pathwayID and entries are the genes that belong to that group
GO_annotations_wide <- GO_annotations[, c("ensembl_gene_id", "go_id")]
GO_annotations_wide$id <- seq.int(nrow(GO_annotations_wide))
GO_annotations_wide <- GO_annotations_wide %>% pivot_wider(names_from = go_id, values_from = ensembl_gene_id)

#only keep GO groups with at least 4 genes and max 500
GO_annotations_wide <- GO_annotations_wide %>% select_if(~ sum(!is.na(.)) > 4 & sum(!is.na(.)) < 500)

#replace GO codes with full names so the results are easier to interpret
tmp <- GO_annotations[, c("name_1006", "go_id")]
tmp <- tmp[!duplicated(tmp),]

colnames(GO_annotations_wide) <- tmp$name_1006[tmp$go_id %in% colnames(GO_annotations_wide)]
rm(tmp)


```


```{r}
#run the mgsa function
MGSA_result = mgsa(ordered_genes_Ensembl, #this is a list of genes previously obtained during the DE analysis
                   #should maybe just take upregulated in one stage  and upregulated in the other, separatedly
                   GO_annotations_wide, 
                   restarts=5,  
                   steps=1e7)

#show the ordered list of gene sets found
setsResults(MGSA_result)[order(setsResults(MGSA_result)$estimate, decreasing = TRUE),][1:25,]
#plot(MGSA_result)

#The model have three parameters:
# α, the false positive rate i.e. the probability of an inactive gene to actually be observed;
# β, the false negative rate i.e. the probability of an active gene to actually be not observed;
# p, the prior probability for any set to be active, a typically small number ensuring sparse solutions to be inferred

#res = setsResults(MGSA_result)
#subset(res, estimate > 0.5)
```

<br/> Below, for reference, the scoring of all Gene Ontology gene sets considered, and the hyperparameters of the model ( _alpha_ , _beta_, and indirectly _p_ ):

```{r, echo=FALSE, fig.width=9, fig.height=9, warning=FALSE}
#for customisation purposes, let us try to obtain the same plots as plot(MGSA_result)

#set space for 4 plots
par(mfrow=c(2,2))

##p, alpha, beta hyperparameters of the model
## Note this is the information that would be extracted from the original bottom 3 plots

# average number of gene sets expected to be active: p* number of gene sets considered
pPost <- (pPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value)*dim(MGSA_result@setsResults)[1]
# most likely alpha parameter of the model (false positive)
pAlpha <- alphaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value
# most likely beta parameter of the model (false negative rate)
pBeta <- betaPost(MGSA_result)[which.max(pPost(MGSA_result)$estimate), ]$value

title <- paste0("MGSA analysis: \n \n expected active gene sets: ",pPost,"\n alpha (false positives): ", pAlpha, "\n beta (false negatives): ",pBeta)

# TEXT
plot(1:100, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
text(x=50, y=50, title , cex=1.2)

## DOTPLOT

tmp <- data.frame(go_id = colnames(GO_annotations_wide), estimate =MGSA_result@setsResults[["estimate"]])
# sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10] #returns the index of the top 10 scoring sets

plot(seq(1:dim(tmp)[1]),
     tmp$estimate,
     xlab="",
     ylab="Posterior Probability of activation",
     #ylim=c(0,3.6),
     xaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(seq(1:dim(tmp)[1]) %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 0.3))
     )
axis(1, sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10],las=2, cex.axis=0.5, font=2, labels = colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]])
title("Posterior probabilities of activation")
abline(h=0.5,col="grey")
#text(sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], tmp$estimate[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]]-0.04, labels=colnames(GO_annotations_wide)[sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10]], cex=0.7)

#DENSITY PLOT

plot(density(tmp$estimate),
     col= "dodgerblue",
     lwd= 2,
     main="",
     xlab="Posterior probability of activation",
     ylab="Number of GO sets \n with given probability",
     #ylim=range(pretty(c(0, 1)))
     )
abline(v=0.5,col="grey")
title("Distribution of posterior activation probabilities")

#BARPLOT

sorted_tmp <- tmp
sorted_tmp$sd <- MGSA_result@setsResults[["std.error"]]
sorted_tmp$index <- seq(1:dim(sorted_tmp)[1])
sorted_tmp <- sorted_tmp[order(sorted_tmp$estimate, decreasing = TRUE),]
#sorted_tmp <- as.data.frame(sort(sorted_tmp$estimate, index.return=TRUE, decreasing=TRUE))
sorted_tmp$rank <- seq(1:dim(sorted_tmp)[1])
#colnames(sorted_tmp) <- c("estimate", "index", "rank")

plot(sorted_tmp[1:20,]$estimate,
     sorted_tmp[1:20,]$rank,
     xlab="Posterior Probability of activation \n +/- Standard Error",
     ylab="",
     #ylim=c(1,20),
     ylim = rev(range(sorted_tmp[1:20,]$rank)), #so that higher ranks (lower positions) are at the bottom
     yaxt = "n", #remove x axis tikmarks
     #las=1, #this is ignored if defining labels later
     pch=16,
     cex=1,
     col = ifelse(sorted_tmp$index %in% sort(tmp$estimate, index.return=TRUE, decreasing=TRUE)$ix[1:10], "dodgerblue", alpha ("black", 1))
     )
axis(2, sorted_tmp[1:20,]$rank,las=2, 
     cex.axis=0.5, 
     font=2, 
     labels = colnames(GO_annotations_wide)[sorted_tmp[1:20,]$index])
title("Posterior probabilities of activation")
# Add error bars
#https://www.benjaminbell.co.uk/2019/04/how-to-add-error-bars-in-r.html
arrows(x0=sorted_tmp[1:20,]$estimate - sorted_tmp[1:20,]$sd, 
       y0=sorted_tmp[1:20,]$rank, 
       x1=sorted_tmp[1:20,]$estimate+ sorted_tmp[1:20,]$sd, 
       y1=sorted_tmp[1:20,]$rank, 
       code=3, 
       angle=90, 
       length=0.1,
       col = "gray")

```

<br/> For the top scoring pathways, below the list of the actual genes belonging to that pathway that were found in our list of differentially-expressed genes:


```{r, echo=FALSE}
#for the top pathways, print the genes that have been found amongst DE
#sorted_tmp[1:5,1] #is the colnames of GO-annotation_wide we have to extract gene codes from

#for each of the top (e.g.) 15 ranking GO pathways
for (i in seq(1:25)) {
  pathway_genes <- GO_annotations_wide[,sorted_tmp[i,1]][!is.na(GO_annotations_wide[,sorted_tmp[i,1]])] #take the pathway with that label, and the genes that belong to it (i.e. the non-NA entries)
  expressed <- intersect(pathway_genes, ordered_genes_Ensembl) #find which of all pathways genes are actually those found amongst DE genes
  #print(top_table[top_table$ensembl_gene_id %in% expressed, c("FC", "adj.P.Val", "ensembl_gene_id", "description", "AveExpr", "CI.L", "CI.R")])
  print(kable(annotation_info_Ao[annotation_info_Ao$ensembl_ID %in% expressed, c("entrez_ID", "ensembl_ID", "merged_symbol", "merged_description") ], 
              caption= paste0("Genes of GO set:[",sorted_tmp[i,1],"] present amonst genes of interest")))
  
}
     
```


#### sufficient subset











```{r}
splsda.perf <- perf(basic.splsda.model) # undergo performance optimisation
plot(splsda.perf)
```
```{r}
splsda.perf$choice.ncomp
```

```{r}
# note that usually a call in the below line would be more appropriate:
optimal.ncomp <- splsda.perf$choice.ncomp["overall", "centroids.dist"]

#overwrite
optimal.ncomp <- 2
```


```{r}
splsda.tune <- tune(X = X, Y = Y, study = study,  # tune the number of features
                              ncomp = optimal.ncomp,# using optimal comp number
                              test.keepX = seq(1, 100, 1), 
                              method = 'mint.splsda', 
                              measure = 'BER', # balanced error rate
                              dist = "centroids.dist")
```

```{r}
plot(splsda.tune, sd = FALSE)

```


```{r}
optimal.keepX <- splsda.tune$choice.keepX # extract optimal values

optimal.keepX
```
```{r}
final.splsda.model <- mint.splsda(X = X, Y = Y, study = study, 
                                  ncomp = optimal.ncomp, 
                                  keepX = optimal.keepX)
```

```{r, fig.width=12, fig.height=12}
plotIndiv(final.splsda.model, study = 'global', 
          legend = TRUE,
          title = '(a) Stem cells, MINT sPLS-DA',
          subtitle = 'Global', ellipse = T)

plotIndiv(final.splsda.model, study = 'all.partial', 
          legend = TRUE,
          title = '(b) Stem cells, MINT sPLS-DA',
          #subtitle = paste("Study",1:4)
          )
```




```{r}
plotIndiv(final.splsda.model , 
          comp = 1:2, 
          #group = Y, ind.names = FALSE,  # colour points by class
          ellipse = TRUE, # include 95% confidence ellipse for each class
          legend = TRUE, title = '(a) PLSDA with confidence ellipses')




# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(final.splsda.model, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
plotIndiv(final.splsda.model, comp = 1:2,
          group = Y, ind.names = FALSE, # colour points by class
          background = background, # include prediction background for each class
          legend = TRUE, title = " (b) PLSDA with prediction background")

```





```{r}
#loading vectors
test <- as.data.frame(final.splsda.model$loadings$X)
head(test)
#variates
#srbct.splsda$variates 
#variable names
#srbct.splsda$names 
```



```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp1, decreasing = F), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp1 != 0,])]


head(test)

```




```{r, fig.height=3, fig.width=15}
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```

```{r, echo=FALSE}

#plot these genes
test <- test[order(test$comp2, decreasing = T), ] 
selected_genes <- rownames(test)[1:20]
selected_genes <- c(selected_genes, rownames(test)[(nrow(test)-19):nrow(test)])
selected_genes <- selected_genes[selected_genes %in% rownames(test[test$comp2 != 0,])]
counts_VST_selectedgenes <- subset(merged_counts, rownames(merged_counts) %in% selected_genes)

head(test)

```

```{r, fig.height=3, fig.width=15}
#add a column with the ocellaris gene for that orthogroup
rownames(counts_VST_selectedgenes) <- dictionary_orthogroups_best_withHox_genebased$Ao[match(rownames(counts_VST_selectedgenes) ,rownames(dictionary_orthogroups_best_withHox_genebased))]

#add a column with the ocellaris description for that gene
load("C://Users/Doctor/Desktop/RNAseq_analyses/annotation_info_NCBIEnsembl_curated_20240411.rds")
annotation_info_Ao <- annotation_info_NCBIEnsembl
rm(annotation_info_NCBIEnsembl)

rownames(counts_VST_selectedgenes) <- annotation_info_Ao$merged_description[match(rownames(counts_VST_selectedgenes) ,annotation_info_Ao$entrez_ID)] 


Heatmap(as.matrix(counts_VST_selectedgenes),
        cluster_columns = F,
        column_split = merged_metadata$species,
        col = rev(brewer.pal(11,"RdBu"))
        )
```

















